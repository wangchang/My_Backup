<?php
require("../../inc/header.php");

/*
		SoftName : EmpireBak Version 2010
		Author   : wm_chief
		Copyright: Powered by www.phome.net
*/

DoSetDbChar('utf8');
E_D("replace into `wp_posts` values('314','1','2013-04-03 10:40:03','2013-04-03 02:40:03','<blockquote>\n  <p>浅出OpenStack源码系列</p>\n  \n  <p>Quantum WSGI中代码概念及如何处理API</p>\n</blockquote>\n\n<p>在写WSGI的代码分析的过程中，发现要理解WSGI部分的代码，得先理解WSGI如何处理API的过程，这样理解代码会相当快，于是补上此篇文档。</p>\n\n<p>在我前面的基础篇中，我已经讲述了quantum中的api-paste.ini文件如何定义了quantum api的处理流程。这里做一个回顾：</p>\n\n<p>对于v2.0之类的API，使用keystone验证的话，会有以下几个过程：</p>\n\n<pre><code>`/v2.0`（urlmap进行区分）---》读取authtoken段的参数---》与keystone进行交互---》增加extension---》APIRouter\n</code></pre>\n\n<p>上面这个流程是什么意思呢？我跳过认证部分讲：</p>\n\n<p>quantum使用的是REST API，这个API的一个特点就是API的路径，有着重要作用，是作为一个参数传递的，比如一个api:</p>\n\n<pre><code>/v2.0/networks/(the uuid of network).json\n</code></pre>\n\n<p>那么，这个networks加上这个HTTP请求的方法（GET/PUT等）就能决定最终是调用quantum plugin中的哪个函数（函数 get_network），而uuid则会作为一个参数传递，.json则会告诉quantum这个API请求的结果需要以什么形式返回。</p>\n\n<!--more-->\n\n<p>上面这个过程我们换算到程序中就有以下这么些东西：</p>\n\n<h2>WSGI&amp;API</h2>\n\n<p><strong>Application</strong></p>\n\n<p>首先，quantum-server这个WSGI服务器需要一个“东西”，用来处理接收到的API，这个应用在代码中的概念就是一个application，那么这个application要处理些啥呢，如何处理？OK，这就是配置文件api-paste.ini所定义的了，你看，其实api-paste.ini中对一个API的处理分为了很多步骤，是由很多的类或者实例或者管道来联合处理的，这些东西合并在一起，就是一个WSGI Application。在Python.Paste中的loadapp()函数读取api-paste.ini这个配置文件，就生成了这么一个application，可以看到这个app准确的来说不是实例化类这种传统方式得到的，这个app主要就是通过调用不同函数不同实例的方法完成一个动作，所以说，他是一个概念，你可以认为这个application只定义了流程，而没有相应的代码。</p>\n\n<p><strong>Routes</strong></p>\n\n<p>在例子API中，我们说到REST API中这个后缀，专业点的说法就是路径path，很是重要。他能决定quantum最终调用的处理方式，那么如何决定这么个事呢，这个时候就需要引入路由这个概念了，与网络中的路由类似，OpenStack中引入Routes这个库就是可以根据REST API中的path信息进行一个调度。</p>\n\n<p><strong>Router</strong></p>\n\n<p>为了完成调度，肯定就需要一个调度器，这个就是Router，正如api-paste.ini中描述的一个API经过application处理以后最后到达APIRouter，这个API Router根据自己生成的路由规则把相应的API内容调度到一个处理它的东西上（controller,如下）。</p>\n\n<p>由于quantum api有核心api和扩展api，所以api-paste.ini中定义的extension其实再载入了相应扩展API定义以后也会生成一个Router，处理扩展API相关，这个下面会讲。</p>\n\n<p><strong>Routes Table：</strong></p>\n\n<p>既然是路由，那么就需要一个路由表了，这个路由表的作用就是让程序能够根据REST API的path信息将相应的操作传递到一个处理它的“东西上”，这个“东西”是什么呢？名字就叫controller：</p>\n\n<p><strong>controller</strong></p>\n\n<p>controller是什么意思？controller就是一个调度器，我们知道，quantum api的操作其实都是plugin来完成的，那么最基本的，肯定是使用plugin中的函数来完成。前面的路由routes，只能根据一定的规则把path路径或者HTTP的body参数路由到一个controller，那么这个controller，要做的就是根据传递过来的信息，plugin中需要执行操作的函数，并调用这个函数，当然，controller也会把body信息(如果有)传递给plugin相关函数。OK，到这里，我必须引入quantum api中的一些基本概念了。</p>\n\n<p><strong>resource</strong></p>\n\n<p>从quantum api中就可以看出来，resource就是一个需要操作的资源，多个resource的集合就是resources,举个例子，quantum中三大概念，network,subnet,port，我们假设API形式为/v2.0/port/XXX /v2.0/network/XXX 这些中的port,network就是resource，那么多个resouce和在一起，就是resources了撒，不过quantum给他换了个名字，叫collection，所以quantum中的REST API都是/v2.0/ports/XXX /v2.0/networks/XXX这种了，因为resource，collection这个词会在代码中出现，所以你明白他是什么意思就OK了！简单一个以quantum中network的总结：</p>\n\n<pre><code>networks = collection\nnetwork = resource\n</code></pre>\n\n<p>我举一个简单的route中添加路由表的例子，仅作举例，不懂的话没关系，以后会深入讲：</p>\n\n<pre><code>from routes import Mapper  \nmap = Mapper()  \nmap.connect(None, \"/error/{action}/{id}, controller=\"error\")  \nmap.connect(\"home\", \"/\", controller=\"main\", action=\"index\")  \n\n# Match a URL, returns a dict or None if no match  \nresult = map.match(''/error/myapp/4'')  \n# result == {''controller'': ''main'', ''action'': ''myapp'', ''id'': ''4''}  \n</code></pre>\n\n<p><strong>action</strong></p>\n\n<p>在routes表中，我们注意有一个action,这个在代码中也会涉及，action是啥意思，我们知道HTTP请求中GET PUT POST等方法，对应需要的操作，那么在quantum代码中，我们不这样叫，我们把HTTP的方法映射到对资源的action（操作上），这个映射关系如下所示，这个图中，collection就是上面的概念resources，而这其实也是一个简单的routes表了，不过目前我们只需要看看action和method的对应。</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/routepath.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/routepath.png\" alt=\"routepath\" width=\"888\" height=\"170\" class=\"aligncenter size-full wp-image-308\" /></a></p>\n\n<h2>API&amp;扩展API</h2>\n\n<p>Quantum是有两类API的，一类是核心API，包括networks,ports,subnets的API，这个API的Router是通过api-paste.ini中的APIRouter来进行的，同时你可以扩展API，相应的扩展都在quantum/extensions目录下，你可以把自己定义的resoucre加入到扩展中，形成扩展API，这一部分后续文章讲，现在只是基础概念。而扩展API的Router其实是在api-paste.ini中调用extension_middleware完成的，所以，整个流程可以如下两个图，这两个图体现了本文全部内容：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/loadapp.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/loadapp.png\" alt=\"loadapp\" width=\"794\" height=\"547\" class=\"aligncenter size-full wp-image-309\" /></a></p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/http.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/http.png\" alt=\"http\" width=\"687\" height=\"634\" class=\"aligncenter size-full wp-image-310\" /></a></p>\n','Quantum WSGI中代码概念及如何处理API','','inherit','open','open','','303-revision-3','','','2013-04-03 10:40:03','2013-04-03 02:40:03','','303','http://blog.wachang.net/2013/04/303-revision-3/','0','revision','','0');");
E_D("replace into `wp_posts` values('315','1','2013-04-03 15:26:41','2013-04-03 07:26:41','<p>原文链接：</p>\n\n<p><a href=\"http://www.iplaysoft.com/top10-programming-fonts.html\">10大最适合编程的字体推荐下载，让代码看起来更美更舒服！</a></p>\n\n<p><a href=\"http://hivelogic.com/articles/top-10-programming-fonts/\">英文原版</a></p>\n\n<!--more-->\n\n<h2>10. Courier</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/courier.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/courier.png\" alt=\"courier\" width=\"518\" height=\"221\" class=\"aligncenter size-full wp-image-316\" /></a></p>\n\n<h2>9. Andale Mono</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/andale.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/andale.png\" alt=\"andale\" width=\"458\" height=\"206\" class=\"aligncenter size-full wp-image-317\" /></a></p>\n\n<h2>8. Monaco</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/monaco.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/monaco.png\" alt=\"monaco\" width=\"436\" height=\"238\" class=\"aligncenter size-full wp-image-318\" /></a></p>\n\n<h2>7. Profont</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/profont.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/profont.png\" alt=\"profont\" width=\"336\" height=\"153\" class=\"aligncenter size-full wp-image-319\" /></a></p>\n\n<h2>6. Monofur</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/monofur.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/monofur.png\" alt=\"monofur\" width=\"393\" height=\"184\" class=\"aligncenter size-full wp-image-320\" /></a></p>\n\n<h2>5. Proggy</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/proggy.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/proggy.png\" alt=\"proggy\" width=\"361\" height=\"157\" class=\"aligncenter size-full wp-image-321\" /></a></p>\n\n<h2>4. Droid Sans Mono</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/droid-sans.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/droid-sans.png\" alt=\"droid sans\" width=\"440\" height=\"213\" class=\"aligncenter size-full wp-image-322\" /></a></p>\n\n<h2>3. Deja Vu Sans Mono</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/deja-vu-sans.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/deja-vu-sans.png\" alt=\"deja vu sans\" width=\"461\" height=\"214\" class=\"aligncenter size-full wp-image-323\" /></a></p>\n\n<h2>2. Consolas + 中文雅黑混合版</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/consolas.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/consolas.png\" alt=\"consolas\" width=\"478\" height=\"201\" class=\"aligncenter size-full wp-image-324\" /></a></p>\n\n<h2>1. Inconsolata</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/inconsolata.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/inconsolata.png\" alt=\"inconsolata\" width=\"462\" height=\"195\" class=\"aligncenter size-full wp-image-325\" /></a></p>\n\n<p><code>所有字体打包下载：</code></p>\n\n<p>[wpdm_file id=3]</p>\n','[转]十大编程字体','','publish','open','open','','coding-fonts','','','2013-04-23 12:40:59','2013-04-23 04:40:59','','0','http://blog.wachang.net/?p=315','0','post','','0');");
E_D("replace into `wp_posts` values('316','1','2013-04-03 15:12:03','2013-04-03 07:12:03','','courier','','inherit','open','open','','courier','','','2013-04-03 15:12:03','2013-04-03 07:12:03','','315','http://blog.wachang.net/wp-content/uploads/2013/04/courier.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('317','1','2013-04-03 15:13:16','2013-04-03 07:13:16','','andale','','inherit','open','open','','andale','','','2013-04-03 15:13:16','2013-04-03 07:13:16','','315','http://blog.wachang.net/wp-content/uploads/2013/04/andale.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('318','1','2013-04-03 15:14:24','2013-04-03 07:14:24','','monaco','','inherit','open','open','','monaco','','','2013-04-03 15:14:24','2013-04-03 07:14:24','','315','http://blog.wachang.net/wp-content/uploads/2013/04/monaco.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('319','1','2013-04-03 15:15:10','2013-04-03 07:15:10','','profont','','inherit','open','open','','profont','','','2013-04-03 15:15:10','2013-04-03 07:15:10','','315','http://blog.wachang.net/wp-content/uploads/2013/04/profont.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('320','1','2013-04-03 15:15:48','2013-04-03 07:15:48','','monofur','','inherit','open','open','','monofur','','','2013-04-03 15:15:48','2013-04-03 07:15:48','','315','http://blog.wachang.net/wp-content/uploads/2013/04/monofur.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('321','1','2013-04-03 15:16:34','2013-04-03 07:16:34','','proggy','','inherit','open','open','','proggy','','','2013-04-03 15:16:34','2013-04-03 07:16:34','','315','http://blog.wachang.net/wp-content/uploads/2013/04/proggy.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('322','1','2013-04-03 15:17:25','2013-04-03 07:17:25','','droid sans','','inherit','open','open','','droid-sans','','','2013-04-03 15:17:25','2013-04-03 07:17:25','','315','http://blog.wachang.net/wp-content/uploads/2013/04/droid-sans.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('323','1','2013-04-03 15:18:22','2013-04-03 07:18:22','','deja vu sans','','inherit','open','open','','deja-vu-sans','','','2013-04-03 15:18:22','2013-04-03 07:18:22','','315','http://blog.wachang.net/wp-content/uploads/2013/04/deja-vu-sans.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('324','1','2013-04-03 15:19:04','2013-04-03 07:19:04','','consolas','','inherit','open','open','','consolas','','','2013-04-03 15:19:04','2013-04-03 07:19:04','','315','http://blog.wachang.net/wp-content/uploads/2013/04/consolas.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('325','1','2013-04-03 15:20:36','2013-04-03 07:20:36','','inconsolata','','inherit','open','open','','inconsolata','','','2013-04-03 15:20:36','2013-04-03 07:20:36','','315','http://blog.wachang.net/wp-content/uploads/2013/04/inconsolata.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('326','1','2013-04-03 15:23:50','2013-04-03 07:23:50','','编程字体','','inherit','open','open','','%e7%bc%96%e7%a8%8b%e5%ad%97%e4%bd%93','','','2013-04-03 15:23:50','2013-04-03 07:23:50','','0','http://blog.wachang.net/wp-content/uploads/2013/04/编程字体.rar','0','attachment','application/rar','0');");
E_D("replace into `wp_posts` values('327','1','2013-04-03 15:26:17','2013-04-03 07:26:17','<p>原文链接：</p>\n\n<p><a href=\"http://www.iplaysoft.com/top10-programming-fonts.html\">10大最适合编程的字体推荐下载，让代码看起来更美更舒服！</a></p>\n\n<p><a href=\"http://hivelogic.com/articles/top-10-programming-fonts/\">英文原版</a></p>\n\n<!--more-->\n\n<h2>10. Courier</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/courier.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/courier.png\" alt=\"courier\" width=\"518\" height=\"221\" class=\"aligncenter size-full wp-image-316\" /></a></p>\n\n<h2>9. Andale Mono</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/andale.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/andale.png\" alt=\"andale\" width=\"458\" height=\"206\" class=\"aligncenter size-full wp-image-317\" /></a></p>\n\n<h2>8. Monaco</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/monaco.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/monaco.png\" alt=\"monaco\" width=\"436\" height=\"238\" class=\"aligncenter size-full wp-image-318\" /></a></p>\n\n<h2>7. Profont</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/profont.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/profont.png\" alt=\"profont\" width=\"336\" height=\"153\" class=\"aligncenter size-full wp-image-319\" /></a></p>\n\n<h2>6. Monofur</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/monofur.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/monofur.png\" alt=\"monofur\" width=\"393\" height=\"184\" class=\"aligncenter size-full wp-image-320\" /></a></p>\n\n<h2>5. Proggy</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/proggy.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/proggy.png\" alt=\"proggy\" width=\"361\" height=\"157\" class=\"aligncenter size-full wp-image-321\" /></a></p>\n\n<h2>4. Droid Sans Mono</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/droid-sans.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/droid-sans.png\" alt=\"droid sans\" width=\"440\" height=\"213\" class=\"aligncenter size-full wp-image-322\" /></a></p>\n\n<h2>3. Deja Vu Sans Mono</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/deja-vu-sans.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/deja-vu-sans.png\" alt=\"deja vu sans\" width=\"461\" height=\"214\" class=\"aligncenter size-full wp-image-323\" /></a></p>\n\n<h2>2. Consolas + 中文雅黑混合版</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/consolas.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/consolas.png\" alt=\"consolas\" width=\"478\" height=\"201\" class=\"aligncenter size-full wp-image-324\" /></a></p>\n\n<h2>1. Inconsolata</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/inconsolata.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/inconsolata.png\" alt=\"inconsolata\" width=\"462\" height=\"195\" class=\"aligncenter size-full wp-image-325\" /></a></p>\n\n<p>所有字体打包下载：</p>\n\n<p>[wpdm_file id=3]</p>\n','[转]十大编程字体','','inherit','open','open','','315-revision','','','2013-04-03 15:26:17','2013-04-03 07:26:17','','315','http://blog.wachang.net/2013/04/315-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('328','1','2013-04-03 15:40:40','2013-04-03 07:40:40','<p>wordpress的特点：</p>\n\n<ul>\n<li>所有文章，评论，插件配置信息全部存放于数据库中。</li>\n<li>备份wordpress的主程序文件其实没啥意思，因为是php就是一些脚本而已，但是主题文件夹和插件文件夹和附件文件夹一定要备份，恢复的时候覆盖就可以了！</li>\n<li>重点备份plugins,themes,uploads三个文件夹，恢复的时候直接覆盖就好。</li>\n</ul>\n\n<p>所以，备份wordpress的核心就是，<code>数据库+plugins,themes,uploads文件夹。</code></p>\n\n<!--more-->\n\n<h2>1 备份恢复方法总结</h2>\n\n<h3>phpmyadmin导出数据库，FTP备份恢复相关文件</h3>\n\n<p>但是貌似有点受限于主机提供商。</p>\n\n<h3>WordPress自带的xml导出导入功能。</h3>\n\n<p>能很好的备份文章，但是据说不能备份<code>插件和主题设置</code>，这个就很痛苦了。</p>\n\n<h3>帝国备份王</h3>\n\n<p>一个php程序备份数据库，据说，非常完美。但是我看最新的版本也就是2010年的了，不知道效果怎么样。</p>\n\n<h2>2 我的备份方案</h2>\n\n<p>我自己博客的备份方案：</p>\n\n<ul>\n<li>因为我文章是markdown格式，很通用，在github上My_Backup/posts/中备份所有的文章。</li>\n<li>数据库就用帝国备份来吧，备份文件不大，放在My_Backup/wordpress/db/中</li>\n<li>为了保证数据库备份不出错，就再做一个mydql dump命令的备份吧，放在My_Backup/wordpress/db/xxx.sql中</li>\n<li>把plugins,themes,uploads做一个备份，放在My_Backup/wordpress/{plugins,themes,uploads}中</li>\n<li>使用wordpress自带的导入导出工具，放在My_Backup/wordpress/xml中</li>\n</ul>\n\n<p>这样看来，不管怎么样，我都可以很好的恢复了吧。</p>\n\n<h2>3 参考文章</h2>\n\n<p><a href=\"http://zmingcx.com/wordpress-backup-and-recovery.html\">http://zmingcx.com/wordpress-backup-and-recovery.html</a></p>\n\n<p><a href=\"http://www.kay1987.com/887\">http://www.kay1987.com/887</a></p>\n\n<p><a href=\"http://www.phome.net/\">http://www.phome.net/</a></p>\n','记录一下Wordpress博客的备份和恢复','','inherit','open','open','','187-autosave','','','2013-04-03 15:40:40','2013-04-03 07:40:40','','187','http://blog.wachang.net/2013/04/187-autosave/','0','revision','','0');");
E_D("replace into `wp_posts` values('329','1','2013-03-20 20:57:47','2013-03-20 12:57:47','<p>wordpress的特点：</p>\n\n<ul>\n<li>所有文章，评论，插件配置信息全部存放于数据库中。</li>\n<li>备份wordpress的主程序文件其实没啥意思，因为是php就是一些脚本而已，但是主题文件夹和插件文件夹和附件文件夹一定要备份，恢复的时候覆盖就可以了！</li>\n<li>重点备份plugins,themes,uploads三个文件夹，恢复的时候直接覆盖就好。</li>\n</ul>\n\n<p>所以，备份wordpress的核心就是，<code>数据库+plugins,themes,uploads文件夹。</code></p>\n\n<!--more-->\n\n<h2>1 备份恢复方法总结</h2>\n\n<h3>phpmyadmin导出数据库，FTP备份恢复相关文件</h3>\n\n<p>但是貌似有点受限于主机提供商。</p>\n\n<h3>WordPress自带的xml导出导入功能。</h3>\n\n<p>能很好的备份文章，但是据说不能备份<code>插件和主题设置</code>，这个就很痛苦了。</p>\n\n<h3>帝国备份王</h3>\n\n<p>一个php程序备份数据库，据说，非常完美。但是我看最新的版本也就是2010年的了，不知道效果怎么样。</p>\n\n<h2>2 我的备份方案</h2>\n\n<p>我自己博客的备份方案：</p>\n\n<ul>\n<li>因为我文章是markdown格式，很通用，在github上My_Backup/posts/中备份所有的文章。</li>\n<li>数据库就用帝国备份来吧，备份文件不大，放在My_Backup/wordpress/db/中</li>\n<li>为了保证数据库备份不出错，就再做一个mydql dump命令的备份吧，放在My_Backup/wordpress/db/xxx.sql中</li>\n<li>把plugins,themes,uploads做一个备份，放在My_Backup/wordpress/{plugins,themes,uploads}中</li>\n<li>使用wordpress自带的导入导出工具，放在My_Backup/wordpress/xml中</li>\n</ul>\n\n<p>这样看来，不管怎么样，我都可以很好的恢复了吧。</p>\n\n<h2>3 参考文章</h2>\n\n<p><a href=\"http://zmingcx.com/wordpress-backup-and-recovery.html\">http://zmingcx.com/wordpress-backup-and-recovery.html</a>\n<a href=\"http://www.kay1987.com/887\">http://www.kay1987.com/887</a>\n<a href=\"http://www.phome.net/\">http://www.phome.net/</a></p>\n','记录一下Wordpress博客的备份和恢复','','inherit','open','open','','187-revision-2','','','2013-03-20 20:57:47','2013-03-20 12:57:47','','187','http://blog.wachang.net/2013/03/187-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('330','1','2013-04-03 10:43:49','2013-04-03 02:43:49','<blockquote>\n  <p>浅出OpenStack源码系列</p>\n  \n  <p>Quantum WSGI中代码概念及如何处理API</p>\n</blockquote>\n\n<p>在写WSGI的代码分析的过程中，发现要理解WSGI部分的代码，得先理解WSGI如何处理API的过程，这样理解代码会相当快，于是补上此篇文档。</p>\n\n<p>在我前面的基础篇中，我已经讲述了quantum中的api-paste.ini文件如何定义了quantum api的处理流程。这里做一个回顾：</p>\n\n<p>对于v2.0之类的API，使用keystone验证的话，会有以下几个过程：</p>\n\n<pre><code>`/v2.0`（urlmap进行区分）---》读取authtoken段的参数---》与keystone进行交互---》增加extension---》APIRouter\n</code></pre>\n\n<p>上面这个流程是什么意思呢？我跳过认证部分讲：</p>\n\n<p>quantum使用的是REST API，这个API的一个特点就是API的路径，有着重要作用，是作为一个参数传递的，比如一个api:</p>\n\n<pre><code>/v2.0/networks/(the uuid of network).json\n</code></pre>\n\n<p>那么，这个networks加上这个HTTP请求的方法（GET/PUT等）就能决定最终是调用quantum plugin中的哪个函数（函数 get_network），而uuid则会作为一个参数传递，.json则会告诉quantum这个API请求的结果需要以什么形式返回。</p>\n\n<!--more-->\n\n<p>上面这个过程我们换算到程序中就有以下这么些东西：</p>\n\n<h2>WSGI&amp;API</h2>\n\n<p><strong>Application</strong></p>\n\n<p>首先，quantum-server这个WSGI服务器需要一个“东西”，用来处理接收到的API，这个应用在代码中的概念就是一个application，那么这个application要处理些啥呢，如何处理？OK，这就是配置文件api-paste.ini所定义的了，你看，其实api-paste.ini中对一个API的处理分为了很多步骤，是由很多的类或者实例或者管道来联合处理的，这些东西合并在一起，就是一个WSGI Application。在Python.Paste中的loadapp()函数读取api-paste.ini这个配置文件，就生成了这么一个application，可以看到这个app准确的来说不是实例化类这种传统方式得到的，这个app主要就是通过调用不同函数不同实例的方法完成一个动作，所以说，他是一个概念，你可以认为这个application只定义了流程，而没有相应的代码。</p>\n\n<p><strong>Routes</strong></p>\n\n<p>在例子API中，我们说到REST API中这个后缀，专业点的说法就是路径path，很是重要。他能决定quantum最终调用的处理方式，那么如何决定这么个事呢，这个时候就需要引入路由这个概念了，与网络中的路由类似，OpenStack中引入Routes这个库就是可以根据REST API中的path信息进行一个调度。</p>\n\n<p><strong>Router</strong></p>\n\n<p>为了完成调度，肯定就需要一个调度器，这个就是Router，正如api-paste.ini中描述的一个API经过application处理以后最后到达APIRouter，这个API Router根据自己生成的路由规则把相应的API内容调度到一个处理它的东西上（controller,如下）。</p>\n\n<p>由于quantum api有核心api和扩展api，所以api-paste.ini中定义的extension其实再载入了相应扩展API定义以后也会生成一个Router，处理扩展API相关，这个下面会讲。</p>\n\n<p><strong>Routes Table：</strong></p>\n\n<p>既然是路由，那么就需要一个路由表了，这个路由表的作用就是让程序能够根据REST API的path信息将相应的操作传递到一个处理它的“东西上”，这个“东西”是什么呢？名字就叫controller：</p>\n\n<p><strong>controller</strong></p>\n\n<p>controller是什么意思？controller就是一个调度器，我们知道，quantum api的操作其实都是plugin来完成的，那么最基本的，肯定是使用plugin中的函数来完成。前面的路由routes，只能根据一定的规则把path路径或者HTTP的body参数路由到一个controller，那么这个controller，要做的就是根据传递过来的信息，plugin中需要执行操作的函数，并调用这个函数，当然，controller也会把body信息(如果有)传递给plugin相关函数。OK，到这里，我必须引入quantum api中的一些基本概念了。</p>\n\n<p><strong>resource</strong></p>\n\n<p>从quantum api中就可以看出来，resource就是一个需要操作的资源，多个resource的集合就是resources,举个例子，quantum中三大概念，network,subnet,port，我们假设API形式为/v2.0/port/XXX /v2.0/network/XXX 这些中的port,network就是resource，那么多个resouce和在一起，就是resources了撒，不过quantum给他换了个名字，叫collection，所以quantum中的REST API都是/v2.0/ports/XXX /v2.0/networks/XXX这种了，因为resource，collection这个词会在代码中出现，所以你明白他是什么意思就OK了！简单一个以quantum中network的总结：</p>\n\n<pre><code>networks = collection\nnetwork = resource\n</code></pre>\n\n<p>我举一个简单的route中添加路由表的例子，仅作举例，不懂的话没关系，以后会深入讲：</p>\n\n<pre><code>from routes import Mapper  \nmap = Mapper()  \nmap.connect(None, \"/error/{action}/{id}, controller=\"error\")  \nmap.connect(\"home\", \"/\", controller=\"main\", action=\"index\")  \n\n# Match a URL, returns a dict or None if no match  \nresult = map.match(''/error/myapp/4'')  \n# result == {''controller'': ''main'', ''action'': ''myapp'', ''id'': ''4''}  \n</code></pre>\n\n<p><strong>action</strong></p>\n\n<p>在routes表中，我们注意有一个action,这个在代码中也会涉及，action是啥意思，我们知道HTTP请求中GET PUT POST等方法，对应需要的操作，那么在quantum代码中，我们不这样叫，我们把HTTP的方法映射到对资源的action（操作上），这个映射关系如下所示，这个图中，collection就是上面的概念resources，而这其实也是一个简单的routes表了，不过目前我们只需要看看action和method的对应。</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/routepath.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/routepath.png\" alt=\"routepath\" width=\"888\" height=\"170\" class=\"aligncenter size-full wp-image-308\" /></a></p>\n\n<p>整个上面所说的其实都是一个<strong>MVC（模型-视图-控制）</strong>框架，这是一个软件开发方式，可以自己学习一下,可以更好的理解OpenStack各个组件的REST API思想（用了python各种库来实现了一个MVC）。</p>\n\n<h2>API&amp;扩展API</h2>\n\n<p>Quantum是有两类API的，一类是核心API，包括networks,ports,subnets的API，这个API的Router是通过api-paste.ini中的APIRouter来进行的，同时你可以扩展API，相应的扩展都在quantum/extensions目录下，你可以把自己定义的resoucre加入到扩展中，形成扩展API，这一部分后续文章讲，现在只是基础概念。而扩展API的Router其实是在api-paste.ini中调用extension_middleware完成的，所以，整个流程可以如下两个图，这两个图体现了本文全部内容：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/loadapp.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/loadapp.png\" alt=\"loadapp\" width=\"794\" height=\"547\" class=\"aligncenter size-full wp-image-309\" /></a></p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/http.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/http.png\" alt=\"http\" width=\"687\" height=\"634\" class=\"aligncenter size-full wp-image-310\" /></a></p>\n','Quantum WSGI中代码概念及如何处理API','','inherit','open','open','','303-revision-4','','','2013-04-03 10:43:49','2013-04-03 02:43:49','','303','http://blog.wachang.net/2013/04/303-revision-4/','0','revision','','0');");
E_D("replace into `wp_posts` values('331','1','2013-04-07 10:20:20','2013-04-07 02:20:20','<blockquote>\n  <p>浅出OpenStack源码系列</p>\n  \n  <p>Quantum WSGI中代码概念及如何处理API</p>\n</blockquote>\n\n<p>在写WSGI的代码分析的过程中，发现要理解WSGI部分的代码，得先理解WSGI如何处理API的过程，这样理解代码会相当快，于是补上此篇文档。</p>\n\n<p>在我前面的基础篇中，我已经讲述了quantum中的api-paste.ini文件如何定义了quantum api的处理流程。这里做一个回顾：</p>\n\n<p>对于v2.0之类的API，使用keystone验证的话，会有以下几个过程：</p>\n\n<pre><code>`/v2.0`（urlmap进行区分）---》读取authtoken段的参数---》与keystone进行交互---》增加extension---》APIRouter\n</code></pre>\n\n<p>上面这个流程是什么意思呢？我跳过认证部分讲：</p>\n\n<p>quantum使用的是REST API，这个API的一个特点就是API的路径，有着重要作用，是作为一个参数传递的，比如一个api:</p>\n\n<pre><code>/v2.0/networks/(the uuid of network).json\n</code></pre>\n\n<p>那么，这个networks加上这个HTTP请求的方法（GET/PUT等）就能决定最终是调用quantum plugin中的哪个函数（函数 get_network），而uuid则会作为一个参数传递，.json则会告诉quantum这个API请求的结果需要以什么形式返回。</p>\n\n<!--more-->\n\n<p>上面这个过程我们换算到程序中就有以下这么些东西：</p>\n\n<h2>WSGI&amp;API</h2>\n\n<p><strong>Application</strong></p>\n\n<p>首先，quantum-server这个WSGI服务器需要一个“东西”，用来处理接收到的API，这个应用在代码中的概念就是一个application，那么这个application要处理些啥呢，如何处理？OK，这就是配置文件api-paste.ini所定义的了，你看，其实api-paste.ini中对一个API的处理分为了很多步骤，是由很多的类或者实例或者管道来联合处理的，这些东西合并在一起，就是一个WSGI Application。在Python.Paste中的loadapp()函数读取api-paste.ini这个配置文件，就生成了这么一个application，可以看到这个app准确的来说不是实例化类这种传统方式得到的，这个app主要就是通过调用不同函数不同实例的方法完成一个动作，所以说，他是一个概念，你可以认为这个application只定义了流程，而没有相应的代码。在api-paste.ini文件中的第一段:</p>\n\n<pre><code>[composite:quantum]\nuse = egg:Paste#urlmap\n/: quantumversions\n/v2.0: quantumapi_v2_0\n</code></pre>\n\n<p>如上，这个application（的名字）就叫做quantum。</p>\n\n<p><strong>Routes</strong></p>\n\n<p>在例子API中，我们说到REST API中这个后缀，专业点的说法就是路径path，很是重要。他能决定quantum最终调用的处理方式，那么如何决定这么个事呢，这个时候就需要引入路由这个概念了，与网络中的路由类似，OpenStack中引入Routes这个库就是可以根据REST API中的path信息进行一个调度。</p>\n\n<p><strong>Router</strong></p>\n\n<p>为了完成调度，肯定就需要一个调度器，这个就是Router，正如api-paste.ini中描述的一个API经过application处理以后最后到达APIRouter，这个API Router根据自己生成的路由规则把相应的API内容调度到一个处理它的东西上（controller,如下）。</p>\n\n<p>由于quantum api有核心api和扩展api，所以api-paste.ini中定义的extension其实再载入了相应扩展API定义以后也会生成一个Router，处理扩展API相关，这个下面会讲。</p>\n\n<p><strong>Routes Table：</strong></p>\n\n<p>既然是路由，那么就需要一个路由表了，这个路由表的作用就是让程序能够根据REST API的path信息将相应的操作传递到一个处理它的“东西上”，这个“东西”是什么呢？名字就叫controller：</p>\n\n<p><strong>controller</strong></p>\n\n<p>controller是什么意思？controller就是一个调度器，我们知道，quantum api的操作其实都是plugin来完成的，那么最基本的，肯定是使用plugin中的函数来完成。前面的路由routes，只能根据一定的规则把path路径或者HTTP的body参数路由到一个controller，那么这个controller，要做的就是根据传递过来的信息，plugin中需要执行操作的函数，并调用这个函数，当然，controller也会把body信息(如果有)传递给plugin相关函数。OK，到这里，我必须引入quantum api中的一些基本概念了。</p>\n\n<p><strong>resource</strong></p>\n\n<p>从quantum api中就可以看出来，resource就是一个需要操作的资源，多个resource的集合就是resources,举个例子，quantum中三大概念，network,subnet,port，我们假设API形式为/v2.0/port/XXX /v2.0/network/XXX 这些中的port,network就是resource，那么多个resouce和在一起，就是resources了撒，不过quantum给他换了个名字，叫collection，所以quantum中的REST API都是/v2.0/ports/XXX /v2.0/networks/XXX这种了，因为resource，collection这个词会在代码中出现，所以你明白他是什么意思就OK了！简单一个以quantum中network的总结：</p>\n\n<pre><code>networks = collection\nnetwork = resource\n</code></pre>\n\n<p>我举一个简单的route中添加路由表的例子，仅作举例，不懂的话没关系，以后会深入讲：</p>\n\n<pre><code>from routes import Mapper  \nmap = Mapper()  \nmap.connect(None, \"/error/{action}/{id}, controller=\"error\")  \nmap.connect(\"home\", \"/\", controller=\"main\", action=\"index\")  \n\n# Match a URL, returns a dict or None if no match  \nresult = map.match(''/error/myapp/4'')  \n# result == {''controller'': ''main'', ''action'': ''myapp'', ''id'': ''4''}  \n</code></pre>\n\n<p><strong>action</strong></p>\n\n<p>在routes表中，我们注意有一个action,这个在代码中也会涉及，action是啥意思，我们知道HTTP请求中GET PUT POST等方法，对应需要的操作，那么在quantum代码中，我们不这样叫，我们把HTTP的方法映射到对资源的action（操作上），这个映射关系如下所示，这个图中，collection就是上面的概念resources，而这其实也是一个简单的routes表了，不过目前我们只需要看看action和method的对应。</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/routepath.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/routepath.png\" alt=\"routepath\" width=\"888\" height=\"170\" class=\"aligncenter size-full wp-image-308\" /></a></p>\n\n<p>整个上面所说的其实都是一个<strong>MVC（模型-视图-控制）</strong>框架，这是一个软件开发方式，可以自己学习一下,可以更好的理解OpenStack各个组件的REST API思想（用了python各种库来实现了一个MVC）。</p>\n\n<h2>API&amp;扩展API</h2>\n\n<p>Quantum是有两类API的，一类是核心API，包括networks,ports,subnets的API，这个API的Router是通过api-paste.ini中的APIRouter来进行的，同时你可以扩展API，相应的扩展都在quantum/extensions目录下，你可以把自己定义的resoucre加入到扩展中，形成扩展API，这一部分后续文章讲，现在只是基础概念。而扩展API的Router其实是在api-paste.ini中调用extension_middleware完成的，所以，整个流程可以如下两个图，这两个图体现了本文全部内容：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/loadapp.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/loadapp.png\" alt=\"loadapp\" width=\"794\" height=\"547\" class=\"aligncenter size-full wp-image-309\" /></a></p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/http.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/http.png\" alt=\"http\" width=\"687\" height=\"634\" class=\"aligncenter size-full wp-image-310\" /></a></p>\n','Quantum WSGI中代码概念及如何处理API','','inherit','open','open','','303-revision-5','','','2013-04-07 10:20:20','2013-04-07 02:20:20','','303','http://blog.wachang.net/2013/04/303-revision-5/','0','revision','','0');");
E_D("replace into `wp_posts` values('332','1','2013-04-07 10:48:50','2013-04-07 02:48:50','<blockquote>\n  <p>浅出OpenStack源码系列</p>\n  \n  <p>Quantum WSGI中代码概念及如何处理API</p>\n</blockquote>\n\n<p>在写WSGI的代码分析的过程中，发现要理解WSGI部分的代码，得先理解WSGI如何处理API的过程，这样理解代码会相当快，于是补上此篇文档。</p>\n\n<p>在我前面的基础篇中，我已经讲述了quantum中的api-paste.ini文件如何定义了quantum api的处理流程。这里做一个回顾：</p>\n\n<p>对于v2.0之类的API，使用keystone验证的话，会有以下几个过程：</p>\n\n<pre><code>`/v2.0`（urlmap进行区分）---》读取authtoken段的参数---》与keystone进行交互---》增加extension---》APIRouter\n</code></pre>\n\n<p>上面这个流程是什么意思呢？我跳过认证部分讲：</p>\n\n<p>quantum使用的是REST API，这个API的一个特点就是API的路径，有着重要作用，是作为一个参数传递的，比如一个api:</p>\n\n<pre><code>/v2.0/networks/(the uuid of network).json\n</code></pre>\n\n<p>那么，这个networks加上这个HTTP请求的方法（GET/PUT等）就能决定最终是调用quantum plugin中的哪个函数（函数 get_network），而uuid则会作为一个参数传递，.json则会告诉quantum这个API请求的结果需要以什么形式返回。</p>\n\n<!--more-->\n\n<p>上面这个过程我们换算到程序中就有以下这么些东西：</p>\n\n<h2>WSGI&amp;API</h2>\n\n<p><strong>Application</strong></p>\n\n<p>首先，quantum-server这个WSGI服务器需要一个“东西”，用来处理接收到的API，这个应用在代码中的概念就是一个application，那么这个application要处理些啥呢，如何处理？OK，这就是配置文件api-paste.ini所定义的了，你看，其实api-paste.ini中对一个API的处理分为了很多步骤，是由很多的类或者实例或者管道来联合处理的，那么，这些类的实例，就是一个application，所以中，api-paste.ini文件中定义了多个application，在Python.Paste中的loadapp()函数读取api-paste.ini这个配置文件，就生成了这么一个抽象的application，可以看到这个app准确的来说不是实例化类这种传统方式得到的，这个app主要就是通过调用不同函数不同实例的方法完成一个动作，所以说，他是一个概念，你可以认为这个application只定义了流程，而没有相应的代码。在api-paste.ini文件中的第一段:</p>\n\n<pre><code>[composite:quantum]\nuse = egg:Paste#urlmap\n/: quantumversions\n/v2.0: quantumapi_v2_0\n</code></pre>\n\n<p>如上，这个application（的名字）就叫做quantum。这个其实是个抽象的application,而后面的一些配置：</p>\n\n<pre><code>[app:quantumversions]\npaste.app_factory = quantum.api.versions:Versions.factory\n</code></pre>\n\n<p>这里也定义了一个app，这个当然就有具体的代码和实例了。</p>\n\n<p><strong>Routes</strong></p>\n\n<p>在例子API中，我们说到REST API中这个后缀，专业点的说法就是路径path，很是重要。他能决定quantum最终调用的处理方式，那么如何决定这么个事呢，这个时候就需要引入路由这个概念了，与网络中的路由类似，OpenStack中引入Routes这个库就是可以根据REST API中的path信息进行一个调度。</p>\n\n<p><strong>Router</strong></p>\n\n<p>为了完成调度，肯定就需要一个调度器，这个就是Router，正如api-paste.ini中描述的一个API经过application处理以后最后到达APIRouter，这个API Router根据自己生成的路由规则把相应的API内容调度到一个处理它的东西上（controller,如下）。</p>\n\n<p>由于quantum api有核心api和扩展api，所以api-paste.ini中定义的extension其实再载入了相应扩展API定义以后也会生成一个Router，处理扩展API相关，这个下面会讲。</p>\n\n<p><strong>Routes Table：</strong></p>\n\n<p>既然是路由，那么就需要一个路由表了，这个路由表的作用就是让程序能够根据REST API的path信息将相应的操作传递到一个处理它的“东西上”，这个“东西”是什么呢？名字就叫controller：</p>\n\n<p><strong>controller</strong></p>\n\n<p>controller是什么意思？controller就是一个调度器，我们知道，quantum api的操作其实都是plugin来完成的，那么最基本的，肯定是使用plugin中的函数来完成。前面的路由routes，只能根据一定的规则把path路径或者HTTP的body参数路由到一个controller，那么这个controller，要做的就是根据传递过来的信息，plugin中需要执行操作的函数，并调用这个函数，当然，controller也会把body信息(如果有)传递给plugin相关函数。OK，到这里，我必须引入quantum api中的一些基本概念了。</p>\n\n<p><strong>resource</strong></p>\n\n<p>从quantum api中就可以看出来，resource就是一个需要操作的资源，多个resource的集合就是resources,举个例子，quantum中三大概念，network,subnet,port，我们假设API形式为/v2.0/port/XXX /v2.0/network/XXX 这些中的port,network就是resource，那么多个resouce和在一起，就是resources了撒，不过quantum给他换了个名字，叫collection，所以quantum中的REST API都是/v2.0/ports/XXX /v2.0/networks/XXX这种了，因为resource，collection这个词会在代码中出现，所以你明白他是什么意思就OK了！简单一个以quantum中network的总结：</p>\n\n<pre><code>networks = collection\nnetwork = resource\n</code></pre>\n\n<p>我举一个简单的route中添加路由表的例子，仅作举例，不懂的话没关系，以后会深入讲：</p>\n\n<pre><code>from routes import Mapper  \nmap = Mapper()  \nmap.connect(None, \"/error/{action}/{id}, controller=\"error\")  \nmap.connect(\"home\", \"/\", controller=\"main\", action=\"index\")  \n\n# Match a URL, returns a dict or None if no match  \nresult = map.match(''/error/myapp/4'')  \n# result == {''controller'': ''main'', ''action'': ''myapp'', ''id'': ''4''}  \n</code></pre>\n\n<p><strong>action</strong></p>\n\n<p>在routes表中，我们注意有一个action,这个在代码中也会涉及，action是啥意思，我们知道HTTP请求中GET PUT POST等方法，对应需要的操作，那么在quantum代码中，我们不这样叫，我们把HTTP的方法映射到对资源的action（操作上），这个映射关系如下所示，这个图中，collection就是上面的概念resources，而这其实也是一个简单的routes表了，不过目前我们只需要看看action和method的对应。</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/routepath.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/routepath.png\" alt=\"routepath\" width=\"888\" height=\"170\" class=\"aligncenter size-full wp-image-308\" /></a></p>\n\n<p>整个上面所说的其实都是一个<strong>MVC（模型-视图-控制）</strong>框架，这是一个软件开发方式，可以自己学习一下,可以更好的理解OpenStack各个组件的REST API思想（用了python各种库来实现了一个MVC）。</p>\n\n<h2>API&amp;扩展API</h2>\n\n<p>Quantum是有两类API的，一类是核心API，包括networks,ports,subnets的API，这个API的Router是通过api-paste.ini中的APIRouter来进行的，同时你可以扩展API，相应的扩展都在quantum/extensions目录下，你可以把自己定义的resoucre加入到扩展中，形成扩展API，这一部分后续文章讲，现在只是基础概念。而扩展API的Router其实是在api-paste.ini中调用extension_middleware完成的，所以，整个流程可以如下两个图，这两个图体现了本文全部内容：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/loadapp.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/loadapp.png\" alt=\"loadapp\" width=\"794\" height=\"547\" class=\"aligncenter size-full wp-image-309\" /></a></p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/http.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/http.png\" alt=\"http\" width=\"687\" height=\"634\" class=\"aligncenter size-full wp-image-310\" /></a></p>\n','Quantum WSGI中代码概念及如何处理API','','inherit','open','open','','303-revision-6','','','2013-04-07 10:48:50','2013-04-07 02:48:50','','303','http://blog.wachang.net/2013/04/303-revision-6/','0','revision','','0');");
E_D("replace into `wp_posts` values('333','1','2013-04-07 15:03:37','0000-00-00 00:00:00','<pre><code>quantum_service = service.serve_wsgi(service.QuantumApiService)#准备WSGI服务\nquantum_service.wait()#启动WSGI服务\n</code></pre>\n','','','draft','open','open','','','','','2013-04-07 15:03:37','2013-04-07 07:03:37','','0','http://blog.wachang.net/?p=333','0','post','','0');");
E_D("replace into `wp_posts` values('334','1','2013-04-07 14:00:37','2013-04-07 06:00:37','<blockquote>\n  <p>浅出OpenStack源码系列</p>\n  \n  <p>Quantum WSGI服务基础(1)</p>\n  \n  <p>本文涉及代码文件:quantum\\\\quantum\\\\wsgi.py</p>\n</blockquote>\n\n<h2>1 背景</h2>\n\n<p>在上一篇文章<strong>Quantum 基础知识及服务启动</strong>中简单的阐述了一下quantum server是如何启动，其中重要的两段代码：</p>\n\n<pre><code>quantum_service = service.serve_wsgi(service.QuantumApiService)#准备WSGI服务\nquantum_service.wait()#启动WSGI服务\n</code></pre>\n\n<p>这两句构造了一个WSGI服务器实例并调用了相应的方法。在WSGI部分有两个文件:</p>\n\n<ul>\n<li><code>quantum\\\\quantum\\\\wsgi.py</code>：实现了WSGI中的基本概念，可以当成一个Lib库。</li>\n<li><code>quantum\\\\quantum\\\\service.py</code>:基于上面wsgi提供的基本操作构建一个wsgi服务，比如quantum-api-server。</li>\n</ul>\n\n<p>在OpenStack的其他组件中，wsgi.py内容都是差不多的，而service.py则是不同的。</p>\n\n<!--more-->\n\n<h2>2 wsgi.py</h2>\n\n<p>首先我们来分析这个文件，如上所说，该文件包含了wsgi中的一些概念的实现。首先看import部分，里面import了几个主要的东西：</p>\n\n<pre><code>import webob.dec#webob库\nimport webob.exc\nfrom xml.etree import ElementTree as etree#XML处理库\nimport eventlet.wsgi\nfrom quantum.openstack.common import jsonutils#JSON相关库\n</code></pre>\n\n<p>以上主要模块我在基础部分都有讲到。请先回顾。</p>\n\n<p>然后我们看看这个类的UML图：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/wsgi.py_.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/wsgi.py_-1024x461.png\" alt=\"wsgi.py\" width=\"640\" height=\"288\" class=\"aligncenter size-large wp-image-305\" /></a></p>\n\n<p>这里再提示wsgi.py中定义的类等就是WSGI的一些基本实现，在quantum架构中，大多会从wsgi.py中定义的类进行继承。</p>\n\n<p>首先，我将<a href=\"http://blog.wachang.net/2013/04/quantum-wsgi-define-and-how-to-handle-api/\">Quantum WSGI中代码概念及如何处理API</a>中涉及的概念在代码上做一个总结。</p>\n\n<h3>2.1 class Application(object)</h3>\n\n<p>这里的Application主要是一个WSGI应用的装饰器，实际的WSGI应用需要继承他。这个类主要是完成配置文件中:<strong>[app:name]内的初始化！！！！</strong></p>\n\n<pre><code>class Application(object):\n    \"\"\"Base WSGI application wrapper. Subclasses need to implement __call__.\"\"\"\n\n    @classmethod\n    def factory(cls, global_config, **local_config): #主要用来实例化类\n        \"\"\"Used for paste app factories in paste.deploy config files.\n\n        Any local configuration (that is, values under the [app:APPNAME]\n        section of the paste config) will be passed into the `__init__` method\n        as kwargs.#这里说明了api-paste.ini文中中的配置如何使用！\n\n        A hypothetical configuration would look like:\n\n            [app:wadl]\n            latest_version = 1.3\n            paste.app_factory = nova.api.fancy_api:Wadl.factory\n\n        which would result in a call to the `Wadl` class as\n        #Class Wadl需要有一个call方法\n\n            import quantum.api.fancy_api\n            fancy_api.Wadl(latest_version=''1.3'')\n\n        You could of course re-implement the `factory` method in subclasses,\n        but using the kwarg passing it shouldn''t be necessary.\n\n        \"\"\"\n        return cls(**local_config)\n\n    def __call__(self, environ, start_response):\n        \"\"\"Subclasses will probably want to implement __call__ like this:\n        #call方法用来实现一个WSGI应用的功能，处理请求，返回结果。子类需要重写这个方法。\n\n        @webob.dec.wsgify(RequestClass=Request)\n        #此装饰器将一个函数封装为一个WSGI应用。\n        def __call__(self, req):\n          # Any of the following objects work as responses:\n\n          # Option 1: simple string\n          res = ''message\\\\n''\n\n          # Option 2: a nicely formatted HTTP exception page\n          res = exc.HTTPForbidden(detail=''Nice try'')\n\n          # Option 3: a webob Response object (in case you need to play with\n          # headers, or you want to be treated like an iterable, or or or)\n          res = Response();\n          res.app_iter = open(''somefile'')\n\n          # Option 4: any wsgi app to be run next\n          res = self.application #quantum中使用的是这种方法。子类需要有一个application参数\n\n          # Option 5: you can get a Response object for a wsgi app, too, to\n          # play with headers etc\n          res = req.get_response(self.application) #quantum中使用的是这种方法。子类需要有一个application参数\n\n          # You can then just return your response...\n          return res\n          # ... or set req.response and return None.\n          req.response = res\n\n        See the end of http://pythonpaste.org/webob/modules/dec.html\n        for more info.\n\n        \"\"\"\n        raise NotImplementedError(_(''You must implement __call__''))    \n</code></pre>\n\n<h3>2.2 class Controller(object)</h3>\n\n<pre><code>class Controller(object):\n    \"\"\"WSGI app that dispatched to methods.与Method对应的controller，上面说到，一个路由表会指定一个controller，这个controller的基本。\n\n    WSGI app that reads routing information supplied by RoutesMiddleware\n    and calls the requested action method upon itself.  All action methods\n    must, in addition to their normal parameters, accept a ''req'' argument\n    which is the incoming wsgi.Request.  They raise a webob.exc exception,\n    or return a dict which will be serialized by requested content type.\n\n    \"\"\"\n\n    @webob.dec.wsgify(RequestClass=Request)#装饰为一个WSGI应用\n    def __call__(self, req):\n        \"\"\"\n        Call the method specified in req.environ by RoutesMiddleware.\n        \"\"\"\n        arg_dict = req.environ[''wsgiorg.routing_args''][1]\n        action = arg_dict[''action'']\n        method = getattr(self, action)\n        del arg_dict[''controller'']\n        del arg_dict[''action'']\n        if ''format'' in arg_dict:\n            del arg_dict[''format'']\n        arg_dict[''request''] = req\n        result = method(**arg_dict)#执行方法，这里是一个抽象，子类继承后决定具体怎么执行    \n</code></pre>\n\n<h3>2.3 class Middleware(object)</h3>\n\n<p>可以认为是一个filter，把一个WSGI包装一点新的功能，<strong>主要用来初始化api-paste.ini配置中[filter:]段中的实例初始化。</strong>，作为一个filter，app必然要作为一个参数。</p>\n\n<pre><code>class Middleware(object):#所谓中间件，也就是一个WSGI APP\n    \"\"\"\n    Base WSGI middleware wrapper. These classes require an application to be\n    initialized that will be called next.  By default the middleware will\n    simply call its wrapped app, or you can override __call__ to customize its\n    behavior.\n    \"\"\"\n\n    @classmethod\n    def factory(cls, global_config, **local_config):\n        \"\"\"Used for paste app factories in paste.deploy config files.\n\n        Any local configuration (that is, values under the [filter:APPNAME]\n        section of the paste config) will be passed into the `__init__` method\n        as kwargs.\n\n        A hypothetical configuration would look like:\n\n            [filter:analytics]\n            redis_host = 127.0.0.1\n            paste.filter_factory = nova.api.analytics:Analytics.factory\n\n        which would result in a call to the `Analytics` class as\n\n            import nova.api.analytics\n            analytics.Analytics(app_from_paste, redis_host=''127.0.0.1'')\n\n        You could of course re-implement the `factory` method in subclasses,\n        but using the kwarg passing it shouldn''t be necessary.\n\n        \"\"\"\n        def _factory(app):\n            return cls(app, **local_config)\n        return _factory\n\n    def __init__(self, application):\n        self.application = application\n\n    def process_request(self, req):\n        \"\"\"\n        Called on each request.\n\n        If this returns None, the next application down the stack will be\n        executed. If it returns a response then that response will be returned\n        and execution will stop here.\n\n        \"\"\"\n        return None\n\n    def process_response(self, response):\n        \"\"\"Do whatever you''d like to the response.\"\"\"\n        return response\n\n    @webob.dec.wsgify#封装为WSGI应用\n    def __call__(self, req):\n        response = self.process_request(req)\n        if response:\n            return response\n        response = req.get_response(self.application)\n        return self.process_response(response)     \n</code></pre>\n\n<h3>2.4 class Resource(Application)</h3>\n\n<p>继承了Application，这就是一个WSGI应用了。这个类用来干嘛？类Controller作为Resource类的一个成员，所以这个类就是用来处理调度controller以及内容格式化的。</p>\n\n<pre><code>class Resource(Application):\n    \"\"\"WSGI app that handles (de)serialization and controller dispatch.\n\n    WSGI app that reads routing information supplied by RoutesMiddleware\n    and calls the requested action method upon its controller.  All\n    controller action methods must accept a ''req'' argument, which is the\n    incoming wsgi.Request. If the operation is a PUT or POST, the controller\n    method must also accept a ''body'' argument (the deserialized request body).\n    They may raise a webob.exc exception or return a dict, which will be\n    serialized by requested content type.\n\n    \"\"\"\n\n    def __init__(self, controller, fault_body_function,\n                 deserializer=None, serializer=None):\n        \"\"\"\n        :param controller: object that implement methods created by routes lib\n        :param deserializer: object that can serialize the output of a\n                             controller into a webob response\n        :param serializer: object that can deserialize a webob request\n                           into necessary pieces\n        :param fault_body_function: a function that will build the response\n                                    body for HTTP errors raised by operations\n                                    on this resource object\n\n        \"\"\"\n        self.controller = controller\n        self.deserializer = deserializer or RequestDeserializer()\n        self.serializer = serializer or ResponseSerializer()\n        self._fault_body_function = fault_body_function\n        # use serializer''s xmlns for populating Fault generator xmlns\n        xml_serializer = self.serializer.body_serializers[''application/xml'']\n        if hasattr(xml_serializer, ''xmlns''):\n            self._xmlns = xml_serializer.xmlns\n    def dispatch(self, request, action, action_args):\n        \"\"\"Find action-spefic method on controller and call it.\"\"\"\n\n        controller_method = getattr(self.controller, action)\n        try:\n            #NOTE(salvatore-orlando): the controller method must have\n            # an argument whose name is ''request''\n            return controller_method(request=request, **action_args)#执行controller的方法了！！\n        except TypeError as exc:\n            LOG.exception(exc)\n            return Fault(webob.exc.HTTPBadRequest(),\n                         self._xmlns) \n</code></pre>\n\n<h3>2.5 class Server(object)</h3>\n\n<p>主要是一个WSGI服务器，也就是Quantum API Server的基本，跟一般的socket服务器差不多，区别就是用了eventlet来做线程处理。</p>\n\n<pre><code>class Server(object):\n    \"\"\"Server class to manage multiple WSGI sockets and applications.\"\"\"\n\n    def _run(self, application, socket):\n        \"\"\"Start a WSGI server in a new green thread.\"\"\"\n        logger = logging.getLogger(''eventlet.wsgi.server'')\n        eventlet.wsgi.server(socket, application, custom_pool=self.pool,\n                         log=logging.WritableLogger(logger))   \n</code></pre>\n\n<h3>2.6 class Router(object)</h3>\n\n<p>把API的路径转换到相应的app，这个类很重要。</p>\n\n<pre><code>class Router(object):\n    \"\"\"\n    WSGI middleware that maps incoming requests to WSGI apps.\n    \"\"\"\n\n    @classmethod\n    def factory(cls, global_config, **local_config):\n        \"\"\"\n        Returns an instance of the WSGI Router class\n        \"\"\"\n        return cls()\n\n    def __init__(self, mapper):\n        \"\"\"\n        Create a router for the given routes.Mapper.#根据routes.Mapper中的路由规则产生一个路由器，\n        相关的路由规则，在解析api-paste.ini中的extensions部分已经完成。\n\n        Each route in `mapper` must specify a ''controller'', which is a\n        WSGI app to call.  You''ll probably want to specify an ''action'' as\n        well and have your controller be a wsgi.Controller, who will route\n        the request to the action method.\n\n        Examples:\n          mapper = routes.Mapper()\n          sc = ServerController()\n\n          # Explicit mapping of one route to a controller+action\n          mapper.connect(None, \"/svrlist\", controller=sc, action=\"list\")\n\n          # Actions are all implicitly defined\n          mapper.resource(\"network\", \"networks\", controller=nc)\n\n          # Pointing to an arbitrary WSGI app.  You can specify the\n          # {path_info:.*} parameter so the target app can be handed just that\n          # section of the URL.\n          mapper.connect(None, \"/v1.0/{path_info:.*}\", controller=BlogApp())\n        \"\"\"\n        self.map = mapper\n        self._router = routes.middleware.RoutesMiddleware(self._dispatch,\n                                                          self.map)\n\n    @webob.dec.wsgify\n    def __call__(self, req):\n        \"\"\"\n        Route the incoming request to a controller based on self.map.\n        If no match, return a 404.\n        \"\"\"\n        return self._router\n\n    @staticmethod\n    @webob.dec.wsgify\n    def _dispatch(req):\n        \"\"\"\n        Called by self._router after matching the incoming request to a route\n        and putting the information into req.environ.  Either returns 404\n        or the routed WSGI app''s response.\n        \"\"\"\n        match = req.environ[''wsgiorg.routing_args''][1]\n        if not match:\n            return webob.exc.HTTPNotFound()\n        app = match[''controller'']#返回是controller的名字\n        return app     \n</code></pre>\n','Quantum WSGI服务基础','','inherit','open','open','','297-revision-4','','','2013-04-07 14:00:37','2013-04-07 06:00:37','','297','http://blog.wachang.net/2013/04/297-revision-4/','0','revision','','0');");
E_D("replace into `wp_posts` values('335','1','2013-04-03 10:40:19','2013-04-03 02:40:19','<h1>浅出OpenStack源码系列</h1>\n\n<h2>1.Python基础模块篇</h2>\n\n<p>OpenStack中使用了许多python模块，这一章就先介绍一下主要模块的最用，同时也是后续文章中的一些参考。</p>\n\n<p><a href=\"http://webpython.codepoint.net/wsgi_tutorial\">Python:WSGI介绍</a></p>\n\n<p><a href=\"http://blog.wachang.net/2013/04/python-paste-deploy-1/\">Python.Paste指南之Deploy(1)-概念</a></p>\n\n<p><a href=\"http://blog.wachang.net/2013/04/python-paste-deploy-2/\">Python.Paste指南之Deploy(2)-实践</a></p>\n\n<h2>2.Quantum篇</h2>\n\n<h3>2.1 Quantum Server</h3>\n\n<p><a href=\"http://blog.wachang.net/2013/04/quantum-code-base/\">Quantum 基础知识及服务启动</a></p>\n\n<p><a href=\"http://blog.wachang.net/2013/04/quantum-wsgi-define-and-how-to-handle-api/\">Quantum WSGI中代码概念及如何处理API</a></p>\n\n<h3>2.3 OpenvSwitch Plugin</h3>\n\n<p><a href=\"http://blog.wachang.net/2013/03/quantum-ovs-plugin-code-structure/\">Quantum OpenvSwitch Plugin代码架构</a></p>\n\n<p><a href=\"http://blog.wachang.net/2013/03/quantum-ovs-agent-config-file/\">Quantum OpenvSwitch Plugin&amp;Agent读取配置文件</a></p>\n\n<p><a href=\"http://blog.wachang.net/2013/03/quantum-ovs-plugin-agent-rpc-1/\">Quantum OpenvSwitch Plugin和Agent的RPC机制（一）</a></p>\n','浅出OpenStack源码','','inherit','open','open','','209-revision-8','','','2013-04-03 10:40:19','2013-04-03 02:40:19','','209','http://blog.wachang.net/2013/04/209-revision-8/','0','revision','','0');");
E_D("replace into `wp_posts` values('336','1','2013-04-07 14:15:52','2013-04-07 06:15:52','<blockquote>\n  <p>浅出OpenStack源码系列</p>\n  \n  <p>Quantum WSGI服务基础(1)</p>\n  \n  <p>本文涉及代码文件:quantum\\\\quantum\\\\wsgi.py</p>\n</blockquote>\n\n<h2>1 背景</h2>\n\n<p>在上一篇文章<strong>Quantum 基础知识及服务启动</strong>中简单的阐述了一下quantum server是如何启动，其中重要的两段代码：</p>\n\n<pre><code>quantum_service = service.serve_wsgi(service.QuantumApiService)#准备WSGI服务\nquantum_service.wait()#启动WSGI服务\n</code></pre>\n\n<p>这两句构造了一个WSGI服务器实例并调用了相应的方法。在WSGI部分有两个文件:</p>\n\n<ul>\n<li><code>quantum\\\\quantum\\\\wsgi.py</code>：实现了WSGI中的基本概念，可以当成一个Lib库。</li>\n<li><code>quantum\\\\quantum\\\\service.py</code>:基于上面wsgi提供的基本操作构建一个wsgi服务，比如quantum-api-server。</li>\n</ul>\n\n<p>在OpenStack的其他组件中，wsgi.py内容都是差不多的，而service.py则是不同的。</p>\n\n<!--more-->\n\n<h2>2 wsgi.py</h2>\n\n<p>首先我们来分析这个文件，如上所说，该文件包含了wsgi中的一些概念的实现。首先看import部分，里面import了几个主要的东西：</p>\n\n<pre><code>import webob.dec#webob库\nimport webob.exc\nfrom xml.etree import ElementTree as etree#XML处理库\nimport eventlet.wsgi\nfrom quantum.openstack.common import jsonutils#JSON相关库\n</code></pre>\n\n<p>以上主要模块我在基础部分都有讲到。请先回顾。</p>\n\n<p>然后我们看看这个类的UML图：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/wsgi.py_.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/wsgi.py_-1024x461.png\" alt=\"wsgi.py\" width=\"640\" height=\"288\" class=\"aligncenter size-large wp-image-305\" /></a></p>\n\n<p>这里再提示wsgi.py中定义的类等就是WSGI的一些基本实现，在quantum架构中，大多会从wsgi.py中定义的类进行继承。</p>\n\n<p>首先，我将<a href=\"http://blog.wachang.net/2013/04/quantum-wsgi-define-and-how-to-handle-api/\">Quantum WSGI中代码概念及如何处理API</a>中涉及的概念在代码上做一个总结。</p>\n\n<h3>2.1 class Application(object)</h3>\n\n<p>这里的Application主要是一个WSGI应用的装饰器，实际的WSGI应用需要继承他。这个类主要是完成配置文件中:<strong>[app:name]内的初始化！！！！</strong></p>\n\n<pre><code>class Application(object):\n    \"\"\"Base WSGI application wrapper. Subclasses need to implement __call__.\"\"\"\n\n    @classmethod\n    def factory(cls, global_config, **local_config): #主要用来实例化类\n        \"\"\"Used for paste app factories in paste.deploy config files.\n\n        Any local configuration (that is, values under the [app:APPNAME]\n        section of the paste config) will be passed into the `__init__` method\n        as kwargs.#这里说明了api-paste.ini文中中的配置如何使用！\n\n        A hypothetical configuration would look like:\n\n            [app:wadl]\n            latest_version = 1.3\n            paste.app_factory = nova.api.fancy_api:Wadl.factory\n\n        which would result in a call to the `Wadl` class as\n        #Class Wadl需要有一个call方法\n\n            import quantum.api.fancy_api\n            fancy_api.Wadl(latest_version=''1.3'')\n\n        You could of course re-implement the `factory` method in subclasses,\n        but using the kwarg passing it shouldn''t be necessary.\n\n        \"\"\"\n        return cls(**local_config)\n\n    def __call__(self, environ, start_response):\n        \"\"\"Subclasses will probably want to implement __call__ like this:\n        #call方法用来实现一个WSGI应用的功能，处理请求，返回结果。子类需要重写这个方法。\n\n        @webob.dec.wsgify(RequestClass=Request)\n        #此装饰器将一个函数封装为一个WSGI应用。\n        def __call__(self, req):\n          # Any of the following objects work as responses:\n\n          # Option 1: simple string\n          res = ''message\\\\n''\n\n          # Option 2: a nicely formatted HTTP exception page\n          res = exc.HTTPForbidden(detail=''Nice try'')\n\n          # Option 3: a webob Response object (in case you need to play with\n          # headers, or you want to be treated like an iterable, or or or)\n          res = Response();\n          res.app_iter = open(''somefile'')\n\n          # Option 4: any wsgi app to be run next\n          res = self.application #quantum中使用的是这种方法。子类需要有一个application参数\n\n          # Option 5: you can get a Response object for a wsgi app, too, to\n          # play with headers etc\n          res = req.get_response(self.application) #quantum中使用的是这种方法。子类需要有一个application参数\n\n          # You can then just return your response...\n          return res\n          # ... or set req.response and return None.\n          req.response = res\n\n        See the end of http://pythonpaste.org/webob/modules/dec.html\n        for more info.\n\n        \"\"\"\n        raise NotImplementedError(_(''You must implement __call__''))    \n</code></pre>\n\n<h3>2.2 class Controller(object)</h3>\n\n<pre><code>class Controller(object):\n    \"\"\"WSGI app that dispatched to methods.与Method对应的controller，上面说到，一个路由表会指定一个controller，这个controller的基本。\n\n    WSGI app that reads routing information supplied by RoutesMiddleware\n    and calls the requested action method upon itself.  All action methods\n    must, in addition to their normal parameters, accept a ''req'' argument\n    which is the incoming wsgi.Request.  They raise a webob.exc exception,\n    or return a dict which will be serialized by requested content type.\n\n    \"\"\"\n\n    @webob.dec.wsgify(RequestClass=Request)#装饰为一个WSGI应用\n    def __call__(self, req):\n        \"\"\"\n        Call the method specified in req.environ by RoutesMiddleware.\n        \"\"\"\n        arg_dict = req.environ[''wsgiorg.routing_args''][1]\n        action = arg_dict[''action'']\n        method = getattr(self, action)\n        del arg_dict[''controller'']\n        del arg_dict[''action'']\n        if ''format'' in arg_dict:\n            del arg_dict[''format'']\n        arg_dict[''request''] = req\n        result = method(**arg_dict)#执行方法，这里是一个抽象，子类继承后决定具体怎么执行    \n</code></pre>\n\n<h3>2.3 class Middleware(object)</h3>\n\n<p>可以认为是一个filter，把一个WSGI包装一点新的功能，<strong>主要用来初始化api-paste.ini配置中[filter:]段中的实例初始化。</strong>，作为一个filter，app必然要作为一个参数。</p>\n\n<pre><code>class Middleware(object):#所谓中间件，也就是一个WSGI APP\n    \"\"\"\n    Base WSGI middleware wrapper. These classes require an application to be\n    initialized that will be called next.  By default the middleware will\n    simply call its wrapped app, or you can override __call__ to customize its\n    behavior.\n    \"\"\"\n\n    @classmethod\n    def factory(cls, global_config, **local_config):\n        \"\"\"Used for paste app factories in paste.deploy config files.\n\n        Any local configuration (that is, values under the [filter:APPNAME]\n        section of the paste config) will be passed into the `__init__` method\n        as kwargs.\n\n        A hypothetical configuration would look like:\n\n            [filter:analytics]\n            redis_host = 127.0.0.1\n            paste.filter_factory = nova.api.analytics:Analytics.factory\n\n        which would result in a call to the `Analytics` class as\n\n            import nova.api.analytics\n            analytics.Analytics(app_from_paste, redis_host=''127.0.0.1'')\n\n        You could of course re-implement the `factory` method in subclasses,\n        but using the kwarg passing it shouldn''t be necessary.\n\n        \"\"\"\n        def _factory(app):\n            return cls(app, **local_config)\n        return _factory\n\n    def __init__(self, application):\n        self.application = application\n\n    def process_request(self, req):\n        \"\"\"\n        Called on each request.\n\n        If this returns None, the next application down the stack will be\n        executed. If it returns a response then that response will be returned\n        and execution will stop here.\n\n        \"\"\"\n        return None\n\n    def process_response(self, response):\n        \"\"\"Do whatever you''d like to the response.\"\"\"\n        return response\n\n    @webob.dec.wsgify#封装为WSGI应用\n    def __call__(self, req):\n        response = self.process_request(req)\n        if response:\n            return response\n        response = req.get_response(self.application)\n        return self.process_response(response)     \n</code></pre>\n\n<h3>2.4 class Resource(Application)</h3>\n\n<p>继承了Application，这就是一个WSGI应用了。这个类用来干嘛？类Controller作为Resource类的一个成员，所以这个类就是用来处理调度controller以及内容格式化的。</p>\n\n<pre><code>class Resource(Application):\n    \"\"\"WSGI app that handles (de)serialization and controller dispatch.\n\n    WSGI app that reads routing information supplied by RoutesMiddleware\n    and calls the requested action method upon its controller.  All\n    controller action methods must accept a ''req'' argument, which is the\n    incoming wsgi.Request. If the operation is a PUT or POST, the controller\n    method must also accept a ''body'' argument (the deserialized request body).\n    They may raise a webob.exc exception or return a dict, which will be\n    serialized by requested content type.\n\n    \"\"\"\n\n    def __init__(self, controller, fault_body_function,\n                 deserializer=None, serializer=None):\n        \"\"\"\n        :param controller: object that implement methods created by routes lib\n        :param deserializer: object that can serialize the output of a\n                             controller into a webob response\n        :param serializer: object that can deserialize a webob request\n                           into necessary pieces\n        :param fault_body_function: a function that will build the response\n                                    body for HTTP errors raised by operations\n                                    on this resource object\n\n        \"\"\"\n        self.controller = controller\n        self.deserializer = deserializer or RequestDeserializer()\n        self.serializer = serializer or ResponseSerializer()\n        self._fault_body_function = fault_body_function\n        # use serializer''s xmlns for populating Fault generator xmlns\n        xml_serializer = self.serializer.body_serializers[''application/xml'']\n        if hasattr(xml_serializer, ''xmlns''):\n            self._xmlns = xml_serializer.xmlns\n    def dispatch(self, request, action, action_args):\n        \"\"\"Find action-spefic method on controller and call it.\"\"\"\n\n        controller_method = getattr(self.controller, action)\n        try:\n            #NOTE(salvatore-orlando): the controller method must have\n            # an argument whose name is ''request''\n            return controller_method(request=request, **action_args)#执行controller的方法了！！\n        except TypeError as exc:\n            LOG.exception(exc)\n            return Fault(webob.exc.HTTPBadRequest(),\n                         self._xmlns) \n</code></pre>\n\n<h3>2.5 class Server(object)</h3>\n\n<p>主要是一个WSGI服务器，也就是Quantum API Server的基本，跟一般的socket服务器差不多，区别就是用了eventlet来做线程处理。</p>\n\n<pre><code>class Server(object):\n    \"\"\"Server class to manage multiple WSGI sockets and applications.\"\"\"\n\n    def _run(self, application, socket):\n        \"\"\"Start a WSGI server in a new green thread.\"\"\"\n        logger = logging.getLogger(''eventlet.wsgi.server'')\n        eventlet.wsgi.server(socket, application, custom_pool=self.pool,\n                         log=logging.WritableLogger(logger))   \n</code></pre>\n\n<h3>2.6 class Router(object)</h3>\n\n<p>把API的路径转换到相应的app，这个类很重要。</p>\n\n<pre><code>class Router(object):\n    \"\"\"\n    WSGI middleware that maps incoming requests to WSGI apps.\n    \"\"\"\n\n    @classmethod\n    def factory(cls, global_config, **local_config):\n        \"\"\"\n        Returns an instance of the WSGI Router class\n        \"\"\"\n        return cls()\n\n    def __init__(self, mapper):\n        \"\"\"\n        Create a router for the given routes.Mapper.#根据routes.Mapper中的路由规则产生一个路由器，\n        相关的路由规则，在解析api-paste.ini中的extensions部分已经完成。\n\n        Each route in `mapper` must specify a ''controller'', which is a\n        WSGI app to call.  You''ll probably want to specify an ''action'' as\n        well and have your controller be a wsgi.Controller, who will route\n        the request to the action method.\n\n        Examples:\n          mapper = routes.Mapper()\n          sc = ServerController()\n\n          # Explicit mapping of one route to a controller+action\n          mapper.connect(None, \"/svrlist\", controller=sc, action=\"list\")\n\n          # Actions are all implicitly defined\n          mapper.resource(\"network\", \"networks\", controller=nc)\n\n          # Pointing to an arbitrary WSGI app.  You can specify the\n          # {path_info:.*} parameter so the target app can be handed just that\n          # section of the URL.\n          mapper.connect(None, \"/v1.0/{path_info:.*}\", controller=BlogApp())\n        \"\"\"\n        self.map = mapper\n        self._router = routes.middleware.RoutesMiddleware(self._dispatch,\n                                                          self.map)\n\n    @webob.dec.wsgify\n    def __call__(self, req):\n        \"\"\"\n        Route the incoming request to a controller based on self.map.\n        If no match, return a 404.\n        \"\"\"\n        return self._router\n\n    @staticmethod\n    @webob.dec.wsgify\n    def _dispatch(req):\n        \"\"\"\n        Called by self._router after matching the incoming request to a route\n        and putting the information into req.environ.  Either returns 404\n        or the routed WSGI app''s response.\n        \"\"\"\n        match = req.environ[''wsgiorg.routing_args''][1]\n        if not match:\n            return webob.exc.HTTPNotFound()\n        app = match[''controller'']#返回是controller的名字\n        return app\n</code></pre>\n','Quantum WSGI服务基础','','inherit','open','open','','297-autosave','','','2013-04-07 14:15:52','2013-04-07 06:15:52','','297','http://blog.wachang.net/2013/04/297-autosave/','0','revision','','0');");
E_D("replace into `wp_posts` values('338','1','2013-04-07 19:51:10','0000-00-00 00:00:00','<pre><code>quantum_service = service.serve_wsgi(service.QuantumApiService)#准备WSGI服务\nquantum_service.wait()#启动WSGI服务\n</code></pre>\n','Quantum API Server','','draft','open','open','','','','','2013-04-07 19:51:10','2013-04-07 11:51:10','','0','http://blog.wachang.net/?p=338','0','post','','0');");
E_D("replace into `wp_posts` values('340','1','2013-04-22 21:26:23','0000-00-00 00:00:00','<pre><code>def _model_query(self, context, model):\n    query = context.session.query(model)\n    # define basic filter condition for model query\n    # NOTE(jkoelker) non-admin queries are scoped to their tenant_id\n    # NOTE(salvatore-orlando): unless the model allows for shared objects\n    query_filter = None\n    if not context.is_admin and hasattr(model, ''tenant_id''):\n        if hasattr(model, ''shared''):\n            query_filter = ((model.tenant_id == context.tenant_id) |\n                            (model.shared))\n        else:\n            query_filter = (model.tenant_id == context.tenant_id)\n    # Execute query hooks registered from mixins and plugins\n    for _name, hooks in self._model_query_hooks.get(model,\n                                                    {}).iteritems():\n        query_hook = hooks.get(''query'')\n        filter_hook = hooks.get(''filter'')\n        if query_hook:\n            query = query_hook(self, context, model, query)\n        if filter_hook:\n            query_filter = filter_hook(self, context, model, query_filter)\n\n    # NOTE(salvatore-orlando): ''if query_filter'' will try to evaluate the\n    # condition, raising an exception\n    if query_filter is not None:\n        query = query.filter(query_filter)\n    return query\n</code></pre>\n','','','draft','open','open','','','','','2013-04-22 21:26:23','2013-04-22 13:26:23','','0','http://blog.wachang.net/?p=340','0','post','','0');");
E_D("replace into `wp_posts` values('341','1','2013-04-23 12:20:50','2013-04-23 04:20:50','','首页','','publish','open','open','','%e9%a6%96%e9%a1%b5','','','2013-04-23 12:20:50','2013-04-23 04:20:50','','0','http://blog.wachang.net/?p=341','1','nav_menu_item','','0');");
E_D("replace into `wp_posts` values('342','1','2013-04-03 15:26:41','2013-04-03 07:26:41','<p>原文链接：</p>\n\n<p><a href=\"http://www.iplaysoft.com/top10-programming-fonts.html\">10大最适合编程的字体推荐下载，让代码看起来更美更舒服！</a></p>\n\n<p><a href=\"http://hivelogic.com/articles/top-10-programming-fonts/\">英文原版</a></p>\n\n<!--more-->\n\n<h2>10. Courier</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/courier.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/courier.png\" alt=\"courier\" width=\"518\" height=\"221\" class=\"aligncenter size-full wp-image-316\" /></a></p>\n\n<h2>9. Andale Mono</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/andale.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/andale.png\" alt=\"andale\" width=\"458\" height=\"206\" class=\"aligncenter size-full wp-image-317\" /></a></p>\n\n<h2>8. Monaco</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/monaco.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/monaco.png\" alt=\"monaco\" width=\"436\" height=\"238\" class=\"aligncenter size-full wp-image-318\" /></a></p>\n\n<h2>7. Profont</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/profont.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/profont.png\" alt=\"profont\" width=\"336\" height=\"153\" class=\"aligncenter size-full wp-image-319\" /></a></p>\n\n<h2>6. Monofur</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/monofur.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/monofur.png\" alt=\"monofur\" width=\"393\" height=\"184\" class=\"aligncenter size-full wp-image-320\" /></a></p>\n\n<h2>5. Proggy</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/proggy.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/proggy.png\" alt=\"proggy\" width=\"361\" height=\"157\" class=\"aligncenter size-full wp-image-321\" /></a></p>\n\n<h2>4. Droid Sans Mono</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/droid-sans.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/droid-sans.png\" alt=\"droid sans\" width=\"440\" height=\"213\" class=\"aligncenter size-full wp-image-322\" /></a></p>\n\n<h2>3. Deja Vu Sans Mono</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/deja-vu-sans.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/deja-vu-sans.png\" alt=\"deja vu sans\" width=\"461\" height=\"214\" class=\"aligncenter size-full wp-image-323\" /></a></p>\n\n<h2>2. Consolas + 中文雅黑混合版</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/consolas.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/consolas.png\" alt=\"consolas\" width=\"478\" height=\"201\" class=\"aligncenter size-full wp-image-324\" /></a></p>\n\n<h2>1. Inconsolata</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/04/inconsolata.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/04/inconsolata.png\" alt=\"inconsolata\" width=\"462\" height=\"195\" class=\"aligncenter size-full wp-image-325\" /></a></p>\n\n<p>所有字体打包下载：</p>\n\n<p>[wpdm_file id=3]</p>\n','[转]十大编程字体','','inherit','open','open','','315-revision-2','','','2013-04-03 15:26:41','2013-04-03 07:26:41','','315','http://blog.wachang.net/2013/04/315-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('343','1','2013-04-23 21:38:34','0000-00-00 00:00:00','<pre><code>   def create_vc(self, context, vc,**kwargs):\n        ret = super(HuaWeiQuantumPlugin,self).create_vc(context,vc,**kwargs)\n        return ret\n</code></pre>\n','','','draft','open','open','','','','','2013-04-23 21:38:34','2013-04-23 13:38:34','','0','http://blog.wachang.net/?p=343','0','post','','0');");
E_D("replace into `wp_posts` values('345','1','2013-04-24 02:05:05','0000-00-00 00:00:00','<pre><code>def _send_xml_to_controller(xml_serializer, data, is_create=False):\n    #===========================================================================\n    #  2012-12-04 add code\n    #===========================================================================\n    if not data:\n        raise webob.exc.HTTPNotFound()\n    cmd=data[''document''][''cmd'']\n    xmldata = xml_serializer(data)\n    print ''[driver] send xmldata = '',xmldata\n    xmldata1,xmldata2=xmldata.split(''&lt;cmd&gt;'',1)\n    xmldata3,xmldata4=xmldata2.split(''&lt;/cmd&gt;'',1)\n    xmldata5,xmldata6=xmldata1.split(''&lt;document&gt;'',1)\n    cmd=''&lt;document&gt;&lt;cmd&gt;%s&lt;/cmd&gt;'' % cmd\n    xmldata=\"%s%s%s\" % (cmd,xmldata6,xmldata4)\n    print ''[driver] send xmldata ='',xmldata\n\n    _socket_plugin = eventlet.connect(_huawei_controller_addr)\n    _socket_plugin.send(xmldata+''\\\\n'')\n    xmldata = _socket_plugin.recv(10240)\n    print ''[driver] recv xmldata = '',xmldata\n    data=_recv_xml_from_controller(xmldata)\n    print ''[driver]controller return ='',data\n\n    result=data[''document''].get(''result'', ''-1'')\n    if result ==''-1'':\n        return False\n    if is_create:\n        id = data[''document''].get(''vnid'','''')\n        if id:\n            print \"(vnid) = \",id\n            return remove_gang(id)\n        else:\n            id = data[''document''].get(''vcid'','''')\n            if id:\n                print \"(vcid) = \",id\n                return remove_gang(id)\n        return False\n    return True\n</code></pre>\n','','','draft','open','open','','','','','2013-04-24 02:05:05','2013-04-23 18:05:05','','0','http://blog.wachang.net/?p=345','0','post','','0');");
E_D("replace into `wp_posts` values('346','1','2013-04-24 02:48:27','0000-00-00 00:00:00','<pre><code>import sys\nfrom oslo.config import cfg #创建一个配置管理器cfg.CONF\nfrom Quantum.common import config #向cfg.CONF注册核心选项core_opts,指明需要读取哪些选项或者哪些CLI参数\nfrom Quantum import service\n\ndef main():\n    # the configuration will be read into the cfg.CONF global data structure\n    config.parse(sys.argv[1:]) #解析配置文件，即是quantum.conf,把相应的配置信息写入到cfg.CONF中。\n\n    try:\n        Quantum_service = service.serve_wsgi(service.QuantumApiService)#准备WSGI服务\n        Quantum_service.wait()#启动WSGI服务\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>\n','','','draft','open','open','','','','','2013-04-24 02:48:27','2013-04-23 18:48:27','','0','http://blog.wachang.net/?p=346','0','post','','0');");
E_D("replace into `wp_posts` values('347','1','2013-04-24 10:56:33','2013-04-24 02:56:33','<pre><code>from routes import Mapper  \nmap = Mapper()  \nmap.connect(None, \"/error/{action}/{id}, controller=\"error\")  \nmap.connect(\"home\", \"/\", controller=\"main\", action=\"index\")  \n\n# Match a URL, returns a dict or None if no match  \nresult = map.match(''/error/myapp/4'')  \n# result == {''controller'': ''main'', ''action'': ''myapp'', ''id'': ''4''}  \n</code></pre>\n','','','trash','open','open','','347','','','2013-04-28 15:37:58','2013-04-28 07:37:58','','0','http://blog.wachang.net/?p=347','0','post','','0');");
E_D("replace into `wp_posts` values('348','1','2013-04-28 14:00:10','2013-04-28 06:00:10','<p>葡萄酒是以鲜葡萄或者葡萄汁为原料，经全部或者部分发酵而成的，有一定酒精度的发酵酒。葡萄酒中花青素预防心脏疾病，白藜芦醇抗癌。PH城碱性，是一位属于弱碱性的酒。葡萄酒在起源于埃及，随罗马帝国扩张传遍欧洲。</p>\n\n<ul>\n<li><p>葡萄酒的生命期？浅龄期--》发展期--》成熟期--》高峰期--》退化期--》垂老期</p></li>\n<li><p>葡萄酒的分类？ 按色泽：白葡萄酒，桃红葡萄酒，红葡萄酒 按糖分：半型葡萄酒，半干型葡萄酒，半甜型葡萄酒，甜型葡萄酒 按二氧化碳：无气葡萄酒，也叫静酒；起泡型葡萄酒，葡萄汽酒。</p></li>\n<li><p>一般葡萄酒怎么酿造？ 采摘--》破碎--》浸渍发酵--》提渣分离--》陈酿--》澄清</p></li>\n<li><p>葡萄酒如何品？（12秒法则） 入口：持续2-3秒，甜味为主；--》发展，5秒及更长，酸甜，特别是苦为主，咸味，酸味，苦味依次上升--》后味：5-12秒甜味逐渐下降</p></li>\n<li><p>葡萄酒的品酒温度？（摄氏度） 甜型：4-8 香槟/起泡：6-8 干白：8-12 桃红：12-14 干红：14-18</p></li>\n</ul>\n\n<!--more-->\n\n<ul>\n<li><p>葡萄酒怎么看？ 先看颜色，杯子倾斜45度，观察酒的颜色饱和度等；然后闻香。第一次，酒杯慢慢举起，不摇动，闻闻；第二次，轻摇酒杯，使空气与酒充分融合。最后，品酒，轻喝一小口，如喉前仔细品味。</p></li>\n<li><p>葡萄酒杯种类：白葡萄酒杯，起泡葡萄酒杯（杯身细长），波尔多红葡萄酒杯（杯体宽于杯口）</p></li>\n<li><p>葡萄酒的瓶形：波尔多瓶形（赤霞珠等品种多使用这种），起泡型（为了抵抗压力，一般底部比较厚达），冰酒型（又细又长，增加档次感）</p></li>\n<li><p>高酒杯如何拿？ 不要拿杯身，手会使得葡萄酒加温，留下手印，要拿杯腿或者杯座。</p></li>\n<li><p>为啥子要用木桶？ 橡木桶中，通过微气孔和氧气和酒有限接触，增添项目单宁和香气。使酒体更协调，口感更好。</p></li>\n<li><p>红葡萄的品种？ 赤霞珠：酒体醇厚，协调，果香浓，酒体宝石红色，口感好 西拉：澄清透明，酒体深宝石红色，复合型果香。 梅鹿辄：酒体丰满，柔和，口感清爽。</p></li>\n<li><p>白葡萄的品种？ 霞多丽：酒色金黄，香气怡人； 雷司令：浅黄色带绿色，柔和爽口； 长相思：天然清新，酒可以长时间存放。</p></li>\n<li><p>葡萄酒上酒顺序？ 先白后红；先淡后浓；先干后甜；先普通再贵；先年份轻再年份久；</p></li>\n<li><p>葡萄酒配什么吃？ 一般是红配红，白配白；干红就配家禽肉类味重的。干白就配海鲜白肉等。</p></li>\n<li><p>有名的酒庄： 智利比斯克酒庄 君顶酒庄 法国雷沃堡酒庄</p></li>\n</ul>\n','葡萄酒知识入门','','publish','open','open','','wine','','','2013-04-28 14:00:23','2013-04-28 06:00:23','','0','http://blog.wachang.net/?p=348','0','post','','0');");
E_D("replace into `wp_posts` values('349','1','2013-04-28 13:59:29','2013-04-28 05:59:29','<p>葡萄酒是以鲜葡萄或者葡萄汁为原料，经全部或者部分发酵而成的，有一定酒精度的发酵酒。葡萄酒中花青素预防心脏疾病，白藜芦醇抗癌。PH城碱性，是一位属于弱碱性的酒。葡萄酒在起源于埃及，随罗马帝国扩张传遍欧洲。</p>\n\n<ul>\n<li><p>葡萄酒的生命期？浅龄期--》发展期--》成熟期--》高峰期--》退化期--》垂老期</p></li>\n<li><p>葡萄酒的分类？\n按色泽：白葡萄酒，桃红葡萄酒，红葡萄酒\n按糖分：半型葡萄酒，半干型葡萄酒，半甜型葡萄酒，甜型葡萄酒\n按二氧化碳：无气葡萄酒，也叫静酒；起泡型葡萄酒，葡萄汽酒。</p></li>\n<li><p>一般葡萄酒怎么酿造？\n采摘--》破碎--》浸渍发酵--》提渣分离--》陈酿--》澄清</p></li>\n<li><p>葡萄酒如何品？（12秒法则）\n入口：持续2-3秒，甜味为主；--》发展，5秒及更长，酸甜，特别是苦为主，咸味，酸味，苦味依次上升--》后味：5-12秒甜味逐渐下降</p></li>\n<li><p>葡萄酒的品酒温度？（摄氏度）\n甜型：4-8 香槟/起泡：6-8 干白：8-12 桃红：12-14 干红：14-18</p></li>\n<li><p>葡萄酒怎么看？\n先看颜色，杯子倾斜45度，观察酒的颜色饱和度等；然后闻香。第一次，酒杯慢慢举起，不摇动，闻闻；第二次，轻摇酒杯，使空气与酒充分融合。最后，品酒，轻喝一小口，如喉前仔细品味。</p></li>\n<li><p>葡萄酒杯种类：白葡萄酒杯，起泡葡萄酒杯（杯身细长），波尔多红葡萄酒杯（杯体宽于杯口）</p></li>\n<li><p>葡萄酒的瓶形：波尔多瓶形（赤霞珠等品种多使用这种），起泡型（为了抵抗压力，一般底部比较厚达），冰酒型（又细又长，增加档次感）</p></li>\n<li><p>高酒杯如何拿？\n不要拿杯身，手会使得葡萄酒加温，留下手印，要拿杯腿或者杯座。</p></li>\n<li><p>为啥子要用木桶？\n橡木桶中，通过微气孔和氧气和酒有限接触，增添项目单宁和香气。使酒体更协调，口感更好。</p></li>\n<li><p>红葡萄的品种？\n赤霞珠：酒体醇厚，协调，果香浓，酒体宝石红色，口感好\n西拉：澄清透明，酒体深宝石红色，复合型果香。\n梅鹿辄：酒体丰满，柔和，口感清爽。</p></li>\n<li><p>白葡萄的品种？\n霞多丽：酒色金黄，香气怡人；\n雷司令：浅黄色带绿色，柔和爽口；\n长相思：天然清新，酒可以长时间存放。</p></li>\n<li><p>葡萄酒上酒顺序？\n先白后红；先淡后浓；先干后甜；先普通再贵；先年份轻再年份久；</p></li>\n<li><p>葡萄酒配什么吃？\n一般是红配红，白配白；干红就配家禽肉类味重的。干白就配海鲜白肉等。</p></li>\n<li><p>有名的酒庄：\n智利比斯克酒庄\n君顶酒庄\n法国雷沃堡酒庄</p></li>\n</ul>\n','葡萄酒知识入门','','inherit','open','open','','348-revision','','','2013-04-28 13:59:29','2013-04-28 05:59:29','','348','http://blog.wachang.net/2013/04/348-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('350','1','2013-04-28 14:00:10','2013-04-28 06:00:10','<p>葡萄酒是以鲜葡萄或者葡萄汁为原料，经全部或者部分发酵而成的，有一定酒精度的发酵酒。葡萄酒中花青素预防心脏疾病，白藜芦醇抗癌。PH城碱性，是一位属于弱碱性的酒。葡萄酒在起源于埃及，随罗马帝国扩张传遍欧洲。</p>\n\n<ul>\n<li><p>葡萄酒的生命期？浅龄期--》发展期--》成熟期--》高峰期--》退化期--》垂老期</p></li>\n<li><p>葡萄酒的分类？\n按色泽：白葡萄酒，桃红葡萄酒，红葡萄酒\n按糖分：半型葡萄酒，半干型葡萄酒，半甜型葡萄酒，甜型葡萄酒\n按二氧化碳：无气葡萄酒，也叫静酒；起泡型葡萄酒，葡萄汽酒。</p></li>\n<li><p>一般葡萄酒怎么酿造？\n采摘--》破碎--》浸渍发酵--》提渣分离--》陈酿--》澄清</p></li>\n<li><p>葡萄酒如何品？（12秒法则）\n入口：持续2-3秒，甜味为主；--》发展，5秒及更长，酸甜，特别是苦为主，咸味，酸味，苦味依次上升--》后味：5-12秒甜味逐渐下降</p></li>\n<li><p>葡萄酒的品酒温度？（摄氏度）\n甜型：4-8 香槟/起泡：6-8 干白：8-12 桃红：12-14 干红：14-18</p></li>\n<li><p>葡萄酒怎么看？\n先看颜色，杯子倾斜45度，观察酒的颜色饱和度等；然后闻香。第一次，酒杯慢慢举起，不摇动，闻闻；第二次，轻摇酒杯，使空气与酒充分融合。最后，品酒，轻喝一小口，如喉前仔细品味。</p></li>\n<li><p>葡萄酒杯种类：白葡萄酒杯，起泡葡萄酒杯（杯身细长），波尔多红葡萄酒杯（杯体宽于杯口）</p></li>\n<li><p>葡萄酒的瓶形：波尔多瓶形（赤霞珠等品种多使用这种），起泡型（为了抵抗压力，一般底部比较厚达），冰酒型（又细又长，增加档次感）</p></li>\n<li><p>高酒杯如何拿？\n不要拿杯身，手会使得葡萄酒加温，留下手印，要拿杯腿或者杯座。</p></li>\n<li><p>为啥子要用木桶？\n橡木桶中，通过微气孔和氧气和酒有限接触，增添项目单宁和香气。使酒体更协调，口感更好。</p></li>\n<li><p>红葡萄的品种？\n赤霞珠：酒体醇厚，协调，果香浓，酒体宝石红色，口感好\n西拉：澄清透明，酒体深宝石红色，复合型果香。\n梅鹿辄：酒体丰满，柔和，口感清爽。</p></li>\n<li><p>白葡萄的品种？\n霞多丽：酒色金黄，香气怡人；\n雷司令：浅黄色带绿色，柔和爽口；\n长相思：天然清新，酒可以长时间存放。</p></li>\n<li><p>葡萄酒上酒顺序？\n先白后红；先淡后浓；先干后甜；先普通再贵；先年份轻再年份久；</p></li>\n<li><p>葡萄酒配什么吃？\n一般是红配红，白配白；干红就配家禽肉类味重的。干白就配海鲜白肉等。</p></li>\n<li><p>有名的酒庄：\n智利比斯克酒庄\n君顶酒庄\n法国雷沃堡酒庄</p></li>\n</ul>\n','葡萄酒知识入门','','inherit','open','open','','348-revision-2','','','2013-04-28 14:00:10','2013-04-28 06:00:10','','348','http://blog.wachang.net/2013/04/348-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('351','1','2013-04-01 20:29:58','2013-04-01 12:29:58','<p>以下是我git clone的Quantum的源代码，我简单做一下注释。</p>\n\n<pre><code>root@Compute2:~/quantum# tree\n.\n├── bin #各个组件的启动脚本\n│   ├── quantum-check-nvp-config\n│   ├── quantum-db-manage\n│   ├── quantum-debug\n│   ├── quantum-dhcp-agent\n│   ├── quantum-dhcp-agent-dnsmasq-lease-update\n│   ├── quantum-hyperv-agent\n│   ├── quantum-l3-agent\n│   ├── quantum-lbaas-agent\n│   ├── quantum-linuxbridge-agent\n│   ├── quantum-metadata-agent\n│   ├── quantum-nec-agent\n│   ├── quantum-netns-cleanup\n│   ├── quantum-ns-metadata-proxy\n│   ├── quantum-openvswitch-agent\n│   ├── quantum-ovs-cleanup\n│   ├── quantum-rootwrap\n│   ├── quantum-rpc-zmq-receiver\n│   ├── quantum-ryu-agent\n│   ├── quantum-server\n│   └── quantum-usage-audit\n├── contrib\n│   └── redhat-eventlet.patch\n├── doc#文档目录，已删除，可以用sphix编译\n├── etc#这是Quantum中所有的配置文件例子\n│   ├── api-paste.ini #配置WSGI应用，用于REST API处理\n│   ├── dhcp_agent.ini\n│   ├── init.d\n│   │   └── quantum-server #配置服务脚本，service quantum xxx\n│   ├── l3_agent.ini\n│   ├── lbaas_agent.ini\n│   ├── metadata_agent.ini\n│   ├── policy.json\n│   ├── quantum\n│   │   ├── plugins #都是插件的配置\n│   │   │   ├── bigswitch\n│   │   │   │   └── restproxy.ini\n│   │   │   ├── brocade\n│   │   │   │   └── brocade.ini\n│   │   │   ├── cisco\n│   │   │   │   ├── cisco_plugins.ini\n│   │   │   │   ├── credentials.ini\n│   │   │   │   ├── db_conn.ini\n│   │   │   │   ├── l2network_plugin.ini\n│   │   │   │   └── nexus.ini\n│   │   │   ├── hyperv\n│   │   │   │   └── hyperv_quantum_plugin.ini\n│   │   │   ├── linuxbridge\n│   │   │   │   └── linuxbridge_conf.ini\n│   │   │   ├── metaplugin\n│   │   │   │   └── metaplugin.ini\n│   │   │   ├── midonet\n│   │   │   │   └── midonet.ini\n│   │   │   ├── nec\n│   │   │   │   └── nec.ini\n│   │   │   ├── nicira\n│   │   │   │   └── nvp.ini\n│   │   │   ├── openvswitch\n│   │   │   │   └── ovs_quantum_plugin.ini\n│   │   │   ├── plumgrid\n│   │   │   │   └── plumgrid.ini\n│   │   │   └── ryu\n│   │   │       └── ryu.ini\n│   │   └── rootwrap.d\n│   │       ├── debug.filters\n│   │       ├── dhcp.filters\n│   │       ├── iptables-firewall.filters\n│   │       ├── l3.filters\n│   │       ├── lbaas-haproxy.filters\n│   │       ├── linuxbridge-plugin.filters\n│   │       ├── nec-plugin.filters\n│   │       ├── openvswitch-plugin.filters\n│   │       └── ryu-plugin.filters\n│   ├── quantum.conf #quantum配置文件\n│   └── rootwrap.conf\n├── HACKING.rst\n├── LICENSE\n├── MANIFEST.in\n├── openstack-common.conf\n├── quantum\n│   ├── agent\n│   │   ├── common\n│   │   │   ├── config.py#注册agent通用的选项，主要是agent_state的选项\n│   │   │   └── __init__.py\n│   │   ├── dhcp_agent.py\n│   │   ├── firewall.py\n│   │   ├── __init__.py\n│   │   ├── l3_agent.py\n│   │   ├── linux#涉及linux操作的库，比如设置iptables，获得MAC地址等\n│   │   │   ├── daemon.py\n│   │   │   ├── dhcp.py\n│   │   │   ├── external_process.py\n│   │   │   ├── __init__.py\n│   │   │   ├── interface.py\n│   │   │   ├── ip_lib.py\n│   │   │   ├── iptables_firewall.py\n│   │   │   ├── iptables_manager.py\n│   │   │   ├── ovs_lib.py\n│   │   │   └── utils.py\n│   │   ├── metadata\n│   │   │   ├── agent.py\n│   │   │   ├── __init__.py\n│   │   │   └── namespace_proxy.py\n│   │   ├── netns_cleanup_util.py\n│   │   ├── ovs_cleanup_util.py\n│   │   ├── rpc.py#Agent端通过RPC向Plugin通信的实现\n│   │   └── securitygroups_rpc.py\n│   ├── api\n│   │   ├── api_common.py\n│   │   ├── extensions.py\n│   │   ├── __init__.py\n│   │   ├── rpc\n│   │   │   ├── agentnotifiers\n│   │   │   │   ├── dhcp_rpc_agent_api.py\n│   │   │   │   ├── __init__.py\n│   │   │   │   └── l3_rpc_agent_api.py\n│   │   │   └── __init__.py\n│   │   ├── v2\n│   │   │   ├── attributes.py\n│   │   │   ├── base.py\n│   │   │   ├── __init__.py\n│   │   │   ├── resource.py\n│   │   │   └── router.py\n│   │   ├── versions.py\n│   │   └── views\n│   │       ├── __init__.py\n│   │       └── versions.py\n│   ├── auth.py\n│   ├── common\n│   │   ├── config.py\n│   │   ├── constants.py\n│   │   ├── exceptions.py\n│   │   ├── __init__.py\n│   │   ├── rpc.py\n│   │   ├── test_lib.py\n│   │   ├── topics.py\n│   │   └── utils.py\n│   ├── context.py\n│   ├── db\n│   │   ├── agentschedulers_db.py\n│   │   ├── agents_db.py\n│   │   ├── api.py\n│   │   ├── db_base_plugin_v2.py\n│   │   ├── dhcp_rpc_base.py\n│   │   ├── extraroute_db.py\n│   │   ├── __init__.py\n│   │   ├── l3_db.py\n│   │   ├── l3_rpc_base.py\n│   │   ├── loadbalancer\n│   │   │   ├── __init__.py\n│   │   │   └── loadbalancer_db.py\n│   │   ├── migration\n│   │   │   ├── alembic.ini\n│   │   │   ├── alembic_migrations\n│   │   │   │   ├── common_ext_ops.py\n│   │   │   │   ├── env.py\n│   │   │   │   ├── __init__.py\n│   │   │   │   ├── script.py.mako\n│   │   │   │   └── versions\n│   │   │   │       ├── 1149d7de0cfa_port_security.py\n│   │   │   │       ├── 1341ed32cc1e_nvp_netbinding_update.py\n│   │   │   │       ├── 1b693c095aa3_quota_ext_db_grizzly.py\n│   │   │   │       ├── 1c33fa3cd1a1_extra_route_config.py\n│   │   │   │       ├── 1d76643bcec4_nvp_netbinding.py\n│   │   │   │       ├── 2a6d0b51f4bb_cisco_plugin_cleanup.py\n│   │   │   │       ├── 2c4af419145b_l3_support.py\n│   │   │   │       ├── 363468ac592c_nvp_network_gw.py\n│   │   │   │       ├── 38335592a0dc_nvp_portmap.py\n│   │   │   │       ├── 3b54bf9e29f7_nec_plugin_sharednet.py\n│   │   │   │       ├── 3cb5d900c5de_security_groups.py\n│   │   │   │       ├── 45680af419f9_nvp_qos.py\n│   │   │   │       ├── 4692d074d587_agent_scheduler.py\n│   │   │   │       ├── 48b6f43f7471_service_type.py\n│   │   │   │       ├── 49332180ca96_ryu_plugin_update.py\n│   │   │   │       ├── 511471cc46b_agent_ext_model_supp.py\n│   │   │   │       ├── 54c2c487e913_lbaas.py\n│   │   │   │       ├── 5a875d0e5c_ryu.py\n│   │   │   │       ├── folsom_initial.py\n│   │   │   │       ├── grizzly_release.py\n│   │   │   │       └── README\n│   │   │   ├── cli.py\n│   │   │   ├── __init__.py\n│   │   │   └── README\n│   │   ├── model_base.py\n│   │   ├── models_v2.py\n│   │   ├── portsecurity_db.py\n│   │   ├── quota_db.py\n│   │   ├── routedserviceinsertion_db.py\n│   │   ├── routerservicetype_db.py\n│   │   ├── securitygroups_db.py\n│   │   ├── securitygroups_rpc_base.py\n│   │   ├── servicetype_db.py\n│   │   └── sqlalchemyutils.py\n│   ├── debug\n│   │   ├── commands.py\n│   │   ├── debug_agent.py\n│   │   ├── __init__.py\n│   │   ├── README\n│   │   └── shell.py\n│   ├── extensions\n│   │   ├── agent.py\n│   │   ├── agentscheduler.py\n│   │   ├── extraroute.py\n│   │   ├── flavor.py\n│   │   ├── __init__.py\n│   │   ├── l3.py\n│   │   ├── loadbalancer.py\n│   │   ├── portbindings.py\n│   │   ├── portsecurity.py\n│   │   ├── providernet.py\n│   │   ├── quotasv2.py\n│   │   ├── routedserviceinsertion.py\n│   │   ├── routerservicetype.py\n│   │   ├── securitygroup.py\n│   │   └── servicetype.py\n│   ├── __init__.py\n│   ├── locale\n│   │   ├── ja\n│   │   │   └── LC_MESSAGES\n│   │   │       └── quantum.po\n│   │   └── quantum.pot\n│   ├── manager.py\n│   ├── openstack\n│   │   ├── common\n│   │   │   ├── context.py\n│   │   │   ├── eventlet_backdoor.py\n│   │   │   ├── exception.py\n│   │   │   ├── excutils.py\n│   │   │   ├── fileutils.py\n│   │   │   ├── gettextutils.py\n│   │   │   ├── importutils.py\n│   │   │   ├── __init__.py\n│   │   │   ├── jsonutils.py\n│   │   │   ├── local.py\n│   │   │   ├── lockutils.py\n│   │   │   ├── log.py\n│   │   │   ├── loopingcall.py\n│   │   │   ├── network_utils.py\n│   │   │   ├── notifier\n│   │   │   │   ├── api.py\n│   │   │   │   ├── __init__.py\n│   │   │   │   ├── log_notifier.py\n│   │   │   │   ├── no_op_notifier.py\n│   │   │   │   ├── rabbit_notifier.py\n│   │   │   │   ├── rpc_notifier2.py\n│   │   │   │   ├── rpc_notifier.py\n│   │   │   │   └── test_notifier.py\n│   │   │   ├── periodic_task.py\n│   │   │   ├── policy.py\n│   │   │   ├── processutils.py\n│   │   │   ├── rpc\n│   │   │   │   ├── amqp.py\n│   │   │   │   ├── common.py\n│   │   │   │   ├── dispatcher.py\n│   │   │   │   ├── impl_fake.py\n│   │   │   │   ├── impl_kombu.py\n│   │   │   │   ├── impl_qpid.py\n│   │   │   │   ├── impl_zmq.py\n│   │   │   │   ├── __init__.py\n│   │   │   │   ├── matchmaker.py\n│   │   │   │   ├── matchmaker_redis.py\n│   │   │   │   ├── proxy.py\n│   │   │   │   └── service.py\n│   │   │   ├── service.py\n│   │   │   ├── setup.py\n│   │   │   ├── threadgroup.py\n│   │   │   ├── timeutils.py\n│   │   │   ├── uuidutils.py\n│   │   │   └── version.py\n│   │   └── __init__.py\n│   ├── plugins\n│   │   ├── bigswitch\n│   │   │   ├── __init__.py\n│   │   │   ├── plugin.py\n│   │   │   ├── README\n│   │   │   ├── tests\n│   │   │   │   ├── __init__.py\n│   │   │   │   └── test_server.py\n│   │   │   ├── vcsversion.py\n│   │   │   └── version.py\n│   │   ├── brocade\n│   │   │   ├── db\n│   │   │   │   ├── __init__.py\n│   │   │   │   └── models.py\n│   │   │   ├── __init__.py\n│   │   │   ├── nos\n│   │   │   │   ├── fake_nosdriver.py\n│   │   │   │   ├── __init__.py\n│   │   │   │   ├── nctemplates.py\n│   │   │   │   └── nosdriver.py\n│   │   │   ├── QuantumPlugin.py\n│   │   │   ├── README.md\n│   │   │   ├── tests\n│   │   │   │   ├── noscli.py\n│   │   │   │   ├── nostest.py\n│   │   │   │   └── README\n│   │   │   └── vlanbm.py\n│   │   ├── cisco\n│   │   │   ├── common\n│   │   │   │   ├── cisco_configparser.py\n│   │   │   │   ├── cisco_constants.py\n│   │   │   │   ├── cisco_credentials_v2.py\n│   │   │   │   ├── cisco_exceptions.py\n│   │   │   │   ├── cisco_faults.py\n│   │   │   │   ├── cisco_utils.py\n│   │   │   │   └── __init__.py\n│   │   │   ├── db\n│   │   │   │   ├── api.py\n│   │   │   │   ├── __init__.py\n│   │   │   │   ├── l2network_db.py\n│   │   │   │   ├── l2network_models.py\n│   │   │   │   ├── models.py\n│   │   │   │   ├── network_db_v2.py\n│   │   │   │   ├── network_models_v2.py\n│   │   │   │   ├── nexus_db_v2.py\n│   │   │   │   └── nexus_models_v2.py\n│   │   │   ├── extensions\n│   │   │   │   ├── credential.py\n│   │   │   │   ├── _credential_view.py\n│   │   │   │   ├── __init__.py\n│   │   │   │   ├── qos.py\n│   │   │   │   └── _qos_view.py\n│   │   │   ├── __init__.py\n│   │   │   ├── l2device_plugin_base.py\n│   │   │   ├── l2network_plugin_configuration.py\n│   │   │   ├── models\n│   │   │   │   ├── __init__.py\n│   │   │   │   └── virt_phy_sw_v2.py\n│   │   │   ├── network_plugin.py\n│   │   │   ├── nexus\n│   │   │   │   ├── cisco_nexus_configuration.py\n│   │   │   │   ├── cisco_nexus_network_driver_v2.py\n│   │   │   │   ├── cisco_nexus_plugin_v2.py\n│   │   │   │   ├── cisco_nexus_snippets.py\n│   │   │   │   └── __init__.py\n│   │   │   ├── README\n│   │   │   ├── run_tests.py\n│   │   │   └── tests\n│   │   │       ├── __init__.py\n│   │   │       └── unit\n│   │   │           ├── api-paste.ini.cisco.test\n│   │   │           ├── __init__.py\n│   │   │           ├── quantum.conf.cisco.test\n│   │   │           ├── test_cisco_extension.py\n│   │   │           ├── test_database.py\n│   │   │           └── v2\n│   │   │               ├── api-paste.ini.cisco.test\n│   │   │               ├── __init__.py\n│   │   │               ├── nexus\n│   │   │               │   ├── fake_nexus_driver.py\n│   │   │               │   └── __init__.py\n│   │   │               ├── quantumv2.conf.cisco.test\n│   │   │               └── test_api_v2.py\n│   │   ├── common\n│   │   │   ├── constants.py\n│   │   │   └── __init__.py\n│   │   ├── hyperv\n│   │   │   ├── agent\n│   │   │   │   ├── hyperv_quantum_agent.py\n│   │   │   │   ├── __init__.py\n│   │   │   │   └── utils.py\n│   │   │   ├── agent_notifier_api.py\n│   │   │   ├── common\n│   │   │   │   ├── constants.py\n│   │   │   │   └── __init__.py\n│   │   │   ├── db.py\n│   │   │   ├── hyperv_quantum_plugin.py\n│   │   │   ├── __init__.py\n│   │   │   ├── model.py\n│   │   │   └── rpc_callbacks.py\n│   │   ├── __init__.py\n│   │   ├── linuxbridge\n│   │   │   ├── agent\n│   │   │   │   ├── __init__.py\n│   │   │   │   └── linuxbridge_quantum_agent.py\n│   │   │   ├── common\n│   │   │   │   ├── config.py\n│   │   │   │   ├── constants.py\n│   │   │   │   └── __init__.py\n│   │   │   ├── db\n│   │   │   │   ├── __init__.py\n│   │   │   │   ├── l2network_db_v2.py\n│   │   │   │   └── l2network_models_v2.py\n│   │   │   ├── __init__.py\n│   │   │   ├── lb_quantum_plugin.py\n│   │   │   └── README\n│   │   ├── metaplugin\n│   │   │   ├── common\n│   │   │   │   ├── config.py\n│   │   │   │   └── __init__.py\n│   │   │   ├── __init__.py\n│   │   │   ├── meta_db_v2.py\n│   │   │   ├── meta_models_v2.py\n│   │   │   ├── meta_quantum_plugin.py\n│   │   │   ├── proxy_quantum_plugin.py\n│   │   │   ├── README\n│   │   │   └── run_tests.py\n│   │   ├── midonet\n│   │   │   ├── config.py\n│   │   │   ├── __init__.py\n│   │   │   ├── midonet_lib.py\n│   │   │   └── plugin.py\n│   │   ├── nec\n│   │   │   ├── agent\n│   │   │   │   ├── __init__.py\n│   │   │   │   └── nec_quantum_agent.py\n│   │   │   ├── common\n│   │   │   │   ├── config.py\n│   │   │   │   ├── exceptions.py\n│   │   │   │   ├── __init__.py\n│   │   │   │   └── ofc_client.py\n│   │   │   ├── db\n│   │   │   │   ├── api.py\n│   │   │   │   ├── __init__.py\n│   │   │   │   ├── models.py\n│   │   │   │   └── nec_plugin_base.py\n│   │   │   ├── drivers\n│   │   │   │   ├── __init__.py\n│   │   │   │   ├── pfc.py\n│   │   │   │   └── trema.py\n│   │   │   ├── extensions\n│   │   │   │   ├── __init__.py\n│   │   │   │   └── packetfilter.py\n│   │   │   ├── __init__.py\n│   │   │   ├── nec_plugin.py\n│   │   │   ├── ofc_driver_base.py\n│   │   │   ├── ofc_manager.py\n│   │   │   └── README\n│   │   ├── nicira\n│   │   │   ├── __init__.py\n│   │   │   └── nicira_nvp_plugin\n│   │   │       ├── api_client\n│   │   │       │   ├── client_eventlet.py\n│   │   │       │   ├── client.py\n│   │   │       │   ├── common.py\n│   │   │       │   ├── __init__.py\n│   │   │       │   ├── request_eventlet.py\n│   │   │       │   └── request.py\n│   │   │       ├── check_nvp_config.py\n│   │   │       ├── common\n│   │   │       │   ├── config.py\n│   │   │       │   ├── exceptions.py\n│   │   │       │   ├── __init__.py\n│   │   │       │   ├── metadata_access.py\n│   │   │       │   └── securitygroups.py\n│   │   │       ├── extensions\n│   │   │       │   ├── __init__.py\n│   │   │       │   ├── nvp_networkgw.py\n│   │   │       │   └── nvp_qos.py\n│   │   │       ├── __init__.py\n│   │   │       ├── nicira_db.py\n│   │   │       ├── nicira_models.py\n│   │   │       ├── nicira_networkgw_db.py\n│   │   │       ├── nicira_qos_db.py\n│   │   │       ├── NvpApiClient.py\n│   │   │       ├── nvp_cluster.py\n│   │   │       ├── nvplib.py\n│   │   │       ├── nvp_plugin_version.py\n│   │   │       ├── QuantumPlugin.py\n│   │   │       └── README\n│   │   ├── openvswitch\n│   │   │   ├── agent\n│   │   │   │   ├── __init__.py\n│   │   │   │   ├── ovs_quantum_agent.py#agent主文件\n│   │   │   │   ├── ovs-quantum-agent-xs_xcp.spec\n│   │   │   │   └── xenserver_install.sh\n│   │   │   ├── common\n│   │   │   │   ├── config.py#ovs插件注册选项，用于读取配置文件\n│   │   │   │   ├── constants.py#一些常量\n│   │   │   │   └── __init__.py\n│   │   │   ├── __init__.py\n│   │   │   ├── Makefile\n│   │   │   ├── ovs_db_v2.py\n│   │   │   ├── ovs_models_v2.py#数据库表定义与sqlalchemy的类的映射\n│   │   │   ├── ovs_quantum_plugin.py#插件部分主程序\n│   │   │   └── README\n│   │   ├── plumgrid\n│   │   │   ├── common\n│   │   │   │   ├── exceptions.py\n│   │   │   │   └── __init__.py\n│   │   │   ├── __init__.py\n│   │   │   ├── plumgrid_nos_plugin\n│   │   │   │   ├── __init__.py\n│   │   │   │   ├── plugin_ver.py\n│   │   │   │   ├── plumgrid_nos_snippets.py\n│   │   │   │   ├── plumgrid_plugin.py\n│   │   │   │   └── rest_connection.py\n│   │   │   └── README\n│   │   ├── ryu\n│   │   │   ├── agent\n│   │   │   │   ├── __init__.py\n│   │   │   │   └── ryu_quantum_agent.py\n│   │   │   ├── common\n│   │   │   │   ├── config.py\n│   │   │   │   └── __init__.py\n│   │   │   ├── db\n│   │   │   │   ├── api_v2.py\n│   │   │   │   ├── __init__.py\n│   │   │   │   └── models_v2.py\n│   │   │   ├── __init__.py\n│   │   │   ├── README\n│   │   │   └── ryu_quantum_plugin.py\n│   │   └── services\n│   │       ├── agent_loadbalancer\n│   │       │   ├── agent\n│   │       │   │   ├── api.py\n│   │       │   │   ├── __init__.py\n│   │       │   │   └── manager.py\n│   │       │   ├── constants.py\n│   │       │   ├── drivers\n│   │       │   │   ├── haproxy\n│   │       │   │   │   ├── cfg.py\n│   │       │   │   │   ├── __init__.py\n│   │       │   │   │   └── namespace_driver.py\n│   │       │   │   └── __init__.py\n│   │       │   ├── __init__.py\n│   │       │   └── plugin.py\n│   │       ├── __init__.py\n│   │       └── service_base.py\n│   ├── policy.py\n│   ├── quantum_plugin_base_v2.py\n│   ├── quota.py\n│   ├── rootwrap\n│   │   ├── filters.py\n│   │   ├── __init__.py\n│   │   └── wrapper.py\n│   ├── scheduler\n│   │   ├── dhcp_agent_scheduler.py\n│   │   ├── __init__.py\n│   │   └── l3_agent_scheduler.py\n│   ├── server\n│   │   └── __init__.py\n│   ├── service.py\n│   ├── tests\n│   │   ├── base.py\n│   │   ├── etc\n│   │   │   ├── api-paste.ini.test\n│   │   │   ├── quantum.conf.test\n│   │   │   └── rootwrap.d\n│   │   │       └── quantum.test.filters\n│   │   ├── __init__.py\n│   │   ├── unit\n│   │   │   ├── bigswitch\n│   │   │   │   ├── etc\n│   │   │   │   │   └── restproxy.ini.test\n│   │   │   │   ├── __init__.py\n│   │   │   │   ├── test_restproxy_plugin.py\n│   │   │   │   └── test_router_db.py\n│   │   │   ├── brocade\n│   │   │   │   ├── __init__.py\n│   │   │   │   ├── test_brocade_db.py\n│   │   │   │   ├── test_brocade_plugin.py\n│   │   │   │   └── test_brocade_vlan.py\n│   │   │   ├── cisco\n│   │   │   │   ├── __init__.py\n│   │   │   │   ├── test_network_plugin.py\n│   │   │   │   └── test_nexus_plugin.py\n│   │   │   ├── database_stubs.py\n│   │   │   ├── db\n│   │   │   │   ├── __init__.py\n│   │   │   │   └── loadbalancer\n│   │   │   │       ├── __init__.py\n│   │   │   │       └── test_db_loadbalancer.py\n│   │   │   ├── dummy_plugin.py\n│   │   │   ├── extensions\n│   │   │   │   ├── extendedattribute.py\n│   │   │   │   ├── extensionattribute.py\n│   │   │   │   ├── foxinsocks.py\n│   │   │   │   ├── __init__.py\n│   │   │   │   └── v2attributes.py\n│   │   │   ├── extension_stubs.py\n│   │   │   ├── hyperv\n│   │   │   │   ├── __init__.py\n│   │   │   │   ├── test_hyperv_quantum_agent.py\n│   │   │   │   ├── test_hyperv_quantum_plugin.py\n│   │   │   │   └── test_hyperv_rpcapi.py\n│   │   │   ├── __init__.py\n│   │   │   ├── linuxbridge\n│   │   │   │   ├── __init__.py\n│   │   │   │   ├── test_agent_scheduler.py\n│   │   │   │   ├── test_defaults.py\n│   │   │   │   ├── test_lb_db.py\n│   │   │   │   ├── test_lb_quantum_agent.py\n│   │   │   │   ├── test_lb_security_group.py\n│   │   │   │   ├── test_linuxbridge_plugin.py\n│   │   │   │   └── test_rpcapi.py\n│   │   │   ├── metaplugin\n│   │   │   │   ├── fake_plugin.py\n│   │   │   │   ├── __init__.py\n│   │   │   │   ├── test_basic.py\n│   │   │   │   └── test_metaplugin.py\n│   │   │   ├── midonet\n│   │   │   │   ├── __init__.py\n│   │   │   │   ├── test_midonet_lib.py\n│   │   │   │   └── test_midonet_plugin.py\n│   │   │   ├── nec\n│   │   │   │   ├── __init__.py\n│   │   │   │   ├── stub_ofc_driver.py\n│   │   │   │   ├── test_agent_scheduler.py\n│   │   │   │   ├── test_config.py\n│   │   │   │   ├── test_db.py\n│   │   │   │   ├── test_nec_plugin.py\n│   │   │   │   ├── test_ofc_manager.py\n│   │   │   │   ├── test_pfc_driver.py\n│   │   │   │   ├── test_security_group.py\n│   │   │   │   └── test_trema_driver.py\n│   │   │   ├── nicira\n│   │   │   │   ├── etc\n│   │   │   │   │   ├── fake_get_gwservice.json\n│   │   │   │   │   ├── fake_get_lrouter.json\n│   │   │   │   │   ├── fake_get_lrouter_lport_att.json\n│   │   │   │   │   ├── fake_get_lrouter_lport.json\n│   │   │   │   │   ├── fake_get_lrouter_nat.json\n│   │   │   │   │   ├── fake_get_lswitch.json\n│   │   │   │   │   ├── fake_get_lswitch_lport_att.json\n│   │   │   │   │   ├── fake_get_lswitch_lport.json\n│   │   │   │   │   ├── fake_get_lswitch_lport_status.json\n│   │   │   │   │   ├── fake_post_gwservice.json\n│   │   │   │   │   ├── fake_post_lqueue.json\n│   │   │   │   │   ├── fake_post_lrouter.json\n│   │   │   │   │   ├── fake_post_lrouter_lport.json\n│   │   │   │   │   ├── fake_post_lrouter_nat.json\n│   │   │   │   │   ├── fake_post_lswitch.json\n│   │   │   │   │   ├── fake_post_lswitch_lport.json\n│   │   │   │   │   ├── fake_post_security_profile.json\n│   │   │   │   │   ├── fake_put_lrouter_lport_att.json\n│   │   │   │   │   ├── fake_put_lswitch_lport_att.json\n│   │   │   │   │   └── nvp.ini.test\n│   │   │   │   ├── fake_nvpapiclient.py\n│   │   │   │   ├── __init__.py\n│   │   │   │   ├── test_defaults.py\n│   │   │   │   ├── test_networkgw.py\n│   │   │   │   ├── test_nicira_plugin.py\n│   │   │   │   ├── test_nvp_api_common.py\n│   │   │   │   ├── test_nvp_api_request_eventlet.py\n│   │   │   │   ├── test_nvp_api_request.py\n│   │   │   │   └── test_nvplib.py\n│   │   │   ├── openvswitch\n│   │   │   │   ├── __init__.py\n│   │   │   │   ├── test_agent_scheduler.py\n│   │   │   │   ├── test_openvswitch_plugin.py\n│   │   │   │   ├── test_ovs_db.py\n│   │   │   │   ├── test_ovs_defaults.py\n│   │   │   │   ├── test_ovs_lib.py\n│   │   │   │   ├── test_ovs_quantum_agent.py\n│   │   │   │   ├── test_ovs_rpcapi.py\n│   │   │   │   ├── test_ovs_security_group.py\n│   │   │   │   └── test_ovs_tunnel.py\n│   │   │   ├── plumgrid\n│   │   │   │   ├── __init__.py\n│   │   │   │   └── test_plumgrid_plugin.py\n│   │   │   ├── ryu\n│   │   │   │   ├── fake_ryu.py\n│   │   │   │   ├── __init__.py\n│   │   │   │   ├── test_defaults.py\n│   │   │   │   ├── test_ryu_agent.py\n│   │   │   │   ├── test_ryu_db.py\n│   │   │   │   ├── test_ryu_plugin.py\n│   │   │   │   └── test_ryu_security_group.py\n│   │   │   ├── services\n│   │   │   │   ├── agent_loadbalancer\n│   │   │   │   │   ├── agent\n│   │   │   │   │   │   ├── __init__.py\n│   │   │   │   │   │   ├── test_api.py\n│   │   │   │   │   │   ├── test_init.py\n│   │   │   │   │   │   └── test_manager.py\n│   │   │   │   │   ├── driver\n│   │   │   │   │   │   ├── haproxy\n│   │   │   │   │   │   │   ├── __init__.py\n│   │   │   │   │   │   │   ├── test_cfg.py\n│   │   │   │   │   │   │   └── test_namespace_driver.py\n│   │   │   │   │   │   └── __init__.py\n│   │   │   │   │   ├── __init__.py\n│   │   │   │   │   └── test_plugin.py\n│   │   │   │   └── __init__.py\n│   │   │   ├── test_agent_config.py\n│   │   │   ├── test_agent_ext_plugin.py\n│   │   │   ├── test_agent_linux_utils.py\n│   │   │   ├── test_agent_netns_cleanup.py\n│   │   │   ├── test_agent_ovs_cleanup.py\n│   │   │   ├── test_agent_rpc.py\n│   │   │   ├── test_api_api_common.py\n│   │   │   ├── test_api_v2.py\n│   │   │   ├── test_api_v2_resource.py\n│   │   │   ├── test_attributes.py\n│   │   │   ├── test_auth.py\n│   │   │   ├── test_common_utils.py\n│   │   │   ├── test_config.py\n│   │   │   ├── test_db_migration.py\n│   │   │   ├── test_db_plugin.py\n│   │   │   ├── test_db.py\n│   │   │   ├── test_db_rpc_base.py\n│   │   │   ├── test_debug_commands.py\n│   │   │   ├── test_dhcp_agent.py\n│   │   │   ├── test_extension_extended_attribute.py\n│   │   │   ├── test_extension_extraroute.py\n│   │   │   ├── _test_extension_portbindings.py\n│   │   │   ├── test_extension_portsecurity.py\n│   │   │   ├── test_extension_security_group.py\n│   │   │   ├── test_extensions.py\n│   │   │   ├── test_iptables_firewall.py\n│   │   │   ├── test_iptables_manager.py\n│   │   │   ├── test_l3_agent.py\n│   │   │   ├── test_l3_plugin.py\n│   │   │   ├── testlib_api.py\n│   │   │   ├── test_linux_daemon.py\n│   │   │   ├── test_linux_dhcp.py\n│   │   │   ├── test_linux_external_process.py\n│   │   │   ├── test_linux_interface.py\n│   │   │   ├── test_linux_ip_lib.py\n│   │   │   ├── test_loadbalancer_plugin.py\n│   │   │   ├── test_metadata_agent.py\n│   │   │   ├── test_metadata_namespace_proxy.py\n│   │   │   ├── test_policy.py\n│   │   │   ├── test_quantum_context.py\n│   │   │   ├── test_quantum_manager.py\n│   │   │   ├── test_quota_ext.py\n│   │   │   ├── _test_rootwrap_exec.py\n│   │   │   ├── test_rootwrap.py\n│   │   │   ├── test_routerserviceinsertion.py\n│   │   │   ├── test_security_groups_rpc.py\n│   │   │   ├── test_servicetype.py\n│   │   │   └── test_wsgi.py\n│   │   └── var\n│   │       ├── ca.crt\n│   │       ├── certificate.crt\n│   │       └── privatekey.key\n│   ├── version.py\n│   └── wsgi.py\n├── README\n├── run_tests.py\n├── run_tests.sh\n├── setup.cfg\n├── setup.py\n├── TESTING\n├── tools\n│   ├── build_debs.sh\n│   ├── check_i18n.py\n│   ├── check_i18n_test_case.txt\n│   ├── clean.sh\n│   ├── i18n_cfg.py\n│   ├── install_venv_common.py\n│   ├── install_venv.py\n│   ├── patch_tox_venv.py\n│   ├── pip-requires\n│   ├── test-requires\n│   └── with_venv.sh\n└── tox.ini\n</code></pre>\n','','','inherit','open','open','','287-revision-6','','','2013-04-01 20:29:58','2013-04-01 12:29:58','','287','http://blog.wachang.net/2013/04/287-revision-6/','0','revision','','0');");
E_D("replace into `wp_posts` values('352','1','2013-04-24 10:56:33','2013-04-24 02:56:33','<pre><code>from routes import Mapper  \nmap = Mapper()  \nmap.connect(None, \"/error/{action}/{id}, controller=\"error\")  \nmap.connect(\"home\", \"/\", controller=\"main\", action=\"index\")  \n\n# Match a URL, returns a dict or None if no match  \nresult = map.match(''/error/myapp/4'')  \n# result == {''controller'': ''main'', ''action'': ''myapp'', ''id'': ''4''}  \n</code></pre>\n','','','inherit','open','open','','347-revision','','','2013-04-24 10:56:33','2013-04-24 02:56:33','','347','http://blog.wachang.net/2013/04/347-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('353','1','2013-05-02 14:45:25','0000-00-00 00:00:00','\n','自动草稿','','auto-draft','open','open','','','','','2013-05-02 14:45:25','0000-00-00 00:00:00','','0','http://blog.wachang.net/?p=353','0','post','','0');");

require("../../inc/footer.php");
?>