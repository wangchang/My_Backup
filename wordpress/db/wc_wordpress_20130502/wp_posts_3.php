<?php
require("../../inc/header.php");

/*
		SoftName : EmpireBak Version 2010
		Author   : wm_chief
		Copyright: Powered by www.phome.net
*/

DoSetDbChar('utf8');
E_D("replace into `wp_posts` values('199','1','2013-03-25 00:31:36','2013-03-24 16:31:36','<blockquote>\n  <p>本系列文章索引：</p>\n  \n  <p>1.<a href=\"\">OpenvSwitch完全使用手册(一)-总览Overview</a></p>\n  \n  <p>2.<a href=\"\">OpenvSwitch完全使用手册(二)-概念及工作流程</a></p>\n</blockquote>\n\n<p>本文主要参考<a href=\"http://openvswitch.org/cgi-bin/gitweb.cgi?p=openvswitch;a=blob_plain;f=README;hb=HEAD\">Overview of functionality and components</a>以及<a href=\"http://openvswitch.org/cgi-bin/gitweb.cgi?p=openvswitch;a=blob_plain;f=FAQ;hb=HEAD\">Frequently Asked Questions</a>以及结合自己的理解。</p>\n\n<h2>1 什么是OpenvSwitch</h2>\n\n<p>OpenvSwitch，简称OVS是一个虚拟交换软件，主要用于虚拟机VM环境，作为一个虚拟交换机，支持Xen/XenServer, KVM, and VirtualBox多种虚拟化技术。</p>\n\n<p>在这种某一台机器的虚拟化的环境中，一个虚拟交换机（vswitch）主要有两个作用：传递虚拟机VM之间的流量，以及实现VM和外界网络的通信。</p>\n\n<p>整个OVS代码用C写的。目前有以下功能：</p>\n\n<ul>\n<li>Standard 802.1Q VLAN model with trunk and access ports</li>\n<li>NIC bonding with or without LACP on upstream switch</li>\n<li>NetFlow, sFlow(R), and mirroring for increased visibility</li>\n<li>QoS (Quality of Service) configuration, plus policing</li>\n<li>GRE, GRE over IPSEC, VXLAN, and LISP tunneling</li>\n<li>802.1ag connectivity fault management</li>\n<li>OpenFlow 1.0 plus numerous extensions</li>\n<li>Transactional configuration database with C and Python bindings</li>\n<li>High-performance forwarding using a Linux kernel module</li>\n</ul>\n\n<h2>2 OpenvSwitch的组成</h2>\n\n<ul>\n<li>ovs-vswitchd：守护程序，实现交换功能，和Linux内核兼容模块一起，实现基于流的交换flow-based switching。</li>\n<li>ovsdb-server：轻量级的数据库服务，主要保存了整个OVS的配置信息，包括接口啊，交换内容，VLAN啊等等。ovs-vswitchd会根据数据库中的配置信息工作。</li>\n<li>ovs-dpctl：一个工具，用来配置交换机内核模块，可以控制转发规则。</li>\n<li>ovs-vsctl：主要是获取或者更改ovs-vswitchd的配置信息，此工具操作的时候会更新ovsdb-server中的数据库。</li>\n<li>ovs-appctl：主要是向OVS守护进程发送命令的，一般用不上。</li>\n<li>ovsdbmonitor：GUI工具来显示ovsdb-server中数据信息。</li>\n<li>ovs-controller：一个简单的OpenFlow控制器</li>\n<li>ovs-ofctl：用来控制OVS作为OpenFlow交换机工作时候的流表内容。</li>\n</ul>\n\n<h2>3 OpenvSwitch和其他vswitch</h2>\n\n<p>这里其他的vswitch,包括VMware vNetwork distributed switch以及思科的Cisco Nexus 1000V。</p>\n\n<p>VMware vNetwork distributed switch以及思科的Cisco Nexus 1000V这种虚拟交换机提供的是一个集中式的控制方式，。而OVS则是一个独立的vswitch，他运行在每个实现虚拟化的物理机器上，并提供远程管理。OVS提供了两种在虚拟化环境中远程管理的协议：一个是OpenFlow,通过流表来管理交换机的行为，一个是OVSDB management protocol，用来暴露sietch的port状态。</p>\n','OpenvSwitch完全使用手册(一)-总览Overview','','inherit','open','open','','198-revision','','','2013-03-25 00:31:36','2013-03-24 16:31:36','','198','http://blog.wachang.net/2013/03/198-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('200','1','2013-03-25 00:32:28','2013-03-24 16:32:28','<blockquote>\n  <p>本系列文章索引：</p>\n  \n  <p>1.<a href=\"http://blog.wachang.net/2013/03/openvswitch-fullbook-1-overview\">OpenvSwitch完全使用手册(一)-总览Overview</a></p>\n  \n  <p>2.<a href=\"\">OpenvSwitch完全使用手册(二)-概念及工作流程</a></p>\n</blockquote>\n\n<p>本文主要参考<a href=\"http://openvswitch.org/cgi-bin/gitweb.cgi?p=openvswitch;a=blob_plain;f=README;hb=HEAD\">Overview of functionality and components</a>以及<a href=\"http://openvswitch.org/cgi-bin/gitweb.cgi?p=openvswitch;a=blob_plain;f=FAQ;hb=HEAD\">Frequently Asked Questions</a>以及结合自己的理解。</p>\n\n<h2>1 什么是OpenvSwitch</h2>\n\n<p>OpenvSwitch，简称OVS是一个虚拟交换软件，主要用于虚拟机VM环境，作为一个虚拟交换机，支持Xen/XenServer, KVM, and VirtualBox多种虚拟化技术。</p>\n\n<p>在这种某一台机器的虚拟化的环境中，一个虚拟交换机（vswitch）主要有两个作用：传递虚拟机VM之间的流量，以及实现VM和外界网络的通信。</p>\n\n<p>整个OVS代码用C写的。目前有以下功能：</p>\n\n<ul>\n<li>Standard 802.1Q VLAN model with trunk and access ports</li>\n<li>NIC bonding with or without LACP on upstream switch</li>\n<li>NetFlow, sFlow(R), and mirroring for increased visibility</li>\n<li>QoS (Quality of Service) configuration, plus policing</li>\n<li>GRE, GRE over IPSEC, VXLAN, and LISP tunneling</li>\n<li>802.1ag connectivity fault management</li>\n<li>OpenFlow 1.0 plus numerous extensions</li>\n<li>Transactional configuration database with C and Python bindings</li>\n<li>High-performance forwarding using a Linux kernel module</li>\n</ul>\n\n<h2>2 OpenvSwitch的组成</h2>\n\n<ul>\n<li>ovs-vswitchd：守护程序，实现交换功能，和Linux内核兼容模块一起，实现基于流的交换flow-based switching。</li>\n<li>ovsdb-server：轻量级的数据库服务，主要保存了整个OVS的配置信息，包括接口啊，交换内容，VLAN啊等等。ovs-vswitchd会根据数据库中的配置信息工作。</li>\n<li>ovs-dpctl：一个工具，用来配置交换机内核模块，可以控制转发规则。</li>\n<li>ovs-vsctl：主要是获取或者更改ovs-vswitchd的配置信息，此工具操作的时候会更新ovsdb-server中的数据库。</li>\n<li>ovs-appctl：主要是向OVS守护进程发送命令的，一般用不上。</li>\n<li>ovsdbmonitor：GUI工具来显示ovsdb-server中数据信息。</li>\n<li>ovs-controller：一个简单的OpenFlow控制器</li>\n<li>ovs-ofctl：用来控制OVS作为OpenFlow交换机工作时候的流表内容。</li>\n</ul>\n\n<h2>3 OpenvSwitch和其他vswitch</h2>\n\n<p>这里其他的vswitch,包括VMware vNetwork distributed switch以及思科的Cisco Nexus 1000V。</p>\n\n<p>VMware vNetwork distributed switch以及思科的Cisco Nexus 1000V这种虚拟交换机提供的是一个集中式的控制方式，。而OVS则是一个独立的vswitch，他运行在每个实现虚拟化的物理机器上，并提供远程管理。OVS提供了两种在虚拟化环境中远程管理的协议：一个是OpenFlow,通过流表来管理交换机的行为，一个是OVSDB management protocol，用来暴露sietch的port状态。</p>\n','OpenvSwitch完全使用手册(一)-总览Overview','','inherit','open','open','','198-revision-2','','','2013-03-25 00:32:28','2013-03-24 16:32:28','','198','http://blog.wachang.net/2013/03/198-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('201','1','2013-03-25 16:41:31','2013-03-25 08:41:31','<blockquote>\n  <p>OpenvSwitch完全使用手册(二)-概念及工作流程1</p>\n</blockquote>\n\n<h2>1 vswitch、Bridge、Datapath</h2>\n\n<p>在网络中，交换机和桥都是同一个概念，OVS实现了一个虚拟机的以太交换机，换句话说，OVS也就是实现了一个以太桥。那么，在OVS中，给一个交换机，或者说一个桥，用了一个专业的名词，叫做DataPath！</p>\n\n<p>要了解，OVS如何工作，首先需要知道桥的概念。</p>\n\n<p>网桥也叫做桥接器，连接两个局域网的设备，网桥工作在数据链路层，将两个LAN连接，根据MAC地址来转发帧，可以看成一个“低层的路由器”（路由器工作在网络层，根据IP地质进行转发）。</p>\n\n<!--more-->\n\n<h3>1.1 网桥的工作原理</h3>\n\n<p>网桥处理包遵循以下几条规则：</p>\n\n<ul>\n<li>在一个接口上接收到的包不会再往那个接口上发送此包。</li>\n<li>每个接收到的包都要学习其源MAC地址。</li>\n<li>如果数据包是多播或者广播包（通过2层MAC地址确定）则要向接收端口以外的所有端口转发，如果上层协议感兴趣，则还会递交上层处理。</li>\n<li>如果数据包的地址不能再CAM表中找到，则向接收端口以外的其他端口转发。</li>\n<li>如果CAM表中能找到，则转发给相应端口，如果发送和接收都是统一端口，则不发送。</li>\n</ul>\n\n<p>注意，网桥是以<code>混杂模式工作</code>的。关于网桥更多，请查阅相关资料。</p>\n\n<h2>2 OVS中的bridge</h2>\n\n<p>上面，说到，一个桥就是一个交换机。在OVS中，</p>\n\n<pre><code>ovs-vsctl add-br brname(br-int)\n\nroot@Compute2:~# ifconfig\n      br-int    Link encap:Ethernet  HWaddr 1a:09:56:ea:0b:49  \n      inet6 addr: fe80::1809:56ff:feea:b49/64 Scope:Link\n      UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n      RX packets:1584 errors:0 dropped:0 overruns:0 frame:0\n      TX packets:6 errors:0 dropped:0 overruns:0 carrier:0\n      collisions:0 txqueuelen:0 \n      RX bytes:316502 (316.5 KB)  TX bytes:468 (468.0 B)\n</code></pre>\n\n<p>当我们创建了一个交换机（网桥）以后，此时网络功能不受影响，但是会产生一个虚拟网卡，名字就是brname，之所以会产生一个虚拟网卡，是为了实现接下来的网桥（交换机）功能。有了这个交换机以后，我还需要为这个交换机增加端口(port)，一个端口，就是一个物理网卡，当网卡加入到这个交换机之后，其工作方式就和普通交换机的一个端口的工作方式类似了。</p>\n\n<pre><code>ovs-vsctl add-port brname port\n</code></pre>\n\n<p><strong>这里要特别注意，网卡加入网桥以后，要按照网桥的工作标准工作，那么加入的一个端口就必须是以混杂模式工作，工作在链路层，处理2层的帧，所以这个port就不需要配置IP了。（你没见过哪个交换的端口有IP的吧）</strong></p>\n\n<p>那么接下来你可能会问，通常的交换机不都是有一个管理接口，可以telnet到交换机上进行配置吧，那么在OVS中创建的虚拟交换机有木有这种呢，有的！上面既然创建交换机brname的时候产生了一个虚拟网口brname,那么，你给这个虚拟网卡配置了IP以后，就相当于给交换机的管理接口配置了IP，此时一个正常的虚拟交换机就搞定了。</p>\n\n<pre><code>ip address add 192.168.1.1/24 dev brname\n</code></pre>\n\n<p>最后，我们来看看一个br的具体信息：</p>\n\n<pre><code>root@Compute2:~# ovs-vsctl show\nbc12c8d2-6900-42dd-9c1c-30e8ecb99a1b\nBridge \"br0\"\n    Port \"eth0\"\n        Interface \"eth0\"\n    Port \"br0\"\n        Interface \"br0\"\n            type: internal\novs_version: \"1.4.0+build0\"\n</code></pre>\n\n<p>首先，这里显示了一个名为br0的桥（交换机），这个交换机有两个接口,一个是eth0，一个是br0，上面说到，创建桥的时候会创建一个和桥名字一样的接口，并自动作为该桥的一个端口，那么这个虚拟接口的作用，一方面是可以作为交换机的管理端口，另一方面也是基于这个虚拟接口，实现了桥的功能。</p>\n\n<h2>3 参考资料：</h2>\n\n<p><a href=\"http://openvswitch.org/cgi-bin/gitweb.cgi?p=openvswitch;a=blob_plain;f=FAQ;hb=HEAD\">http://openvswitch.org/cgi-bin/gitweb.cgi?p=openvswitch;a=blob_plain;f=FAQ;hb=HEAD</a></p>\n','OpenvSwitch完全使用手册(二)-概念及工作流程1','','publish','open','open','','openvswitch-fullbook-2-workflow-1','','\nhttp://blog.wachang.net/2013/03/openvswitch-fullbook-1-overview/','2013-03-25 18:49:59','2013-03-25 10:49:59','','0','http://blog.wachang.net/?p=201','0','post','','0');");
E_D("replace into `wp_posts` values('202','1','2013-03-25 16:18:42','2013-03-25 08:18:42','<p>本系列文章索引：</p>\n\n<p>1.<a href=\"http://blog.wachang.net/2013/03/openvswitch-fullbook-1-overview/\">OpenvSwitch完全使用手册(一)-总览Overview</a></p>\n\n<p>2.<a href=\"http://blog.wachang.net/2013/03/openvswitch-fullook-2-workflow/\">OpenvSwitch完全使用手册(二)-概念及工作流程</a></p>\n\n<p>3.<a href=\"\">OpenvSwitch完全使用手册(三)-基本安装和使用</a></p>\n\n<h2>1 vswitch、Bridge、Datapath</h2>\n\n<p>在网络中，交换机和桥都是同一个概念，OVS实现了一个虚拟机的以太交换机，换句话说，OVS也就是实现了一个以太桥。那么，在OVS中，给一个交换机，或者说一个桥，用了一个专业的名词，叫做DataPath！</p>\n\n<p>要了解，OVS如何工作，首先需要知道桥的概念。</p>\n\n<p>网桥也叫做桥接器，连接两个局域网的设备，网桥工作在数据链路层，将两个LAN连接，根据MAC地址来转发帧，可以看成一个“低层的路由器”（路由器工作在网络层，根据IP地质进行转发）。</p>\n\n<h3>1.1 网桥的工作原理</h3>\n\n<p>网桥处理包遵循以下几条规则：</p>\n\n<ul>\n<li>在一个接口上接收到的包不会再往那个接口上发送此包。</li>\n<li>每个接收到的包都要学习其源MAC地址。</li>\n<li>如果数据包是多播或者广播包（通过2层MAC地址确定）则要向接收端口以外的所有端口转发，如果上层协议感兴趣，则还会递交上层处理。</li>\n<li>如果数据包的地址不能再CAM表中找到，则向接收端口以外的其他端口转发。</li>\n<li>如果CAM表中能找到，则转发给相应端口，如果发送和接收都是统一端口，则不发送。</li>\n</ul>\n\n<p>注意，网桥是以<code>混杂模式工作</code>的。关于网桥更多，请查阅相关资料。</p>\n\n<h2>2 OVS中的bridge</h2>\n\n<p>上面，说到，一个桥就是一个交换机。在OVS中，</p>\n\n<pre><code>ovs-vsctl add-br brname(br-int)\n\nroot@Compute2:~# ifconfig\n      br-int    Link encap:Ethernet  HWaddr 1a:09:56:ea:0b:49  \n      inet6 addr: fe80::1809:56ff:feea:b49/64 Scope:Link\n      UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n      RX packets:1584 errors:0 dropped:0 overruns:0 frame:0\n      TX packets:6 errors:0 dropped:0 overruns:0 carrier:0\n      collisions:0 txqueuelen:0 \n      RX bytes:316502 (316.5 KB)  TX bytes:468 (468.0 B)\n</code></pre>\n\n<p>当我们创建了一个交换机（网桥）以后，此时网络功能不受影响，但是会产生一个虚拟网卡，名字就是brname，之所以会产生一个虚拟网卡，是为了实现接下来的网桥（交换机）功能。有了这个交换机以后，我还需要为这个交换机增加端口(port)，一个端口，就是一个物理网卡，当网卡加入到这个交换机之后，其工作方式就和普通交换机的一个端口的工作方式类似了。</p>\n\n<pre><code>ovs-vsctl add-port brname port\n</code></pre>\n\n<p><strong>这里要特别注意，网卡加入网桥以后，要按照网桥的工作标准工作，那么加入的一个端口就必须是以混杂模式工作，工作在链路层，处理2层的帧，所以这个port就不需要配置IP了。（你没见过哪个交换的端口有IP的吧）</strong></p>\n\n<p>那么接下来你可能会问，通常的交换机不都是有一个管理接口，可以telnet到交换机上进行配置吧，那么在OVS中创建的虚拟交换机有木有这种呢，有的！上面既然创建交换机brname的时候产生了一个虚拟网口brname,那么，你给这个虚拟网卡配置了IP以后，就相当于给交换机的管理接口配置了IP，此时一个正常的虚拟交换机就搞定了。</p>\n\n<pre><code>ip address add 192.168.1.1/24 dev brname\n</code></pre>\n','OpenvSwitch完全使用手册(二)-概念及工作流程','','inherit','open','open','','201-revision','','','2013-03-25 16:18:42','2013-03-25 08:18:42','','201','http://blog.wachang.net/2013/03/201-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('203','1','2013-03-25 16:40:18','2013-03-25 08:40:18','<p>本系列文章索引：</p>\n\n<p>1.<a href=\"http://blog.wachang.net/2013/03/openvswitch-fullbook-1-overview/\">OpenvSwitch完全使用手册(一)-总览Overview</a></p>\n\n<p>2.<a href=\"http://blog.wachang.net/2013/03/openvswitch-fullook-2-workflow-1/\">OpenvSwitch完全使用手册(二)-概念及工作流程1</a></p>\n\n<p>3.<a href=\"\">OpenvSwitch完全使用手册(三)-基本安装和使用</a></p>\n\n<h2>1 vswitch、Bridge、Datapath</h2>\n\n<p>在网络中，交换机和桥都是同一个概念，OVS实现了一个虚拟机的以太交换机，换句话说，OVS也就是实现了一个以太桥。那么，在OVS中，给一个交换机，或者说一个桥，用了一个专业的名词，叫做DataPath！</p>\n\n<p>要了解，OVS如何工作，首先需要知道桥的概念。</p>\n\n<p>网桥也叫做桥接器，连接两个局域网的设备，网桥工作在数据链路层，将两个LAN连接，根据MAC地址来转发帧，可以看成一个“低层的路由器”（路由器工作在网络层，根据IP地质进行转发）。</p>\n\n<h3>1.1 网桥的工作原理</h3>\n\n<p>网桥处理包遵循以下几条规则：</p>\n\n<ul>\n<li>在一个接口上接收到的包不会再往那个接口上发送此包。</li>\n<li>每个接收到的包都要学习其源MAC地址。</li>\n<li>如果数据包是多播或者广播包（通过2层MAC地址确定）则要向接收端口以外的所有端口转发，如果上层协议感兴趣，则还会递交上层处理。</li>\n<li>如果数据包的地址不能再CAM表中找到，则向接收端口以外的其他端口转发。</li>\n<li>如果CAM表中能找到，则转发给相应端口，如果发送和接收都是统一端口，则不发送。</li>\n</ul>\n\n<p>注意，网桥是以<code>混杂模式工作</code>的。关于网桥更多，请查阅相关资料。</p>\n\n<h2>2 OVS中的bridge</h2>\n\n<p>上面，说到，一个桥就是一个交换机。在OVS中，</p>\n\n<pre><code>ovs-vsctl add-br brname(br-int)\n\nroot@Compute2:~# ifconfig\n      br-int    Link encap:Ethernet  HWaddr 1a:09:56:ea:0b:49  \n      inet6 addr: fe80::1809:56ff:feea:b49/64 Scope:Link\n      UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n      RX packets:1584 errors:0 dropped:0 overruns:0 frame:0\n      TX packets:6 errors:0 dropped:0 overruns:0 carrier:0\n      collisions:0 txqueuelen:0 \n      RX bytes:316502 (316.5 KB)  TX bytes:468 (468.0 B)\n</code></pre>\n\n<p>当我们创建了一个交换机（网桥）以后，此时网络功能不受影响，但是会产生一个虚拟网卡，名字就是brname，之所以会产生一个虚拟网卡，是为了实现接下来的网桥（交换机）功能。有了这个交换机以后，我还需要为这个交换机增加端口(port)，一个端口，就是一个物理网卡，当网卡加入到这个交换机之后，其工作方式就和普通交换机的一个端口的工作方式类似了。</p>\n\n<pre><code>ovs-vsctl add-port brname port\n</code></pre>\n\n<p><strong>这里要特别注意，网卡加入网桥以后，要按照网桥的工作标准工作，那么加入的一个端口就必须是以混杂模式工作，工作在链路层，处理2层的帧，所以这个port就不需要配置IP了。（你没见过哪个交换的端口有IP的吧）</strong></p>\n\n<p>那么接下来你可能会问，通常的交换机不都是有一个管理接口，可以telnet到交换机上进行配置吧，那么在OVS中创建的虚拟交换机有木有这种呢，有的！上面既然创建交换机brname的时候产生了一个虚拟网口brname,那么，你给这个虚拟网卡配置了IP以后，就相当于给交换机的管理接口配置了IP，此时一个正常的虚拟交换机就搞定了。</p>\n\n<pre><code>ip address add 192.168.1.1/24 dev brname\n</code></pre>\n\n<p>最后，我们来看看一个br的具体信息：</p>\n\n<pre><code>root@Compute2:~# ovs-vsctl show\nbc12c8d2-6900-42dd-9c1c-30e8ecb99a1b\nBridge \"br0\"\n    Port \"eth0\"\n        Interface \"eth0\"\n    Port \"br0\"\n        Interface \"br0\"\n            type: internal\novs_version: \"1.4.0+build0\"\n</code></pre>\n\n<p>首先，这里显示了一个名为br0的桥（交换机），这个交换机有两个接口,一个是eth0，一个是br0，上面说到，创建桥的时候会创建一个和桥名字一样的接口，并自动作为该桥的一个端口，那么这个虚拟接口的作用，一方面是可以作为交换机的管理端口，另一方面也是基于这个虚拟接口，实现了桥的功能。</p>\n\n<h2>3 参考资料：</h2>\n\n<p><a href=\"http://openvswitch.org/cgi-bin/gitweb.cgi?p=openvswitch;a=blob_plain;f=FAQ;hb=HEAD\">http://openvswitch.org/cgi-bin/gitweb.cgi?p=openvswitch;a=blob_plain;f=FAQ;hb=HEAD</a></p>\n','OpenvSwitch完全使用手册(二)-概念及工作流程1','','inherit','open','open','','201-revision-2','','','2013-03-25 16:40:18','2013-03-25 08:40:18','','201','http://blog.wachang.net/2013/03/201-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('204','1','2013-03-25 16:41:31','2013-03-25 08:41:31','<p>本系列文章索引：</p>\n\n<p>1.<a href=\"http://blog.wachang.net/2013/03/openvswitch-fullbook-1-overview/\">OpenvSwitch完全使用手册(一)-总览Overview</a></p>\n\n<p>2.<a href=\"http://blog.wachang.net/2013/03/openvswitch-fullook-2-workflow-1/\">OpenvSwitch完全使用手册(二)-概念及工作流程1</a></p>\n\n<p>3.<a href=\"\">OpenvSwitch完全使用手册(三)-基本安装和使用</a></p>\n\n<h2>1 vswitch、Bridge、Datapath</h2>\n\n<p>在网络中，交换机和桥都是同一个概念，OVS实现了一个虚拟机的以太交换机，换句话说，OVS也就是实现了一个以太桥。那么，在OVS中，给一个交换机，或者说一个桥，用了一个专业的名词，叫做DataPath！</p>\n\n<p>要了解，OVS如何工作，首先需要知道桥的概念。</p>\n\n<p>网桥也叫做桥接器，连接两个局域网的设备，网桥工作在数据链路层，将两个LAN连接，根据MAC地址来转发帧，可以看成一个“低层的路由器”（路由器工作在网络层，根据IP地质进行转发）。</p>\n\n<h3>1.1 网桥的工作原理</h3>\n\n<p>网桥处理包遵循以下几条规则：</p>\n\n<ul>\n<li>在一个接口上接收到的包不会再往那个接口上发送此包。</li>\n<li>每个接收到的包都要学习其源MAC地址。</li>\n<li>如果数据包是多播或者广播包（通过2层MAC地址确定）则要向接收端口以外的所有端口转发，如果上层协议感兴趣，则还会递交上层处理。</li>\n<li>如果数据包的地址不能再CAM表中找到，则向接收端口以外的其他端口转发。</li>\n<li>如果CAM表中能找到，则转发给相应端口，如果发送和接收都是统一端口，则不发送。</li>\n</ul>\n\n<p>注意，网桥是以<code>混杂模式工作</code>的。关于网桥更多，请查阅相关资料。</p>\n\n<h2>2 OVS中的bridge</h2>\n\n<p>上面，说到，一个桥就是一个交换机。在OVS中，</p>\n\n<pre><code>ovs-vsctl add-br brname(br-int)\n\nroot@Compute2:~# ifconfig\n      br-int    Link encap:Ethernet  HWaddr 1a:09:56:ea:0b:49  \n      inet6 addr: fe80::1809:56ff:feea:b49/64 Scope:Link\n      UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n      RX packets:1584 errors:0 dropped:0 overruns:0 frame:0\n      TX packets:6 errors:0 dropped:0 overruns:0 carrier:0\n      collisions:0 txqueuelen:0 \n      RX bytes:316502 (316.5 KB)  TX bytes:468 (468.0 B)\n</code></pre>\n\n<p>当我们创建了一个交换机（网桥）以后，此时网络功能不受影响，但是会产生一个虚拟网卡，名字就是brname，之所以会产生一个虚拟网卡，是为了实现接下来的网桥（交换机）功能。有了这个交换机以后，我还需要为这个交换机增加端口(port)，一个端口，就是一个物理网卡，当网卡加入到这个交换机之后，其工作方式就和普通交换机的一个端口的工作方式类似了。</p>\n\n<pre><code>ovs-vsctl add-port brname port\n</code></pre>\n\n<p><strong>这里要特别注意，网卡加入网桥以后，要按照网桥的工作标准工作，那么加入的一个端口就必须是以混杂模式工作，工作在链路层，处理2层的帧，所以这个port就不需要配置IP了。（你没见过哪个交换的端口有IP的吧）</strong></p>\n\n<p>那么接下来你可能会问，通常的交换机不都是有一个管理接口，可以telnet到交换机上进行配置吧，那么在OVS中创建的虚拟交换机有木有这种呢，有的！上面既然创建交换机brname的时候产生了一个虚拟网口brname,那么，你给这个虚拟网卡配置了IP以后，就相当于给交换机的管理接口配置了IP，此时一个正常的虚拟交换机就搞定了。</p>\n\n<pre><code>ip address add 192.168.1.1/24 dev brname\n</code></pre>\n\n<p>最后，我们来看看一个br的具体信息：</p>\n\n<pre><code>root@Compute2:~# ovs-vsctl show\nbc12c8d2-6900-42dd-9c1c-30e8ecb99a1b\nBridge \"br0\"\n    Port \"eth0\"\n        Interface \"eth0\"\n    Port \"br0\"\n        Interface \"br0\"\n            type: internal\novs_version: \"1.4.0+build0\"\n</code></pre>\n\n<p>首先，这里显示了一个名为br0的桥（交换机），这个交换机有两个接口,一个是eth0，一个是br0，上面说到，创建桥的时候会创建一个和桥名字一样的接口，并自动作为该桥的一个端口，那么这个虚拟接口的作用，一方面是可以作为交换机的管理端口，另一方面也是基于这个虚拟接口，实现了桥的功能。</p>\n\n<h2>3 参考资料：</h2>\n\n<p><a href=\"http://openvswitch.org/cgi-bin/gitweb.cgi?p=openvswitch;a=blob_plain;f=FAQ;hb=HEAD\">http://openvswitch.org/cgi-bin/gitweb.cgi?p=openvswitch;a=blob_plain;f=FAQ;hb=HEAD</a></p>\n','OpenvSwitch完全使用手册(二)-概念及工作流程1','','inherit','open','open','','201-revision-3','','','2013-03-25 16:41:31','2013-03-25 08:41:31','','201','http://blog.wachang.net/2013/03/201-revision-3/','0','revision','','0');");
E_D("replace into `wp_posts` values('205','1','2013-03-25 18:59:02','2013-03-25 10:59:02','<blockquote>\n  <p>OpenvSwitch完全使用手册(二)-概念及工作流程2</p>\n  \n  <p>这一部分我以一个简单的例子，说明在虚拟化环境中OpenvSwitch的典型工作流程。</p>\n</blockquote>\n\n<p>前面已经说到，OVS主要是用来在虚拟化环境中。虚拟机之间一个虚拟机和外网之间的通信所用，如下是一个典型的结构图：</p>\n\n<p>那么，通常情况下的工作流程如下：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/vm-ovs-workflow.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/vm-ovs-workflow.png\" alt=\"vm-ovs-workflow\" width=\"752\" height=\"416\" class=\"aligncenter size-full wp-image-217\" /></a></p>\n\n<ul>\n<li>1 VM实例instance产生一个数据包并发送至实例内的虚拟网络接口VNIC，图中就是instance中的eth0.</li>\n<li>2 这个数据包会传送到物理节点上的VNIC接口，如图就是vnet接口。</li>\n<li>3 数据包从vnet NIC出来，到达桥（虚拟交换机）br100上.</li>\n<li>4 数据包经过交换机的处理，从物理节点上的物理接口发出，如图中物理节点上的eth0.</li>\n<li>5 数据包从eth0出去的时候，是按照物理节点上的路由以及默认网关操作的，这个时候该数据包其实已经不受你的控制了。</li>\n</ul>\n','OpenvSwitch完全使用手册(二)-概念及工作流程2','','publish','open','open','','openvswitch-fullbook-2-workflow-2','','','2013-03-25 18:59:39','2013-03-25 10:59:39','','0','http://blog.wachang.net/?p=205','0','post','','0');");
E_D("replace into `wp_posts` values('206','1','2013-03-25 16:47:37','2013-03-25 08:47:37','<a title=\"OpenvSwitch完全使用手册(一)-总览Overview\" href=\"http://blog.wachang.net/2013/03/openvswitch-fullbook-1-overview/\" target=\"_blank\">OpenvSwitch完全使用手册(一)-总览Overview</a>\r\n\r\n<a title=\"OpenvSwitch完全使用手册(二)-概念及工作流程1\" href=\"http://blog.wachang.net/2013/03/openvswitch-fullbook-2-workflow-1/\" target=\"_blank\">OpenvSwitch完全使用手册(二)-概念及工作流程1</a>\r\n\r\n<a href=\"http://blog.wachang.net/2013/03/openvswitch-fullbook-2-workflow-2/\">OpenvSwitch完全使用手册(二)-概念及工作流程2</a>\r\n\r\nOpenvSwitch完全使用手册(三)-基本安装和使用\r\n\r\nOpenvSwitch完全使用手册(四)-OVS的数据库\r\n\r\nOpenvSwitch完全使用手册()-OpenFlow\r\n\r\nOpenvSwitch完全使用手册()-VLAN\r\n\r\nOpenvSwitch完全使用手册()-sFlow\r\n\r\nOpenvSwitch完全使用手册()-GRE\r\n\r\nOpenvSwitch完全使用手册()-VXLAN\r\n\r\nOpenvSwitch完全使用手册()-...','OpenvSwitch完全使用手册','','publish','open','open','','openvswitch-fullbook','','','2013-03-25 19:07:19','2013-03-25 11:07:19','','0','http://blog.wachang.net/?page_id=206','0','page','','0');");
E_D("replace into `wp_posts` values('207','1','2013-03-25 16:47:29','2013-03-25 08:47:29','<a title=\"OpenvSwitch完全使用手册(一)-总览Overview\" href=\"http://blog.wachang.net/2013/03/openvswitch-fullbook-1-overview/\" target=\"_blank\">OpenvSwitch完全使用手册(一)-总览Overview</a>\n\n<a title=\"OpenvSwitch完全使用手册(二)-概念及工作流程1\" href=\"http://blog.wachang.net/2013/03/openvswitch-fullbook-2-workflow-1/\" target=\"_blank\">OpenvSwitch完全使用手册(二)-概念及工作流程1</a>','OpenvSwitch完全使用手册','','inherit','open','open','','206-revision','','','2013-03-25 16:47:29','2013-03-25 08:47:29','','206','http://blog.wachang.net/2013/03/206-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('208','1','2013-03-25 16:47:37','2013-03-25 08:47:37',' ','','','publish','open','open','','208','','','2013-04-23 12:20:50','2013-04-23 04:20:50','','0','http://blog.wachang.net/2013/03/208/','4','nav_menu_item','','0');");
E_D("replace into `wp_posts` values('209','1','2013-03-25 16:50:09','2013-03-25 08:50:09','<h1>浅出OpenStack源码系列</h1>\n\n<h2>1.Python基础模块篇</h2>\n\n<p>OpenStack中使用了许多python模块，这一章就先介绍一下主要模块的最用，同时也是后续文章中的一些参考。</p>\n\n<p><a href=\"http://webpython.codepoint.net/wsgi_tutorial\">Python:WSGI介绍</a></p>\n\n<p><a href=\"http://blog.wachang.net/2013/04/python-paste-deploy-1/\">Python.Paste指南之Deploy(1)-概念</a></p>\n\n<p><a href=\"http://blog.wachang.net/2013/04/python-paste-deploy-2/\">Python.Paste指南之Deploy(2)-实践</a></p>\n\n<h2>2.Quantum篇</h2>\n\n<h3>2.1 Quantum Server</h3>\n\n<p><a href=\"http://blog.wachang.net/2013/04/quantum-code-base/\">Quantum 基础知识及服务启动</a></p>\n\n<p><a href=\"http://blog.wachang.net/2013/04/quantum-wsgi-define-and-how-to-handle-api/\">Quantum WSGI中代码概念及如何处理API</a></p>\n\n<p><a href=\"http://blog.wachang.net/2013/04/quantum-wsgi-base/\">Quantum WSGI服务基础</a></p>\n\n<h3>2.3 OpenvSwitch Plugin</h3>\n\n<p><a href=\"http://blog.wachang.net/2013/03/quantum-ovs-plugin-code-structure/\">Quantum OpenvSwitch Plugin代码架构</a></p>\n\n<p><a href=\"http://blog.wachang.net/2013/03/quantum-ovs-agent-config-file/\">Quantum OpenvSwitch Plugin&amp;Agent读取配置文件</a></p>\n\n<p><a href=\"http://blog.wachang.net/2013/03/quantum-ovs-plugin-agent-rpc-1/\">Quantum OpenvSwitch Plugin和Agent的RPC机制（一）</a></p>\n','浅出OpenStack源码','','publish','open','open','','openstack-src-insight','','','2013-04-07 14:04:08','2013-04-07 06:04:08','','0','http://blog.wachang.net/?page_id=209','0','page','','0');");
E_D("replace into `wp_posts` values('210','1','2013-03-25 16:49:34','2013-03-25 08:49:34','','浅出OpenStack源码','','inherit','open','open','','209-revision','','','2013-03-25 16:49:34','2013-03-25 08:49:34','','209','http://blog.wachang.net/2013/03/209-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('211','1','2013-03-25 16:50:09','2013-03-25 08:50:09',' ','','','publish','open','open','','211','','','2013-04-23 12:20:50','2013-04-23 04:20:50','','0','http://blog.wachang.net/2013/03/211/','5','nav_menu_item','','0');");
E_D("replace into `wp_posts` values('212','1','2013-03-25 16:41:45','2013-03-25 08:41:45','<p>本系列文章索引：</p>\n\n<p>1.<a href=\"http://blog.wachang.net/2013/03/openvswitch-fullbook-1-overview/\">OpenvSwitch完全使用手册(一)-总览Overview</a></p>\n\n<p>2.<a href=\"http://blog.wachang.net/2013/03/openvswitch-fullook-2-workflow-1/\">OpenvSwitch完全使用手册(二)-概念及工作流程1</a></p>\n\n<p>3.<a href=\"\">OpenvSwitch完全使用手册(三)-基本安装和使用</a></p>\n\n<h2>1 vswitch、Bridge、Datapath</h2>\n\n<p>在网络中，交换机和桥都是同一个概念，OVS实现了一个虚拟机的以太交换机，换句话说，OVS也就是实现了一个以太桥。那么，在OVS中，给一个交换机，或者说一个桥，用了一个专业的名词，叫做DataPath！</p>\n\n<p>要了解，OVS如何工作，首先需要知道桥的概念。</p>\n\n<p>网桥也叫做桥接器，连接两个局域网的设备，网桥工作在数据链路层，将两个LAN连接，根据MAC地址来转发帧，可以看成一个“低层的路由器”（路由器工作在网络层，根据IP地质进行转发）。</p>\n\n<!--more-->\n\n<h3>1.1 网桥的工作原理</h3>\n\n<p>网桥处理包遵循以下几条规则：</p>\n\n<ul>\n<li>在一个接口上接收到的包不会再往那个接口上发送此包。</li>\n<li>每个接收到的包都要学习其源MAC地址。</li>\n<li>如果数据包是多播或者广播包（通过2层MAC地址确定）则要向接收端口以外的所有端口转发，如果上层协议感兴趣，则还会递交上层处理。</li>\n<li>如果数据包的地址不能再CAM表中找到，则向接收端口以外的其他端口转发。</li>\n<li>如果CAM表中能找到，则转发给相应端口，如果发送和接收都是统一端口，则不发送。</li>\n</ul>\n\n<p>注意，网桥是以<code>混杂模式工作</code>的。关于网桥更多，请查阅相关资料。</p>\n\n<h2>2 OVS中的bridge</h2>\n\n<p>上面，说到，一个桥就是一个交换机。在OVS中，</p>\n\n<pre><code>ovs-vsctl add-br brname(br-int)\n\nroot@Compute2:~# ifconfig\n      br-int    Link encap:Ethernet  HWaddr 1a:09:56:ea:0b:49  \n      inet6 addr: fe80::1809:56ff:feea:b49/64 Scope:Link\n      UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n      RX packets:1584 errors:0 dropped:0 overruns:0 frame:0\n      TX packets:6 errors:0 dropped:0 overruns:0 carrier:0\n      collisions:0 txqueuelen:0 \n      RX bytes:316502 (316.5 KB)  TX bytes:468 (468.0 B)\n</code></pre>\n\n<p>当我们创建了一个交换机（网桥）以后，此时网络功能不受影响，但是会产生一个虚拟网卡，名字就是brname，之所以会产生一个虚拟网卡，是为了实现接下来的网桥（交换机）功能。有了这个交换机以后，我还需要为这个交换机增加端口(port)，一个端口，就是一个物理网卡，当网卡加入到这个交换机之后，其工作方式就和普通交换机的一个端口的工作方式类似了。</p>\n\n<pre><code>ovs-vsctl add-port brname port\n</code></pre>\n\n<p><strong>这里要特别注意，网卡加入网桥以后，要按照网桥的工作标准工作，那么加入的一个端口就必须是以混杂模式工作，工作在链路层，处理2层的帧，所以这个port就不需要配置IP了。（你没见过哪个交换的端口有IP的吧）</strong></p>\n\n<p>那么接下来你可能会问，通常的交换机不都是有一个管理接口，可以telnet到交换机上进行配置吧，那么在OVS中创建的虚拟交换机有木有这种呢，有的！上面既然创建交换机brname的时候产生了一个虚拟网口brname,那么，你给这个虚拟网卡配置了IP以后，就相当于给交换机的管理接口配置了IP，此时一个正常的虚拟交换机就搞定了。</p>\n\n<pre><code>ip address add 192.168.1.1/24 dev brname\n</code></pre>\n\n<p>最后，我们来看看一个br的具体信息：</p>\n\n<pre><code>root@Compute2:~# ovs-vsctl show\nbc12c8d2-6900-42dd-9c1c-30e8ecb99a1b\nBridge \"br0\"\n    Port \"eth0\"\n        Interface \"eth0\"\n    Port \"br0\"\n        Interface \"br0\"\n            type: internal\novs_version: \"1.4.0+build0\"\n</code></pre>\n\n<p>首先，这里显示了一个名为br0的桥（交换机），这个交换机有两个接口,一个是eth0，一个是br0，上面说到，创建桥的时候会创建一个和桥名字一样的接口，并自动作为该桥的一个端口，那么这个虚拟接口的作用，一方面是可以作为交换机的管理端口，另一方面也是基于这个虚拟接口，实现了桥的功能。</p>\n\n<h2>3 参考资料：</h2>\n\n<p><a href=\"http://openvswitch.org/cgi-bin/gitweb.cgi?p=openvswitch;a=blob_plain;f=FAQ;hb=HEAD\">http://openvswitch.org/cgi-bin/gitweb.cgi?p=openvswitch;a=blob_plain;f=FAQ;hb=HEAD</a></p>\n','OpenvSwitch完全使用手册(二)-概念及工作流程1','','inherit','open','open','','201-revision-4','','','2013-03-25 16:41:45','2013-03-25 08:41:45','','201','http://blog.wachang.net/2013/03/201-revision-4/','0','revision','','0');");
E_D("replace into `wp_posts` values('213','1','2013-03-25 00:34:02','2013-03-24 16:34:02','<p>本系列文章索引：</p>\n\n<p>1.<a href=\"http://blog.wachang.net/2013/03/openvswitch-fullbook-1-overview\">OpenvSwitch完全使用手册(一)-总览Overview</a></p>\n\n<p>2.<a href=\"\">OpenvSwitch完全使用手册(二)-概念及工作流程</a></p>\n\n<p>本文主要参考<a href=\"http://openvswitch.org/cgi-bin/gitweb.cgi?p=openvswitch;a=blob_plain;f=README;hb=HEAD\">Overview of functionality and components</a>以及<a href=\"http://openvswitch.org/cgi-bin/gitweb.cgi?p=openvswitch;a=blob_plain;f=FAQ;hb=HEAD\">Frequently Asked Questions</a>以及结合自己的理解。</p>\n\n<h2>1 什么是OpenvSwitch</h2>\n\n<p>OpenvSwitch，简称OVS是一个虚拟交换软件，主要用于虚拟机VM环境，作为一个虚拟交换机，支持Xen/XenServer, KVM, and VirtualBox多种虚拟化技术。</p>\n\n<p>在这种某一台机器的虚拟化的环境中，一个虚拟交换机（vswitch）主要有两个作用：传递虚拟机VM之间的流量，以及实现VM和外界网络的通信。</p>\n\n<p>整个OVS代码用C写的。目前有以下功能：</p>\n\n<ul>\n<li>Standard 802.1Q VLAN model with trunk and access ports</li>\n<li>NIC bonding with or without LACP on upstream switch</li>\n<li>NetFlow, sFlow(R), and mirroring for increased visibility</li>\n<li>QoS (Quality of Service) configuration, plus policing</li>\n<li>GRE, GRE over IPSEC, VXLAN, and LISP tunneling</li>\n<li>802.1ag connectivity fault management</li>\n<li>OpenFlow 1.0 plus numerous extensions</li>\n<li>Transactional configuration database with C and Python bindings</li>\n<li>High-performance forwarding using a Linux kernel module</li>\n</ul>\n\n<!--more-->\n\n<h2>2 OpenvSwitch的组成</h2>\n\n<ul>\n<li>ovs-vswitchd：守护程序，实现交换功能，和Linux内核兼容模块一起，实现基于流的交换flow-based switching。</li>\n<li>ovsdb-server：轻量级的数据库服务，主要保存了整个OVS的配置信息，包括接口啊，交换内容，VLAN啊等等。ovs-vswitchd会根据数据库中的配置信息工作。</li>\n<li>ovs-dpctl：一个工具，用来配置交换机内核模块，可以控制转发规则。</li>\n<li>ovs-vsctl：主要是获取或者更改ovs-vswitchd的配置信息，此工具操作的时候会更新ovsdb-server中的数据库。</li>\n<li>ovs-appctl：主要是向OVS守护进程发送命令的，一般用不上。</li>\n<li>ovsdbmonitor：GUI工具来显示ovsdb-server中数据信息。</li>\n<li>ovs-controller：一个简单的OpenFlow控制器</li>\n<li>ovs-ofctl：用来控制OVS作为OpenFlow交换机工作时候的流表内容。</li>\n</ul>\n\n<h2>3 OpenvSwitch和其他vswitch</h2>\n\n<p>这里其他的vswitch,包括VMware vNetwork distributed switch以及思科的Cisco Nexus 1000V。</p>\n\n<p>VMware vNetwork distributed switch以及思科的Cisco Nexus 1000V这种虚拟交换机提供的是一个集中式的控制方式，。而OVS则是一个独立的vswitch，他运行在每个实现虚拟化的物理机器上，并提供远程管理。OVS提供了两种在虚拟化环境中远程管理的协议：一个是OpenFlow,通过流表来管理交换机的行为，一个是OVSDB management protocol，用来暴露sietch的port状态。</p>\n','OpenvSwitch完全使用手册(一)-总览Overview','','inherit','open','open','','198-revision-3','','','2013-03-25 00:34:02','2013-03-24 16:34:02','','198','http://blog.wachang.net/2013/03/198-revision-3/','0','revision','','0');");
E_D("replace into `wp_posts` values('215','1','2013-03-25 16:51:25','2013-03-25 08:51:25','<h2>1 vswitch、Bridge、Datapath</h2>\n\n<p>在网络中，交换机和桥都是同一个概念，OVS实现了一个虚拟机的以太交换机，换句话说，OVS也就是实现了一个以太桥。那么，在OVS中，给一个交换机，或者说一个桥，用了一个专业的名词，叫做DataPath！</p>\n\n<p>要了解，OVS如何工作，首先需要知道桥的概念。</p>\n\n<p>网桥也叫做桥接器，连接两个局域网的设备，网桥工作在数据链路层，将两个LAN连接，根据MAC地址来转发帧，可以看成一个“低层的路由器”（路由器工作在网络层，根据IP地质进行转发）。</p>\n\n<!--more-->\n\n<h3>1.1 网桥的工作原理</h3>\n\n<p>网桥处理包遵循以下几条规则：</p>\n\n<ul>\n<li>在一个接口上接收到的包不会再往那个接口上发送此包。</li>\n<li>每个接收到的包都要学习其源MAC地址。</li>\n<li>如果数据包是多播或者广播包（通过2层MAC地址确定）则要向接收端口以外的所有端口转发，如果上层协议感兴趣，则还会递交上层处理。</li>\n<li>如果数据包的地址不能再CAM表中找到，则向接收端口以外的其他端口转发。</li>\n<li>如果CAM表中能找到，则转发给相应端口，如果发送和接收都是统一端口，则不发送。</li>\n</ul>\n\n<p>注意，网桥是以<code>混杂模式工作</code>的。关于网桥更多，请查阅相关资料。</p>\n\n<h2>2 OVS中的bridge</h2>\n\n<p>上面，说到，一个桥就是一个交换机。在OVS中，</p>\n\n<pre><code>ovs-vsctl add-br brname(br-int)\n\nroot@Compute2:~# ifconfig\n      br-int    Link encap:Ethernet  HWaddr 1a:09:56:ea:0b:49  \n      inet6 addr: fe80::1809:56ff:feea:b49/64 Scope:Link\n      UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n      RX packets:1584 errors:0 dropped:0 overruns:0 frame:0\n      TX packets:6 errors:0 dropped:0 overruns:0 carrier:0\n      collisions:0 txqueuelen:0 \n      RX bytes:316502 (316.5 KB)  TX bytes:468 (468.0 B)\n</code></pre>\n\n<p>当我们创建了一个交换机（网桥）以后，此时网络功能不受影响，但是会产生一个虚拟网卡，名字就是brname，之所以会产生一个虚拟网卡，是为了实现接下来的网桥（交换机）功能。有了这个交换机以后，我还需要为这个交换机增加端口(port)，一个端口，就是一个物理网卡，当网卡加入到这个交换机之后，其工作方式就和普通交换机的一个端口的工作方式类似了。</p>\n\n<pre><code>ovs-vsctl add-port brname port\n</code></pre>\n\n<p><strong>这里要特别注意，网卡加入网桥以后，要按照网桥的工作标准工作，那么加入的一个端口就必须是以混杂模式工作，工作在链路层，处理2层的帧，所以这个port就不需要配置IP了。（你没见过哪个交换的端口有IP的吧）</strong></p>\n\n<p>那么接下来你可能会问，通常的交换机不都是有一个管理接口，可以telnet到交换机上进行配置吧，那么在OVS中创建的虚拟交换机有木有这种呢，有的！上面既然创建交换机brname的时候产生了一个虚拟网口brname,那么，你给这个虚拟网卡配置了IP以后，就相当于给交换机的管理接口配置了IP，此时一个正常的虚拟交换机就搞定了。</p>\n\n<pre><code>ip address add 192.168.1.1/24 dev brname\n</code></pre>\n\n<p>最后，我们来看看一个br的具体信息：</p>\n\n<pre><code>root@Compute2:~# ovs-vsctl show\nbc12c8d2-6900-42dd-9c1c-30e8ecb99a1b\nBridge \"br0\"\n    Port \"eth0\"\n        Interface \"eth0\"\n    Port \"br0\"\n        Interface \"br0\"\n            type: internal\novs_version: \"1.4.0+build0\"\n</code></pre>\n\n<p>首先，这里显示了一个名为br0的桥（交换机），这个交换机有两个接口,一个是eth0，一个是br0，上面说到，创建桥的时候会创建一个和桥名字一样的接口，并自动作为该桥的一个端口，那么这个虚拟接口的作用，一方面是可以作为交换机的管理端口，另一方面也是基于这个虚拟接口，实现了桥的功能。</p>\n\n<h2>3 参考资料：</h2>\n\n<p><a href=\"http://openvswitch.org/cgi-bin/gitweb.cgi?p=openvswitch;a=blob_plain;f=FAQ;hb=HEAD\">http://openvswitch.org/cgi-bin/gitweb.cgi?p=openvswitch;a=blob_plain;f=FAQ;hb=HEAD</a></p>\n','OpenvSwitch完全使用手册(二)-概念及工作流程1','','inherit','open','open','','201-revision-5','','','2013-03-25 16:51:25','2013-03-25 08:51:25','','201','http://blog.wachang.net/2013/03/201-revision-5/','0','revision','','0');");
E_D("replace into `wp_posts` values('216','1','2013-03-25 16:52:10','2013-03-25 08:52:10','<p>本文主要参考<a href=\"http://openvswitch.org/cgi-bin/gitweb.cgi?p=openvswitch;a=blob_plain;f=README;hb=HEAD\">Overview of functionality and components</a>以及<a href=\"http://openvswitch.org/cgi-bin/gitweb.cgi?p=openvswitch;a=blob_plain;f=FAQ;hb=HEAD\">Frequently Asked Questions</a>以及结合自己的理解。</p>\n\n<h2>1 什么是OpenvSwitch</h2>\n\n<p>OpenvSwitch，简称OVS是一个虚拟交换软件，主要用于虚拟机VM环境，作为一个虚拟交换机，支持Xen/XenServer, KVM, and VirtualBox多种虚拟化技术。</p>\n\n<p>在这种某一台机器的虚拟化的环境中，一个虚拟交换机（vswitch）主要有两个作用：传递虚拟机VM之间的流量，以及实现VM和外界网络的通信。</p>\n\n<p>整个OVS代码用C写的。目前有以下功能：</p>\n\n<ul>\n<li>Standard 802.1Q VLAN model with trunk and access ports</li>\n<li>NIC bonding with or without LACP on upstream switch</li>\n<li>NetFlow, sFlow(R), and mirroring for increased visibility</li>\n<li>QoS (Quality of Service) configuration, plus policing</li>\n<li>GRE, GRE over IPSEC, VXLAN, and LISP tunneling</li>\n<li>802.1ag connectivity fault management</li>\n<li>OpenFlow 1.0 plus numerous extensions</li>\n<li>Transactional configuration database with C and Python bindings</li>\n<li>High-performance forwarding using a Linux kernel module</li>\n</ul>\n\n<!--more-->\n\n<h2>2 OpenvSwitch的组成</h2>\n\n<ul>\n<li>ovs-vswitchd：守护程序，实现交换功能，和Linux内核兼容模块一起，实现基于流的交换flow-based switching。</li>\n<li>ovsdb-server：轻量级的数据库服务，主要保存了整个OVS的配置信息，包括接口啊，交换内容，VLAN啊等等。ovs-vswitchd会根据数据库中的配置信息工作。</li>\n<li>ovs-dpctl：一个工具，用来配置交换机内核模块，可以控制转发规则。</li>\n<li>ovs-vsctl：主要是获取或者更改ovs-vswitchd的配置信息，此工具操作的时候会更新ovsdb-server中的数据库。</li>\n<li>ovs-appctl：主要是向OVS守护进程发送命令的，一般用不上。</li>\n<li>ovsdbmonitor：GUI工具来显示ovsdb-server中数据信息。</li>\n<li>ovs-controller：一个简单的OpenFlow控制器</li>\n<li>ovs-ofctl：用来控制OVS作为OpenFlow交换机工作时候的流表内容。</li>\n</ul>\n\n<h2>3 OpenvSwitch和其他vswitch</h2>\n\n<p>这里其他的vswitch,包括VMware vNetwork distributed switch以及思科的Cisco Nexus 1000V。</p>\n\n<p>VMware vNetwork distributed switch以及思科的Cisco Nexus 1000V这种虚拟交换机提供的是一个集中式的控制方式，。而OVS则是一个独立的vswitch，他运行在每个实现虚拟化的物理机器上，并提供远程管理。OVS提供了两种在虚拟化环境中远程管理的协议：一个是OpenFlow,通过流表来管理交换机的行为，一个是OVSDB management protocol，用来暴露sietch的port状态。</p>\n','OpenvSwitch完全使用手册(一)-总览Overview','','inherit','open','open','','198-revision-4','','','2013-03-25 16:52:10','2013-03-25 08:52:10','','198','http://blog.wachang.net/2013/03/198-revision-4/','0','revision','','0');");
E_D("replace into `wp_posts` values('217','1','2013-03-25 18:58:09','2013-03-25 10:58:09','','vm-ovs-workflow','','inherit','open','open','','vm-ovs-workflow','','','2013-03-25 18:58:09','2013-03-25 10:58:09','','205','http://blog.wachang.net/wp-content/uploads/2013/03/vm-ovs-workflow.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('218','1','2013-03-25 18:58:33','2013-03-25 10:58:33','<blockquote>\n  <p>OpenvSwitch完全使用手册(二)-概念及工作流程2</p>\n  \n  <p>这一部分我以一个简单的例子，说明在虚拟化环境中OpenvSwitch的典型工作流程。</p>\n</blockquote>\n\n<p>前面已经说到，OVS主要是用来在虚拟化环境中。虚拟机之间一个虚拟机和外网之间的通信所用，如下是一个典型的结构图：</p>\n\n<p>那么，通常情况下的工作流程如下：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/vm-ovs-workflow.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/vm-ovs-workflow.png\" alt=\"vm-ovs-workflow\" width=\"752\" height=\"416\" class=\"aligncenter size-full wp-image-217\" /></a></p>\n\n<ul>\n<li>1 VM实例instance产生一个数据包并发送至实例内的虚拟网络接口VNIC，图中就是instance中的eth0.</li>\n<li>2 这个数据包会传送到物理节点上的VNIC接口，如图就是vnet接口。</li>\n<li>3 数据包从vnet NIC出来，到达桥（虚拟交换机）br100上.</li>\n<li>4 数据包经过交换机的处理，从物理节点上的物理接口发出，如图中物理节点上的eth0.</li>\n<li>5 数据包从eth0出去的时候，是按照物理节点上的路由以及默认网关操作的，这个时候该数据包其实已经不受你的控制了。</li>\n</ul>\n','OpenvSwitch完全使用手册(二)-概念及工作流程2','','inherit','open','open','','205-revision','','','2013-03-25 18:58:33','2013-03-25 10:58:33','','205','http://blog.wachang.net/2013/03/205-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('219','1','2013-03-25 18:59:02','2013-03-25 10:59:02','<blockquote>\n  <p>OpenvSwitch完全使用手册(二)-概念及工作流程2</p>\n  \n  <p>这一部分我以一个简单的例子，说明在虚拟化环境中OpenvSwitch的典型工作流程。</p>\n</blockquote>\n\n<p>前面已经说到，OVS主要是用来在虚拟化环境中。虚拟机之间一个虚拟机和外网之间的通信所用，如下是一个典型的结构图：</p>\n\n<p>那么，通常情况下的工作流程如下：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/vm-ovs-workflow.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/vm-ovs-workflow.png\" alt=\"vm-ovs-workflow\" width=\"752\" height=\"416\" class=\"aligncenter size-full wp-image-217\" /></a></p>\n\n<ul>\n<li>1 VM实例instance产生一个数据包并发送至实例内的虚拟网络接口VNIC，图中就是instance中的eth0.</li>\n<li>2 这个数据包会传送到物理节点上的VNIC接口，如图就是vnet接口。</li>\n<li>3 数据包从vnet NIC出来，到达桥（虚拟交换机）br100上.</li>\n<li>4 数据包经过交换机的处理，从物理节点上的物理接口发出，如图中物理节点上的eth0.</li>\n<li>5 数据包从eth0出去的时候，是按照物理节点上的路由以及默认网关操作的，这个时候该数据包其实已经不受你的控制了。</li>\n</ul>\n','OpenvSwitch完全使用手册(二)-概念及工作流程2','','inherit','open','open','','205-revision-2','','','2013-03-25 18:59:02','2013-03-25 10:59:02','','205','http://blog.wachang.net/2013/03/205-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('220','1','2013-03-25 16:47:37','2013-03-25 08:47:37','<a title=\"OpenvSwitch完全使用手册(一)-总览Overview\" href=\"http://blog.wachang.net/2013/03/openvswitch-fullbook-1-overview/\" target=\"_blank\">OpenvSwitch完全使用手册(一)-总览Overview</a>\r\n\r\n<a title=\"OpenvSwitch完全使用手册(二)-概念及工作流程1\" href=\"http://blog.wachang.net/2013/03/openvswitch-fullbook-2-workflow-1/\" target=\"_blank\">OpenvSwitch完全使用手册(二)-概念及工作流程1</a>','OpenvSwitch完全使用手册','','inherit','open','open','','206-revision-2','','','2013-03-25 16:47:37','2013-03-25 08:47:37','','206','http://blog.wachang.net/2013/03/206-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('221','1','2013-03-25 19:08:21','2013-03-25 11:08:21','<a title=\"OpenvSwitch完全使用手册(一)-总览Overview\" href=\"http://blog.wachang.net/2013/03/openvswitch-fullbook-1-overview/\" target=\"_blank\">OpenvSwitch完全使用手册(一)-总览Overview</a>\n\n<a title=\"OpenvSwitch完全使用手册(二)-概念及工作流程1\" href=\"http://blog.wachang.net/2013/03/openvswitch-fullbook-2-workflow-1/\" target=\"_blank\">OpenvSwitch完全使用手册(二)-概念及工作流程1</a>\n\n<a href=\"http://blog.wachang.net/2013/03/openvswitch-fullbook-2-workflow-2/\">OpenvSwitch完全使用手册(二)-概念及工作流程2</a>\n\nOpenvSwitch完全使用手册(三)-基本安装和使用\n\nOpenvSwitch完全使用手册(四)-OVS的数据库\n\nOpenvSwitch完全使用手册()-OpenFlow\n\nOpenvSwitch完全使用手册()-VLAN\n\nOpenvSwitch完全使用手册()-sFlow\n\nOpenvSwitch完全使用手册()-GRE\n\nOpenvSwitch完全使用手册()-VXLAN\n\nOpenvSwitch完全使用手册()-...','OpenvSwitch完全使用手册','','inherit','open','open','','206-autosave','','','2013-03-25 19:08:21','2013-03-25 11:08:21','','206','http://blog.wachang.net/2013/03/206-autosave/','0','revision','','0');");
E_D("replace into `wp_posts` values('222','1','2013-03-25 19:00:38','2013-03-25 11:00:38','<a title=\"OpenvSwitch完全使用手册(一)-总览Overview\" href=\"http://blog.wachang.net/2013/03/openvswitch-fullbook-1-overview/\" target=\"_blank\">OpenvSwitch完全使用手册(一)-总览Overview</a>\r\n\r\n<a title=\"OpenvSwitch完全使用手册(二)-概念及工作流程1\" href=\"http://blog.wachang.net/2013/03/openvswitch-fullbook-2-workflow-1/\" target=\"_blank\">OpenvSwitch完全使用手册(二)-概念及工作流程1</a>\r\n\r\n<a href=\"http://blog.wachang.net/2013/03/openvswitch-fullbook-2-workflow-2/\">OpenvSwitch完全使用手册(二)-概念及工作流程2</a>','OpenvSwitch完全使用手册','','inherit','open','open','','206-revision-3','','','2013-03-25 19:00:38','2013-03-25 11:00:38','','206','http://blog.wachang.net/2013/03/206-revision-3/','0','revision','','0');");
E_D("replace into `wp_posts` values('223','1','2013-03-25 21:55:53','0000-00-00 00:00:00','<p>之前说到，OVS有一个数据库，主要是用于ovs-vswitchd这个进程读取配置，然后控制行为。\n大多数的OVSDB中的Table都有两个列项other_config和external_ids,\nother_config:字符串形式的键值对，主要保存一些不常用的信息。\nexternal_ids：字符串形式的键值对，主要用于保存一些和OVS集成的架构的信息。\n在OVSDB中，主要有以下表项Table:</p>\n\n<pre><code>表项Table    |         描述\n--------------------------------------------------\nOpen_vSwitch | 保存Open vSwitch 基本配置\nBridge       | 保存Bridge的基本配置\nPort         | 保存所有Port的信息\nInterface    | 保存一个port所对应的实际物理网络设备的信息\nFlow_Table   | OpenFlow流表信息\nQoS          | QoS配置信息\nQueue        | QoS输出队列信息\nMirror       | 保存Port mirroring镜像信息\nController   | OpenFlow controller配置信息\nManager      | OVSDB management connection.管理连接信息\nNetFlow      | NetFlow相应配置\nSSL          | SSL配置信息\nsFlow        | sFlow配置\n</code></pre>\n\n<p>下图是各个表之间的关系：其中，每个节点表示一张表，粗剪头表示很有很强的引用关系，每个剪头上面的英文，表示的是当前表中的某一列项的名字，（对于的是哪一张表），后面的符号？表示0个或者1个，*表示0个或者多个，+表示一个或者多个（至少一个）。</p>\n','OpenvSwitch完全使用手册(四)-OVS的数据库','','draft','open','open','','','','','2013-03-25 21:55:53','2013-03-25 13:55:53','','0','http://blog.wachang.net/?p=223','0','post','','0');");
E_D("replace into `wp_posts` values('224','1','2013-03-25 21:55:26','2013-03-25 13:55:26','<p>之前说到，OVS有一个数据库，主要是用于ovs-vswitchd这个进程读取配置，然后控制行为。\n大多数的OVSDB中的Table都有两个列项other_config和external_ids,\nother_config:字符串形式的键值对，主要保存一些不常用的信息。\nexternal_ids：字符串形式的键值对，主要用于保存一些和OVS集成的架构的信息。\n在OVSDB中，主要有以下表项Table:</p>\n\n<pre><code>表项Table    |         描述\n--------------------------------------------------\nOpen_vSwitch | 保存Open vSwitch 基本配置\nBridge       | 保存Bridge的基本配置\nPort         | 保存所有Port的信息\nInterface    | 保存一个port所对应的实际物理网络设备的信息\nFlow_Table   | OpenFlow流表信息\nQoS          | QoS配置信息\nQueue        | QoS输出队列信息\nMirror       | 保存Port mirroring镜像信息\nController   | OpenFlow controller配置信息\nManager      | OVSDB management connection.管理连接信息\nNetFlow      | NetFlow相应配置\nSSL          | SSL配置信息\nsFlow        | sFlow配置\n</code></pre>\n\n<p>下图是各个表之间的关系：其中，每个节点表示一张表，粗剪头表示很有很强的引用关系，每个剪头上面的英文，表示的是当前表中的某一列项的名字，（对于的是哪一张表），后面的符号？表示0个或者1个，*表示0个或者多个，+表示一个或者多个（至少一个）。</p>\n','OpenvSwitch完全使用手册(四)-OVS的数据库','','inherit','open','open','','223-revision','','','2013-03-25 21:55:26','2013-03-25 13:55:26','','223','http://blog.wachang.net/2013/03/223-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('225','1','2013-03-26 20:58:02','2013-03-26 12:58:02','<blockquote>\n  <p>浅出OpenStack源码系列</p>\n  \n  <p>Quantum OpenvSwitch Plugin源码分析</p>\n  \n  <p>Plugin和Agent的RPC机制（一）</p>\n  \n  <p>基于2013、03月的Quantum源代码，主要是Folsom版本。</p>\n</blockquote>\n\n<p>这一节主要讲讲OVS Plugin和OVS agent之间如何进行交互，也就是RPC机制的过程。</p>\n\n<p>首先，需要了解一点RPC的知识，主要是AMQP协议，这方面可以网上找一点文章看看。</p>\n\n<h2>1.Plugin/Agent的RPC交互背景</h2>\n\n<p>如果我下文中有一些术语如果不明白，那就需要先补充AMQP和RabbitMQ的知识了。</p>\n\n<p>在Quantum Plugin的OpenvSwitch插件中，有一些操作需要Agent端通过执行<code>ovs-vsctl</code>来完成，这些操作包括：</p>\n\n<ul>\n<li>port-update：更新一个port的信息</li>\n<li>network-delete:删除网络，那么就需要删除网络上所有的port信息</li>\n<li>tunnel:在GRE模式中，有时候需要更新GRE port的信息</li>\n</ul>\n\n<p>而Plugin的作用就是告诉Agent应该做什么，他们是通过RPC机制来通信，简单来说，就是:`Plugin把一个具体操作发送到RabbitMQ的消息队列中，Agent从里面读取消息，并执行，当结果需要通知Plugin的时候，又向PLugin发送一个RPC消息，Plugin此时就主要是更改数据库相应的信息。</p>\n\n<!--more-->\n\n<p>同时，Agent还有一个作用，就是通过RPC通告plugin自己是否存活。也会把自己的设备信息发送给Plugin，或者告诉Plugin：本Agent已死，请在数据库删除我的信息吧，有事烧纸~</p>\n\n<h2>2.Plugin/Agent的RPC交互结构</h2>\n\n<p>以下会涉及到消息队列的知识，请一定先学习相关知识。</p>\n\n<p>我们暂时不考虑L3-agent这种，就简单的学习OVS PLUGIN和AGENT的交互。</p>\n\n<p>首先Plugin和Agent有两条RPC通道，注意，我说的逻辑上的哈：</p>\n\n<p>通道1：Plugin向Agent发送port-update,network-delete,tunnel-update的消息，在消息队列上使用的Exchange分别名为：q-agent-notifier-network-delete&#95;fanout，q-agent-notifier-port-update&#95;fanout，q-agent-notifier-tunnel-update_fanout，交换类型fanout.</p>\n\n<p>在通道1上，又来继续，因为OpenStack中有多个OVS AGENT，每个Agent会有一个ID，并且，每个AGENT在每个Exchange上都有一条消息队列。队列名字为：q-agent-notifier-tunnel-update&#95;fanout&#95;995ad5d516d1430fa7f8535337ed5b24这种，简单点说，就是一个Agent在通道1的过程中，会有3个相应的名字中包含自己ID号的队列与三个Exchange进行绑定。</p>\n\n<p>通道2：Agent向Plugin发送通道1的结果或者自身的一个心跳信息（主要是设备打开关闭，设备info）等信息，在消息队列上Exchange名为：openstack，交换类型topic交换。</p>\n\n<p>在OpenStack中，Quantum Server节点只有一个，加之这个交换机是topic交换，所以Plugin端与交换机openstack就只有一个队列，名字为：q-plugin</p>\n\n<p>说白了，就是说Plugin-->Agent使用的Exchange是q-agent-notifier-&#42;**||||，Agent-->Plugin使用的Exchange是openstack。</p>\n\n<p>下面是Quantum官方资料的一个图，我只截取相关部分，你应该能看懂了！暂时我们只学习我圈红的部分。</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互1-1024x707.png\" alt=\"PluginAgent的交互1\" width=\"640\" height=\"441\" class=\"aligncenter size-large wp-image-228\" /></a></p>\n\n<p>我对这个图进行了一些补充，如下是两个OVS AGENT的情况！</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互2.png\" alt=\"PluginAgent的交互2\" width=\"570\" height=\"621\" class=\"aligncenter size-full wp-image-229\" /></a></p>\n\n<h2>3.源码概念理解</h2>\n\n<p>首先，再次强调，虽然OpenvSwitch Plugin单Plugin+多agent形式的，但是在实际中，Plugin会主动向Agent发送消息（更改port删除network，tunnel_update等等），Agent也会主动向Plugin发送信息（比如在新计算节点加入的时候需要报告OVS信息，以及OVS有改动后要通知Plugin更改数据库等），所以从消息队列的方向来说，Plugin和Agent既是生产者，也是消费者。在源代码中，会有这么几个概念：</p>\n\n<ul>\n<li>manager：其实就是指Plugin或者Agent的实例。</li>\n<li>dispatcher:在RPC中，当接收消息以后，需要定义一个函数来处理，这成为回调callback，dispatcher就是做这么一个调度工作,一个到达的消息可以被调度（dispatch）到一个函数或者一个类中。</li>\n<li>create_consumer：用于向AMQP服务器指明接收哪个队列的消息，这个函数需要dispatcher作为参数（很明显，接收到消息以后就交给调度器处理嘛）</li>\n<li>在Plugin的代码中：<code>Class AgentNotifierApi</code>这个类用于向Agent发送RPC消息</li>\n<li>在Plugin的代码中:<code>Class OVSRpcCallbacks</code>作为Plugin接收RPC消息的目标，见上面dispatcher的描述。</li>\n<li>在Agent代码中：<code>Class OVSPluginApi</code>这个类用于向Plugin发送RPC消息</li>\n</ul>\n\n<p>下面再给出源代码中各个组件的一个流程图,对于Plugin和Agent端都是通用的，下一节中会从源码上分析本节内容！</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/RPC源码流程.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/RPC源码流程.jpg\" alt=\"RPC源码流程\" width=\"855\" height=\"400\" class=\"aligncenter size-full wp-image-235\" /></a></p>\n','Quantum OpenvSwitch Plugin和Agent的RPC机制（一）','','publish','open','open','','quantum-ovs-plugin-agent-rpc-1','','','2013-03-26 21:54:07','2013-03-26 13:54:07','','0','http://blog.wachang.net/?p=225','0','post','','0');");
E_D("replace into `wp_posts` values('226','1','2013-03-26 13:02:48','2013-03-26 05:02:48','','rpcproxy','','inherit','open','open','','rpcproxy','','','2013-03-26 13:02:48','2013-03-26 05:02:48','','225','http://blog.wachang.net/wp-content/uploads/2013/03/rpcproxy.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('227','1','2013-03-26 13:38:30','2013-03-26 05:38:30','<blockquote>\n  <p>浅出OpenStack源码系列</p>\n  \n  <p>Quantum OpenvSwitch Plugin源码分析</p>\n  \n  <p>Plugin和Agent的RPC机制（一）</p>\n  \n  <p>基于2013、03月的Quantum源代码，主要是Folsom版本。</p>\n</blockquote>\n\n<p>这一节主要讲讲OVS Plugin和OVS agent之间如何进行交互，也就是RPC机制的过程。</p>\n\n<p>首先，需要了解一点RPC的知识，主要是AMQP协议，这方面可以网上找一点文章看看。</p>\n\n<h2>一点背景</h2>\n\n<p>在OVS plugin插件中，只有几个操作实际上是需要Agent来具体执行的：</p>\n\n<ul>\n<li>port-update：更新一个port的信息</li>\n<li>network-delete:删除网络，那么就需要删除网络上所有的port信息</li>\n<li>tunnel:在GRE模式中，有时候需要更新GRE port的信息</li>\n</ul>\n\n<h2>1.类RpcProcy:产生和发出消息</h2>\n\n<p>首先，rpc机制主要是就是传递消息，那么Plugin和agent之间的消息格式是怎样的呢？又是如何产生的呢？\n在quantum.openstack.common.rpc.proxy中有一个类RpcProxy就是用来发送消息的。从目录结构来看这是一个通用的类，也就是说NOVA等组件有关RPC也是通过这个类来进行消息的发送。</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/rpcproxy.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/rpcproxy.png\" alt=\"rpcproxy\" width=\"210\" height=\"324\" class=\"aligncenter size-full wp-image-226\" /></a></p>\n\n<p>这个类的make_msg方法定义了RPC中消息的类型：</p>\n\n<pre><code>@staticmethod\ndef make_msg(method, **kwargs):\n    return {''method'': method, ''args'': kwargs}\n</code></pre>\n\n<p>如上，RPC机制中，一个消息就是一个字典，举个例子来说，某一个关于port-update的消息就可能是这样：</p>\n\n<pre><code>{''method'': port_update, ''args'': 关于要更新的port的一些信息}\n</code></pre>\n\n<p>OK，知道消息是怎么样的了，接下来就是消息是如何发送了，同样也是在这个类中的四个方法：</p>\n\n<pre><code>def call(self, context, msg, topic=None, version=None, timeout=None)：必须等待远程调用以后的返回\ndef multicall(self, context, msg, topic=None, version=None, timeout=None)：必须等待多个远程调用以后的返回，此时返回一个迭代器，你可以迭代取值\ndef cast(self, context, msg, topic=None, version=None)：单播\ndef fanout_cast(self, context, msg, topic=None, version=None)：fanout\ndef cast_to_server(self, context, server_params, msg, topic=None,version=None)\ndef fanout_cast_to_server(self, context, server_params, msg, topic=None,version=None)\n</code></pre>\n\n<p>上面四种消息投递方式具体请参见AMQP或者RabbitMQ的文档，那么在OVS Plugin中，采用的是<code>fanout_cast</code>的方式发送消息。以上几种方法的具体实现，是在quantum.openstack.common.rpc.<strong>init</strong>.py中，简单列举一下fanout_cast的实现：</p>\n\n<p>def fanout_cast(context, topic, msg):\n        return _get_impl().fanout_cast(CONF, context, topic, msg)</p>\n\n<h2>2.类RpcDispatcher：接收消息和处理</h2>\n\n<p>quantum.openstack.common.rpc.dispatcher.py中，定义了最基本的Dispatcher类。所谓Dispatcher，当AMQP中的消费者读取的相应的消息以后，通过dispatcher的调度，调用相应的函数执行操作。我们首先来看Plugin端的调度器：</p>\n','Quantum OpenvSwitch Plugin和Agent的RPC机制（一）','','inherit','open','open','','225-revision','','','2013-03-26 13:38:30','2013-03-26 05:38:30','','225','http://blog.wachang.net/2013/03/225-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('228','1','2013-03-26 16:53:14','2013-03-26 08:53:14','','PluginAgent的交互1','','inherit','open','open','','pluginagent%e7%9a%84%e4%ba%a4%e4%ba%921','','','2013-03-26 16:53:14','2013-03-26 08:53:14','','225','http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互1.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('229','1','2013-03-26 16:59:46','2013-03-26 08:59:46','','PluginAgent的交互2','','inherit','open','open','','pluginagent%e7%9a%84%e4%ba%a4%e4%ba%922','','','2013-03-26 16:59:46','2013-03-26 08:59:46','','225','http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互2.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('230','1','2013-03-26 17:06:04','2013-03-26 09:06:04','<blockquote>\n  <p>浅出OpenStack源码系列</p>\n  \n  <p>Quantum OpenvSwitch Plugin源码分析</p>\n  \n  <p>Plugin和Agent的RPC机制（一）</p>\n  \n  <p>基于2013、03月的Quantum源代码，主要是Folsom版本。</p>\n</blockquote>\n\n<p>这一节主要讲讲OVS Plugin和OVS agent之间如何进行交互，也就是RPC机制的过程。</p>\n\n<p>首先，需要了解一点RPC的知识，主要是AMQP协议，这方面可以网上找一点文章看看。</p>\n\n<h2>1.Plugin/Agent的RPC交互背景</h2>\n\n<p>如果我下文中有一些术语如果不明白，那就需要先补充AMQP和RabbitMQ的知识了。</p>\n\n<p>在Quantum Plugin的OpenvSwitch插件中，有一些操作需要Agent端通过执行<code>ovs-vsctl</code>来完成，这些操作包括：</p>\n\n<ul>\n<li>port-update：更新一个port的信息</li>\n<li>network-delete:删除网络，那么就需要删除网络上所有的port信息</li>\n<li>tunnel:在GRE模式中，有时候需要更新GRE port的信息</li>\n</ul>\n\n<p>而Plugin的作用就是告诉Agent应该做什么，他们是通过RPC机制来通信，简单来说，就是:`Plugin把一个具体操作发送到RabbitMQ的消息队列中，Agent从里面读取消息，并执行，当结果需要通知Plugin的时候，又向PLugin发送一个RPC消息，Plugin此时就主要是更改数据库相应的信息。</p>\n\n<p>同时，Agent还有一个作用，就是通过RPC通告plugin自己是否存活。也会把自己的设备信息发送给Plugin，或者告诉Plugin：本Agent已死，请在数据库删除我的信息吧，有事烧纸~</p>\n\n<h2>2.Plugin/Agent的RPC交互结构</h2>\n\n<p>以下会涉及到消息队列的知识，请一定先学习相关知识。</p>\n\n<p>我们暂时不考虑L3-agent这种，就简单的学习OVS PLUGIN和AGENT的交互。</p>\n\n<p>首先Plugin和Agent有两条RPC通道，注意，我说的逻辑上的哈：</p>\n\n<p>通道1：Plugin向Agent发送port-update,network-delete,tunnel-update的消息，在消息队列上使用的Exchange分别名为：q-agent-notifier-network-delete_fanout，q-agent-notifier-port-update_fanout，q-agent-notifier-tunnel-update_fanout，交换类型fanout.</p>\n\n<p>在通道1上，又来继续，因为OpenStack中有多个OVS AGENT，每个Agent会有一个ID，并且，每个AGENT在每个Exchange上都有一条消息队列。队列名字为：q-agent-notifier-tunnel-update_fanout_995ad5d516d1430fa7f8535337ed5b24这种，简单点说，就是一个Agent在通道1的过程中，会有3个相应的名字中包含自己ID号的队列与三个Exchange进行绑定。</p>\n\n<p>通道2：Agent向Plugin发送通道1的结果或者自身的一个心跳信息（主要是设备打开关闭，设备info）等信息，在消息队列上Exchange名为：openstack，交换类型topic交换。</p>\n\n<p>在OpenStack中，Quantum Server节点只有一个，加之这个交换机是topic交换，所以Plugin端与交换机openstack就只有一个队列，名字为：q-plugin</p>\n\n<p>说白了，就是说Plugin-->Agent使用的Exchange是q-agent-notifier-***，Agent-->Plugin使用的Exchange是openstack。</p>\n\n<p>下面是Quantum官方资料的一个图，我只截取相关部分，你应该能看懂了！暂时我们只学习我圈红的部分。</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互1-1024x707.png\" alt=\"PluginAgent的交互1\" width=\"640\" height=\"441\" class=\"aligncenter size-large wp-image-228\" /></a></p>\n\n<p>我对这个图进行了一些补充，如下是两个OVS AGENT的情况！</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互2.png\" alt=\"PluginAgent的交互2\" width=\"570\" height=\"621\" class=\"aligncenter size-full wp-image-229\" /></a></p>\n\n<h2>3.Plugin/Agent的RPC交互分类</h2>\n','Quantum OpenvSwitch Plugin和Agent的RPC机制（一）','','inherit','open','open','','225-revision-2','','','2013-03-26 17:06:04','2013-03-26 09:06:04','','225','http://blog.wachang.net/2013/03/225-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('231','1','2013-03-26 17:09:30','2013-03-26 09:09:30','<blockquote>\n  <p>浅出OpenStack源码系列</p>\n  \n  <p>Quantum OpenvSwitch Plugin源码分析</p>\n  \n  <p>Plugin和Agent的RPC机制（一）</p>\n  \n  <p>基于2013、03月的Quantum源代码，主要是Folsom版本。</p>\n</blockquote>\n\n<p>这一节主要讲讲OVS Plugin和OVS agent之间如何进行交互，也就是RPC机制的过程。</p>\n\n<p>首先，需要了解一点RPC的知识，主要是AMQP协议，这方面可以网上找一点文章看看。</p>\n\n<h2>1.Plugin/Agent的RPC交互背景</h2>\n\n<p>如果我下文中有一些术语如果不明白，那就需要先补充AMQP和RabbitMQ的知识了。</p>\n\n<p>在Quantum Plugin的OpenvSwitch插件中，有一些操作需要Agent端通过执行<code>ovs-vsctl</code>来完成，这些操作包括：</p>\n\n<ul>\n<li>port-update：更新一个port的信息</li>\n<li>network-delete:删除网络，那么就需要删除网络上所有的port信息</li>\n<li>tunnel:在GRE模式中，有时候需要更新GRE port的信息</li>\n</ul>\n\n<p>而Plugin的作用就是告诉Agent应该做什么，他们是通过RPC机制来通信，简单来说，就是:`Plugin把一个具体操作发送到RabbitMQ的消息队列中，Agent从里面读取消息，并执行，当结果需要通知Plugin的时候，又向PLugin发送一个RPC消息，Plugin此时就主要是更改数据库相应的信息。</p>\n\n<p>同时，Agent还有一个作用，就是通过RPC通告plugin自己是否存活。也会把自己的设备信息发送给Plugin，或者告诉Plugin：本Agent已死，请在数据库删除我的信息吧，有事烧纸~</p>\n\n<h2>2.Plugin/Agent的RPC交互结构</h2>\n\n<p>以下会涉及到消息队列的知识，请一定先学习相关知识。</p>\n\n<p>我们暂时不考虑L3-agent这种，就简单的学习OVS PLUGIN和AGENT的交互。</p>\n\n<p>首先Plugin和Agent有两条RPC通道，注意，我说的逻辑上的哈：</p>\n\n<p>通道1：Plugin向Agent发送port-update,network-delete,tunnel-update的消息，在消息队列上使用的Exchange分别名为：q-agent-notifier-network-delete_fanout，q-agent-notifier-port-update_fanout，q-agent-notifier-tunnel-update_fanout，交换类型fanout.</p>\n\n<p>在通道1上，又来继续，因为OpenStack中有多个OVS AGENT，每个Agent会有一个ID，并且，每个AGENT在每个Exchange上都有一条消息队列。队列名字为：q-agent-notifier-tunnel-update_fanout_995ad5d516d1430fa7f8535337ed5b24这种，简单点说，就是一个Agent在通道1的过程中，会有3个相应的名字中包含自己ID号的队列与三个Exchange进行绑定。</p>\n\n<p>通道2：Agent向Plugin发送通道1的结果或者自身的一个心跳信息（主要是设备打开关闭，设备info）等信息，在消息队列上Exchange名为：openstack，交换类型topic交换。</p>\n\n<p>在OpenStack中，Quantum Server节点只有一个，加之这个交换机是topic交换，所以Plugin端与交换机openstack就只有一个队列，名字为：q-plugin</p>\n\n<p>说白了，就是说Plugin-->Agent使用的Exchange是q-agent-notifier-***，Agent-->Plugin使用的Exchange是openstack。</p>\n\n<p>下面是Quantum官方资料的一个图，我只截取相关部分，你应该能看懂了！暂时我们只学习我圈红的部分。</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互1-1024x707.png\" alt=\"PluginAgent的交互1\" width=\"640\" height=\"441\" class=\"aligncenter size-large wp-image-228\" /></a></p>\n\n<p>我对这个图进行了一些补充，如下是两个OVS AGENT的情况！</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互2.png\" alt=\"PluginAgent的交互2\" width=\"570\" height=\"621\" class=\"aligncenter size-full wp-image-229\" /></a></p>\n\n<h2>3.Plugin/Agent的RPC交互分类</h2>\n','Quantum OpenvSwitch Plugin和Agent的RPC机制（一）','','inherit','open','open','','225-revision-3','','','2013-03-26 17:09:30','2013-03-26 09:09:30','','225','http://blog.wachang.net/2013/03/225-revision-3/','0','revision','','0');");
E_D("replace into `wp_posts` values('232','1','2013-03-26 20:55:03','2013-03-26 12:55:03','<blockquote>\n  <p>浅出OpenStack源码系列</p>\n  \n  <p>Quantum OpenvSwitch Plugin源码分析</p>\n  \n  <p>Plugin和Agent的RPC机制（一）</p>\n  \n  <p>基于2013、03月的Quantum源代码，主要是Folsom版本。</p>\n</blockquote>\n\n<p>这一节主要讲讲OVS Plugin和OVS agent之间如何进行交互，也就是RPC机制的过程。</p>\n\n<p>首先，需要了解一点RPC的知识，主要是AMQP协议，这方面可以网上找一点文章看看。</p>\n\n<h2>1.Plugin/Agent的RPC交互背景</h2>\n\n<p>如果我下文中有一些术语如果不明白，那就需要先补充AMQP和RabbitMQ的知识了。</p>\n\n<p>在Quantum Plugin的OpenvSwitch插件中，有一些操作需要Agent端通过执行<code>ovs-vsctl</code>来完成，这些操作包括：</p>\n\n<ul>\n<li>port-update：更新一个port的信息</li>\n<li>network-delete:删除网络，那么就需要删除网络上所有的port信息</li>\n<li>tunnel:在GRE模式中，有时候需要更新GRE port的信息</li>\n</ul>\n\n<p>而Plugin的作用就是告诉Agent应该做什么，他们是通过RPC机制来通信，简单来说，就是:`Plugin把一个具体操作发送到RabbitMQ的消息队列中，Agent从里面读取消息，并执行，当结果需要通知Plugin的时候，又向PLugin发送一个RPC消息，Plugin此时就主要是更改数据库相应的信息。</p>\n\n<p>同时，Agent还有一个作用，就是通过RPC通告plugin自己是否存活。也会把自己的设备信息发送给Plugin，或者告诉Plugin：本Agent已死，请在数据库删除我的信息吧，有事烧纸~</p>\n\n<h2>2.Plugin/Agent的RPC交互结构</h2>\n\n<p>以下会涉及到消息队列的知识，请一定先学习相关知识。</p>\n\n<p>我们暂时不考虑L3-agent这种，就简单的学习OVS PLUGIN和AGENT的交互。</p>\n\n<p>首先Plugin和Agent有两条RPC通道，注意，我说的逻辑上的哈：</p>\n\n<p>通道1：Plugin向Agent发送port-update,network-delete,tunnel-update的消息，在消息队列上使用的Exchange分别名为：q-agent-notifier-network-delete&#95;fanout，q-agent-notifier-port-update&#95;fanout，q-agent-notifier-tunnel-update_fanout，交换类型fanout.</p>\n\n<p>在通道1上，又来继续，因为OpenStack中有多个OVS AGENT，每个Agent会有一个ID，并且，每个AGENT在每个Exchange上都有一条消息队列。队列名字为：q-agent-notifier-tunnel-update&#95;fanout&#95;995ad5d516d1430fa7f8535337ed5b24这种，简单点说，就是一个Agent在通道1的过程中，会有3个相应的名字中包含自己ID号的队列与三个Exchange进行绑定。</p>\n\n<p>通道2：Agent向Plugin发送通道1的结果或者自身的一个心跳信息（主要是设备打开关闭，设备info）等信息，在消息队列上Exchange名为：openstack，交换类型topic交换。</p>\n\n<p>在OpenStack中，Quantum Server节点只有一个，加之这个交换机是topic交换，所以Plugin端与交换机openstack就只有一个队列，名字为：q-plugin</p>\n\n<p>说白了，就是说Plugin-->Agent使用的Exchange是q-agent-notifier-&#42;**||，Agent-->Plugin使用的Exchange是openstack。</p>\n\n<p>下面是Quantum官方资料的一个图，我只截取相关部分，你应该能看懂了！暂时我们只学习我圈红的部分。</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互1-1024x707.png\" alt=\"PluginAgent的交互1\" width=\"640\" height=\"441\" class=\"aligncenter size-large wp-image-228\" /></a></p>\n\n<p>我对这个图进行了一些补充，如下是两个OVS AGENT的情况！</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互2.png\" alt=\"PluginAgent的交互2\" width=\"570\" height=\"621\" class=\"aligncenter size-full wp-image-229\" /></a></p>\n\n<h2>3.源码概念理解</h2>\n\n<p>首先，再次强调，虽然OpenvSwitch Plugin单Plugin+多agent形式的，但是在实际中，Plugin会主动向Agent发送消息（更改port删除network，tunnel_update等等），Agent也会主动向Plugin发送信息（比如在新计算节点加入的时候需要报告OVS信息，以及OVS有改动后要通知Plugin更改数据库等），所以从消息队列的方向来说，Plugin和Agent既是生产者，也是消费者。在源代码中，会有这么几个概念：</p>\n\n<ul>\n<li>manager：其实就是指Plugin或者Agent的实例。</li>\n<li>dispatcher:在RPC中，当接收消息以后，需要定义一个函数来处理，这成为回调callback，dispatcher就是做这么一个调度工作,一个到达的消息可以被调度（dispatch）到一个函数或者一个类中。</li>\n<li>create_consumer：用于向AMQP服务器指明接收哪个队列的消息，这个函数需要dispatcher作为参数（很明显，接收到消息以后就交给调度器处理嘛）</li>\n<li>在Plugin的代码中：<code>Class AgentNotifierApi</code>这个类用于向Agent发送RPC消息</li>\n<li>在Plugin的代码中:<code>Class OVSRpcCallbacks</code>作为Plugin接收RPC消息的目标，见上面dispatcher的描述。</li>\n<li>在Agent代码中：<code>Class OVSPluginApi</code>这个类用于向Plugin发送RPC消息</li>\n</ul>\n','Quantum OpenvSwitch Plugin和Agent的RPC机制（一）','','inherit','open','open','','225-revision-4','','','2013-03-26 20:55:03','2013-03-26 12:55:03','','225','http://blog.wachang.net/2013/03/225-revision-4/','0','revision','','0');");
E_D("replace into `wp_posts` values('233','1','2013-03-26 20:58:02','2013-03-26 12:58:02','<blockquote>\n  <p>浅出OpenStack源码系列</p>\n  \n  <p>Quantum OpenvSwitch Plugin源码分析</p>\n  \n  <p>Plugin和Agent的RPC机制（一）</p>\n  \n  <p>基于2013、03月的Quantum源代码，主要是Folsom版本。</p>\n</blockquote>\n\n<p>这一节主要讲讲OVS Plugin和OVS agent之间如何进行交互，也就是RPC机制的过程。</p>\n\n<p>首先，需要了解一点RPC的知识，主要是AMQP协议，这方面可以网上找一点文章看看。</p>\n\n<h2>1.Plugin/Agent的RPC交互背景</h2>\n\n<p>如果我下文中有一些术语如果不明白，那就需要先补充AMQP和RabbitMQ的知识了。</p>\n\n<p>在Quantum Plugin的OpenvSwitch插件中，有一些操作需要Agent端通过执行<code>ovs-vsctl</code>来完成，这些操作包括：</p>\n\n<ul>\n<li>port-update：更新一个port的信息</li>\n<li>network-delete:删除网络，那么就需要删除网络上所有的port信息</li>\n<li>tunnel:在GRE模式中，有时候需要更新GRE port的信息</li>\n</ul>\n\n<p>而Plugin的作用就是告诉Agent应该做什么，他们是通过RPC机制来通信，简单来说，就是:`Plugin把一个具体操作发送到RabbitMQ的消息队列中，Agent从里面读取消息，并执行，当结果需要通知Plugin的时候，又向PLugin发送一个RPC消息，Plugin此时就主要是更改数据库相应的信息。</p>\n\n<p>同时，Agent还有一个作用，就是通过RPC通告plugin自己是否存活。也会把自己的设备信息发送给Plugin，或者告诉Plugin：本Agent已死，请在数据库删除我的信息吧，有事烧纸~</p>\n\n<h2>2.Plugin/Agent的RPC交互结构</h2>\n\n<p>以下会涉及到消息队列的知识，请一定先学习相关知识。</p>\n\n<p>我们暂时不考虑L3-agent这种，就简单的学习OVS PLUGIN和AGENT的交互。</p>\n\n<p>首先Plugin和Agent有两条RPC通道，注意，我说的逻辑上的哈：</p>\n\n<p>通道1：Plugin向Agent发送port-update,network-delete,tunnel-update的消息，在消息队列上使用的Exchange分别名为：q-agent-notifier-network-delete&#95;fanout，q-agent-notifier-port-update&#95;fanout，q-agent-notifier-tunnel-update_fanout，交换类型fanout.</p>\n\n<p>在通道1上，又来继续，因为OpenStack中有多个OVS AGENT，每个Agent会有一个ID，并且，每个AGENT在每个Exchange上都有一条消息队列。队列名字为：q-agent-notifier-tunnel-update&#95;fanout&#95;995ad5d516d1430fa7f8535337ed5b24这种，简单点说，就是一个Agent在通道1的过程中，会有3个相应的名字中包含自己ID号的队列与三个Exchange进行绑定。</p>\n\n<p>通道2：Agent向Plugin发送通道1的结果或者自身的一个心跳信息（主要是设备打开关闭，设备info）等信息，在消息队列上Exchange名为：openstack，交换类型topic交换。</p>\n\n<p>在OpenStack中，Quantum Server节点只有一个，加之这个交换机是topic交换，所以Plugin端与交换机openstack就只有一个队列，名字为：q-plugin</p>\n\n<p>说白了，就是说Plugin-->Agent使用的Exchange是q-agent-notifier-&#42;**||，Agent-->Plugin使用的Exchange是openstack。</p>\n\n<p>下面是Quantum官方资料的一个图，我只截取相关部分，你应该能看懂了！暂时我们只学习我圈红的部分。</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互1-1024x707.png\" alt=\"PluginAgent的交互1\" width=\"640\" height=\"441\" class=\"aligncenter size-large wp-image-228\" /></a></p>\n\n<p>我对这个图进行了一些补充，如下是两个OVS AGENT的情况！</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互2.png\" alt=\"PluginAgent的交互2\" width=\"570\" height=\"621\" class=\"aligncenter size-full wp-image-229\" /></a></p>\n\n<h2>3.源码概念理解</h2>\n\n<p>首先，再次强调，虽然OpenvSwitch Plugin单Plugin+多agent形式的，但是在实际中，Plugin会主动向Agent发送消息（更改port删除network，tunnel_update等等），Agent也会主动向Plugin发送信息（比如在新计算节点加入的时候需要报告OVS信息，以及OVS有改动后要通知Plugin更改数据库等），所以从消息队列的方向来说，Plugin和Agent既是生产者，也是消费者。在源代码中，会有这么几个概念：</p>\n\n<ul>\n<li>manager：其实就是指Plugin或者Agent的实例。</li>\n<li>dispatcher:在RPC中，当接收消息以后，需要定义一个函数来处理，这成为回调callback，dispatcher就是做这么一个调度工作,一个到达的消息可以被调度（dispatch）到一个函数或者一个类中。</li>\n<li>create_consumer：用于向AMQP服务器指明接收哪个队列的消息，这个函数需要dispatcher作为参数（很明显，接收到消息以后就交给调度器处理嘛）</li>\n<li>在Plugin的代码中：<code>Class AgentNotifierApi</code>这个类用于向Agent发送RPC消息</li>\n<li>在Plugin的代码中:<code>Class OVSRpcCallbacks</code>作为Plugin接收RPC消息的目标，见上面dispatcher的描述。</li>\n<li>在Agent代码中：<code>Class OVSPluginApi</code>这个类用于向Plugin发送RPC消息</li>\n</ul>\n','Quantum OpenvSwitch Plugin和Agent的RPC机制（一）','','inherit','open','open','','225-revision-5','','','2013-03-26 20:58:02','2013-03-26 12:58:02','','225','http://blog.wachang.net/2013/03/225-revision-5/','0','revision','','0');");
E_D("replace into `wp_posts` values('234','1','2013-03-26 21:40:22','2013-03-26 13:40:22','<blockquote>\n  <p>浅出OpenStack源码系列</p>\n  \n  <p>Quantum OpenvSwitch Plugin源码分析</p>\n  \n  <p>Plugin和Agent的RPC机制（一）</p>\n  \n  <p>基于2013、03月的Quantum源代码，主要是Folsom版本。</p>\n</blockquote>\n\n<p>这一节主要讲讲OVS Plugin和OVS agent之间如何进行交互，也就是RPC机制的过程。</p>\n\n<p>首先，需要了解一点RPC的知识，主要是AMQP协议，这方面可以网上找一点文章看看。</p>\n\n<h2>1.Plugin/Agent的RPC交互背景</h2>\n\n<p>如果我下文中有一些术语如果不明白，那就需要先补充AMQP和RabbitMQ的知识了。</p>\n\n<p>在Quantum Plugin的OpenvSwitch插件中，有一些操作需要Agent端通过执行<code>ovs-vsctl</code>来完成，这些操作包括：</p>\n\n<ul>\n<li>port-update：更新一个port的信息</li>\n<li>network-delete:删除网络，那么就需要删除网络上所有的port信息</li>\n<li>tunnel:在GRE模式中，有时候需要更新GRE port的信息</li>\n</ul>\n\n<p>而Plugin的作用就是告诉Agent应该做什么，他们是通过RPC机制来通信，简单来说，就是:`Plugin把一个具体操作发送到RabbitMQ的消息队列中，Agent从里面读取消息，并执行，当结果需要通知Plugin的时候，又向PLugin发送一个RPC消息，Plugin此时就主要是更改数据库相应的信息。</p>\n\n<!--more-->\n\n<p>同时，Agent还有一个作用，就是通过RPC通告plugin自己是否存活。也会把自己的设备信息发送给Plugin，或者告诉Plugin：本Agent已死，请在数据库删除我的信息吧，有事烧纸~</p>\n\n<h2>2.Plugin/Agent的RPC交互结构</h2>\n\n<p>以下会涉及到消息队列的知识，请一定先学习相关知识。</p>\n\n<p>我们暂时不考虑L3-agent这种，就简单的学习OVS PLUGIN和AGENT的交互。</p>\n\n<p>首先Plugin和Agent有两条RPC通道，注意，我说的逻辑上的哈：</p>\n\n<p>通道1：Plugin向Agent发送port-update,network-delete,tunnel-update的消息，在消息队列上使用的Exchange分别名为：q-agent-notifier-network-delete&#95;fanout，q-agent-notifier-port-update&#95;fanout，q-agent-notifier-tunnel-update_fanout，交换类型fanout.</p>\n\n<p>在通道1上，又来继续，因为OpenStack中有多个OVS AGENT，每个Agent会有一个ID，并且，每个AGENT在每个Exchange上都有一条消息队列。队列名字为：q-agent-notifier-tunnel-update&#95;fanout&#95;995ad5d516d1430fa7f8535337ed5b24这种，简单点说，就是一个Agent在通道1的过程中，会有3个相应的名字中包含自己ID号的队列与三个Exchange进行绑定。</p>\n\n<p>通道2：Agent向Plugin发送通道1的结果或者自身的一个心跳信息（主要是设备打开关闭，设备info）等信息，在消息队列上Exchange名为：openstack，交换类型topic交换。</p>\n\n<p>在OpenStack中，Quantum Server节点只有一个，加之这个交换机是topic交换，所以Plugin端与交换机openstack就只有一个队列，名字为：q-plugin</p>\n\n<p>说白了，就是说Plugin-->Agent使用的Exchange是q-agent-notifier-&#42;**||||，Agent-->Plugin使用的Exchange是openstack。</p>\n\n<p>下面是Quantum官方资料的一个图，我只截取相关部分，你应该能看懂了！暂时我们只学习我圈红的部分。</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互1-1024x707.png\" alt=\"PluginAgent的交互1\" width=\"640\" height=\"441\" class=\"aligncenter size-large wp-image-228\" /></a></p>\n\n<p>我对这个图进行了一些补充，如下是两个OVS AGENT的情况！</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互2.png\" alt=\"PluginAgent的交互2\" width=\"570\" height=\"621\" class=\"aligncenter size-full wp-image-229\" /></a></p>\n\n<h2>3.源码概念理解</h2>\n\n<p>首先，再次强调，虽然OpenvSwitch Plugin单Plugin+多agent形式的，但是在实际中，Plugin会主动向Agent发送消息（更改port删除network，tunnel_update等等），Agent也会主动向Plugin发送信息（比如在新计算节点加入的时候需要报告OVS信息，以及OVS有改动后要通知Plugin更改数据库等），所以从消息队列的方向来说，Plugin和Agent既是生产者，也是消费者。在源代码中，会有这么几个概念：</p>\n\n<ul>\n<li>manager：其实就是指Plugin或者Agent的实例。</li>\n<li>dispatcher:在RPC中，当接收消息以后，需要定义一个函数来处理，这成为回调callback，dispatcher就是做这么一个调度工作,一个到达的消息可以被调度（dispatch）到一个函数或者一个类中。</li>\n<li>create_consumer：用于向AMQP服务器指明接收哪个队列的消息，这个函数需要dispatcher作为参数（很明显，接收到消息以后就交给调度器处理嘛）</li>\n<li>在Plugin的代码中：<code>Class AgentNotifierApi</code>这个类用于向Agent发送RPC消息</li>\n<li>在Plugin的代码中:<code>Class OVSRpcCallbacks</code>作为Plugin接收RPC消息的目标，见上面dispatcher的描述。</li>\n<li>在Agent代码中：<code>Class OVSPluginApi</code>这个类用于向Plugin发送RPC消息</li>\n</ul>\n\n<p>下面再给出源代码中各个组件的一个流程图,下一节中会从源码上分析本节内容！</p>\n','Quantum OpenvSwitch Plugin和Agent的RPC机制（一）','','inherit','open','open','','225-autosave','','','2013-03-26 21:40:22','2013-03-26 13:40:22','','225','http://blog.wachang.net/2013/03/225-autosave/','0','revision','','0');");
E_D("replace into `wp_posts` values('235','1','2013-03-26 21:53:48','2013-03-26 13:53:48','','RPC源码流程','','inherit','open','open','','rpc%e6%ba%90%e7%a0%81%e6%b5%81%e7%a8%8b','','','2013-03-26 21:53:48','2013-03-26 13:53:48','','225','http://blog.wachang.net/wp-content/uploads/2013/03/RPC源码流程.jpg','0','attachment','image/jpeg','0');");
E_D("replace into `wp_posts` values('236','1','2013-03-26 20:58:21','2013-03-26 12:58:21','<blockquote>\n  <p>浅出OpenStack源码系列</p>\n  \n  <p>Quantum OpenvSwitch Plugin源码分析</p>\n  \n  <p>Plugin和Agent的RPC机制（一）</p>\n  \n  <p>基于2013、03月的Quantum源代码，主要是Folsom版本。</p>\n</blockquote>\n\n<p>这一节主要讲讲OVS Plugin和OVS agent之间如何进行交互，也就是RPC机制的过程。</p>\n\n<p>首先，需要了解一点RPC的知识，主要是AMQP协议，这方面可以网上找一点文章看看。</p>\n\n<h2>1.Plugin/Agent的RPC交互背景</h2>\n\n<p>如果我下文中有一些术语如果不明白，那就需要先补充AMQP和RabbitMQ的知识了。</p>\n\n<p>在Quantum Plugin的OpenvSwitch插件中，有一些操作需要Agent端通过执行<code>ovs-vsctl</code>来完成，这些操作包括：</p>\n\n<ul>\n<li>port-update：更新一个port的信息</li>\n<li>network-delete:删除网络，那么就需要删除网络上所有的port信息</li>\n<li>tunnel:在GRE模式中，有时候需要更新GRE port的信息</li>\n</ul>\n\n<p>而Plugin的作用就是告诉Agent应该做什么，他们是通过RPC机制来通信，简单来说，就是:`Plugin把一个具体操作发送到RabbitMQ的消息队列中，Agent从里面读取消息，并执行，当结果需要通知Plugin的时候，又向PLugin发送一个RPC消息，Plugin此时就主要是更改数据库相应的信息。</p>\n\n<!--more-->\n\n<p>同时，Agent还有一个作用，就是通过RPC通告plugin自己是否存活。也会把自己的设备信息发送给Plugin，或者告诉Plugin：本Agent已死，请在数据库删除我的信息吧，有事烧纸~</p>\n\n<h2>2.Plugin/Agent的RPC交互结构</h2>\n\n<p>以下会涉及到消息队列的知识，请一定先学习相关知识。</p>\n\n<p>我们暂时不考虑L3-agent这种，就简单的学习OVS PLUGIN和AGENT的交互。</p>\n\n<p>首先Plugin和Agent有两条RPC通道，注意，我说的逻辑上的哈：</p>\n\n<p>通道1：Plugin向Agent发送port-update,network-delete,tunnel-update的消息，在消息队列上使用的Exchange分别名为：q-agent-notifier-network-delete&#95;fanout，q-agent-notifier-port-update&#95;fanout，q-agent-notifier-tunnel-update_fanout，交换类型fanout.</p>\n\n<p>在通道1上，又来继续，因为OpenStack中有多个OVS AGENT，每个Agent会有一个ID，并且，每个AGENT在每个Exchange上都有一条消息队列。队列名字为：q-agent-notifier-tunnel-update&#95;fanout&#95;995ad5d516d1430fa7f8535337ed5b24这种，简单点说，就是一个Agent在通道1的过程中，会有3个相应的名字中包含自己ID号的队列与三个Exchange进行绑定。</p>\n\n<p>通道2：Agent向Plugin发送通道1的结果或者自身的一个心跳信息（主要是设备打开关闭，设备info）等信息，在消息队列上Exchange名为：openstack，交换类型topic交换。</p>\n\n<p>在OpenStack中，Quantum Server节点只有一个，加之这个交换机是topic交换，所以Plugin端与交换机openstack就只有一个队列，名字为：q-plugin</p>\n\n<p>说白了，就是说Plugin-->Agent使用的Exchange是q-agent-notifier-&#42;**|||，Agent-->Plugin使用的Exchange是openstack。</p>\n\n<p>下面是Quantum官方资料的一个图，我只截取相关部分，你应该能看懂了！暂时我们只学习我圈红的部分。</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互1-1024x707.png\" alt=\"PluginAgent的交互1\" width=\"640\" height=\"441\" class=\"aligncenter size-large wp-image-228\" /></a></p>\n\n<p>我对这个图进行了一些补充，如下是两个OVS AGENT的情况！</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/PluginAgent的交互2.png\" alt=\"PluginAgent的交互2\" width=\"570\" height=\"621\" class=\"aligncenter size-full wp-image-229\" /></a></p>\n\n<h2>3.源码概念理解</h2>\n\n<p>首先，再次强调，虽然OpenvSwitch Plugin单Plugin+多agent形式的，但是在实际中，Plugin会主动向Agent发送消息（更改port删除network，tunnel_update等等），Agent也会主动向Plugin发送信息（比如在新计算节点加入的时候需要报告OVS信息，以及OVS有改动后要通知Plugin更改数据库等），所以从消息队列的方向来说，Plugin和Agent既是生产者，也是消费者。在源代码中，会有这么几个概念：</p>\n\n<ul>\n<li>manager：其实就是指Plugin或者Agent的实例。</li>\n<li>dispatcher:在RPC中，当接收消息以后，需要定义一个函数来处理，这成为回调callback，dispatcher就是做这么一个调度工作,一个到达的消息可以被调度（dispatch）到一个函数或者一个类中。</li>\n<li>create_consumer：用于向AMQP服务器指明接收哪个队列的消息，这个函数需要dispatcher作为参数（很明显，接收到消息以后就交给调度器处理嘛）</li>\n<li>在Plugin的代码中：<code>Class AgentNotifierApi</code>这个类用于向Agent发送RPC消息</li>\n<li>在Plugin的代码中:<code>Class OVSRpcCallbacks</code>作为Plugin接收RPC消息的目标，见上面dispatcher的描述。</li>\n<li>在Agent代码中：<code>Class OVSPluginApi</code>这个类用于向Plugin发送RPC消息</li>\n</ul>\n','Quantum OpenvSwitch Plugin和Agent的RPC机制（一）','','inherit','open','open','','225-revision-6','','','2013-03-26 20:58:21','2013-03-26 12:58:21','','225','http://blog.wachang.net/2013/03/225-revision-6/','0','revision','','0');");
E_D("replace into `wp_posts` values('237','1','2013-03-26 21:59:44','2013-03-26 13:59:44','<p>有时候看代码需要总结，这个类之间的关系很复杂，懒得有手写，就想用一点工具来自动生成。于是就找了找Python的UML工具，至于什么是UML，随便一查就知道了。具体需求正如以下这哥们所说：</p>\n\n<blockquote>\n  <p>随着项目进展，类越来越多，原来做总体设计的时候没有想到有这么复杂的情况:(。现在我想画出uml图来反映各个类之间的关系。</p>\n</blockquote>\n\n<p>于是找了下，有这么些工具：</p>\n\n<h2>1 Ecplise插件pyuml</h2>\n\n<p>因为我不用ecplise，所以不知道了。</p>\n\n<h2>2 Python UML Tool</h2>\n\n<p>在http://sourceforge.net/projects/pyut/上找到的，版不过版本确实比较老了，最后更新是09年的。使用起来还是很方便的，比较麻烦的就是对于类神马的必须手动输入成员和方法，<strong>不支持撤销操作</strong>。</p>\n\n<h2>3 Pynsource</h2>\n\n<p><a href=\"http://www.andypatterns.com/index.php/products/pynsource/\">项目主页</a></p>\n\n<p><a href=\"https://code.google.com/p/pynsource/downloads/list\">下载</a></p>\n\n<p>使用上比较方便，导入python文件后就可以自动生成相应的类关系，特别是支持把关系转换成asic表，这个我就喜欢！<strong>用于生成单个Python文件UML就非常好，但是要手动指定类的继承关系之类的很麻烦，不支持撤销操作。</strong></p>\n\n<h2>4 Gaphor</h2>\n\n<p>&lt;sourceforge.net/projects/gaphor/></p>\n\n<p>我找到的版本比较老，python2.5的，安装也很复杂，算了吧。</p>\n\n<h2>Dia</h2>\n\n<p>Dia是基于GTK的图形绘制程序，适用于Linux, Unix和Window DIA软件启动界面 s，以 GPL 许可发布。通俗的说，一个10MB量级的免费软件，代替visio基本没问题，被收入了“最好的300款免费软件”。也有些用户认为Dia很多地方不太好用，但无论如何，它是综合性能最高的免费解决方案。</p>\n\n<h2>参考文章</h2>\n\n<p>http://imtx.me/archives/155.html</p>\n\n<p>http://www.cnblogs.com/dkblog/archive/2011/05/06/2039124.html</p>\n\n<p>http://www.blogjava.net/xiaohuzi2008/archive/2012/12/25/393463.html</p>\n\n<p>http://blog.chinaunix.net/uid-20446794-id-1677395.html</p>\n\n<p>http://tgic.me/2010/02/05/%E8%A7%A3%E5%86%B3-gaphor-uml-%E4%B8%8D%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E7%9A%84%E9%97%AE%E9%A2%98/</p>\n\n<p>https://cacoo.com</p>\n','UML Tools For Python','','inherit','open','open','','161-revision-4','','','2013-03-26 21:59:44','2013-03-26 13:59:44','','161','http://blog.wachang.net/2013/03/161-revision-4/','0','revision','','0');");
E_D("replace into `wp_posts` values('238','1','2013-03-27 00:43:59','2013-03-26 16:43:59','<blockquote>\n  <p>浅出OpenStack源码系列</p>\n  \n  <p>Quantum OpenvSwitch Plugin代码架构</p>\n</blockquote>\n\n<p>此文主要罗列一下OpenvSwitch Plugin的代码架构，做一点解释，为后续文章做准备。</p>\n\n<h2>1.代码目录结构：</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/quantum-ovs-plugin代码目录.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/quantum-ovs-plugin代码目录.jpg\" alt=\"quantum ovs plugin代码目录\" width=\"315\" height=\"405\" class=\"aligncenter size-full wp-image-239\" /></a></p>\n\n<p><code>ovs_quantum_plugin.py</code>:是plugin部分的主文件，在配置文件中指定选用此文件中类<code>OVSQuantumPluginV2</code>，quantum在启动的时候就会实例化此类，从而plugin可以正常工作。</p>\n\n<p><code>ovs_models_v2.py</code>:是数据库models文件，主要是sqlachemy使用，用于把数据库的一个Table和一个类进行关联。</p>\n\n<p><code>ovs_db_v2.py</code>:openvswitch plugin的数据库支持，通过使用sqlalchemy实现数据库的查找写入等操作。</p>\n\n<p><code>ovs_quantum_agent.py</code>：agent程序文件，在agent端执行</p>\n\n<p><code>common</code>:则包含了解析OVS配置相关的支持。</p>\n\n<!--more-->\n\n<h2>2.OpenvSwitch Plugin类关系</h2>\n\n<p>插件主要是ovs&#95;quantum&#95;plugin.py文件，首先查看一下该文件中import的内容：</p>\n\n<pre><code>from quantum.db import quota_db\nfrom quantum.db import securitygroups_rpc_base as sg_db_rpc\nfrom quantum.extensions import portbindings\nfrom quantum.extensions import providernet as provider\nfrom quantum.extensions import securitygroup as ext_sg\nfrom quantum.openstack.common import importutils\nfrom quantum.openstack.common import log as logging\nfrom quantum.openstack.common import rpc\nfrom quantum.openstack.common.rpc import proxy\nfrom quantum.plugins.openvswitch.common import config\nfrom quantum.plugins.openvswitch.common import constants\nfrom quantum.plugins.openvswitch import ovs_db_v2\nfrom quantum import policy\n</code></pre>\n\n<p>其中plugin部分的类关系如下图所示：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/ovs_plugin_uml.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/ovs_plugin_uml-1024x581.jpg\" alt=\"ovs_plugin_uml\" width=\"640\" height=\"363\" class=\"aligncenter size-large wp-image-240\" /></a></p>\n\n<p>其中，<strong>剪头表示类之间的继承关系，而带点的线表示该类的一个实例是作为另外一个类中的一个属性</strong></p>\n\n<h2>3.penvSwitch Agent类关系</h2>\n\n<p>还是先看import的内容：</p>\n\n<pre><code>import sys\nimport time\n\nimport eventlet\nfrom oslo.config import cfg\n\nfrom quantum.agent.linux import ip_lib\nfrom quantum.agent.linux import ovs_lib\nfrom quantum.agent.linux import utils\nfrom quantum.agent import rpc as agent_rpc\nfrom quantum.agent import securitygroups_rpc as sg_rpc\nfrom quantum.common import config as logging_config\nfrom quantum.common import constants as q_const\nfrom quantum.common import topics\nfrom quantum.common import utils as q_utils\nfrom quantum import context\nfrom quantum.extensions import securitygroup as ext_sg\nfrom quantum.openstack.common import log as logging\nfrom quantum.openstack.common import loopingcall\nfrom quantum.openstack.common.rpc import dispatcher\nfrom quantum.plugins.openvswitch.common import config\nfrom quantum.plugins.openvswitch.common import constants\n</code></pre>\n\n<p>相应的UML图：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/ovs_agent_uml.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/ovs_agent_uml.jpg\" alt=\"ovs_agent_uml\" width=\"897\" height=\"917\" class=\"aligncenter size-full wp-image-241\" /></a></p>\n','Quantum OpenvSwitch Plugin代码架构','','publish','open','open','','quantum-ovs-plugin-code-structure','','','2013-03-27 00:49:15','2013-03-26 16:49:15','','0','http://blog.wachang.net/?p=238','0','post','','0');");
E_D("replace into `wp_posts` values('239','1','2013-03-27 00:15:09','2013-03-26 16:15:09','','quantum ovs plugin代码目录','','inherit','open','open','','quantum-ovs-plugin%e4%bb%a3%e7%a0%81%e7%9b%ae%e5%bd%95','','','2013-03-27 00:15:09','2013-03-26 16:15:09','','238','http://blog.wachang.net/wp-content/uploads/2013/03/quantum-ovs-plugin代码目录.jpg','0','attachment','image/jpeg','0');");
E_D("replace into `wp_posts` values('240','1','2013-03-27 00:28:52','2013-03-26 16:28:52','','ovs_plugin_uml','','inherit','open','open','','ovs_plugin_uml','','','2013-03-27 00:28:52','2013-03-26 16:28:52','','238','http://blog.wachang.net/wp-content/uploads/2013/03/ovs_plugin_uml.jpg','0','attachment','image/jpeg','0');");
E_D("replace into `wp_posts` values('241','1','2013-03-27 00:43:01','2013-03-26 16:43:01','','ovs_agent_uml','','inherit','open','open','','ovs_agent_uml','','','2013-03-27 00:43:01','2013-03-26 16:43:01','','238','http://blog.wachang.net/wp-content/uploads/2013/03/ovs_agent_uml.jpg','0','attachment','image/jpeg','0');");
E_D("replace into `wp_posts` values('242','1','2013-03-27 00:43:56','2013-03-26 16:43:56','<blockquote>\n  <p>浅出OpenStack源码系列</p>\n  \n  <p>Quantum OpenvSwitch Plugin代码架构</p>\n</blockquote>\n\n<p>此文主要罗列一下OpenvSwitch Plugin的代码架构，做一点解释，为后续文章做准备。</p>\n\n<h2>1.代码目录结构：</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/quantum-ovs-plugin代码目录.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/quantum-ovs-plugin代码目录.jpg\" alt=\"quantum ovs plugin代码目录\" width=\"315\" height=\"405\" class=\"aligncenter size-full wp-image-239\" /></a></p>\n\n<p><code>ovs_quantum_plugin.py</code>:是plugin部分的主文件，在配置文件中指定选用此文件中类<code>OVSQuantumPluginV2</code>，quantum在启动的时候就会实例化此类，从而plugin可以正常工作。</p>\n\n<p><code>ovs_models_v2.py</code>:是数据库models文件，主要是sqlachemy使用，用于把数据库的一个Table和一个类进行关联。</p>\n\n<p><code>ovs_db_v2.py</code>:openvswitch plugin的数据库支持，通过使用sqlalchemy实现数据库的查找写入等操作。</p>\n\n<p><code>ovs_quantum_agent.py</code>：agent程序文件，在agent端执行</p>\n\n<p><code>common</code>:则包含了解析OVS配置相关的支持。</p>\n\n<h2>2.OpenvSwitch Plugin类关系</h2>\n\n<p>插件主要是ovs_quantum_plugin.py文件，首先查看一下该文件中import的内容：</p>\n\n<pre><code>from quantum.db import quota_db\nfrom quantum.db import securitygroups_rpc_base as sg_db_rpc\nfrom quantum.extensions import portbindings\nfrom quantum.extensions import providernet as provider\nfrom quantum.extensions import securitygroup as ext_sg\nfrom quantum.openstack.common import importutils\nfrom quantum.openstack.common import log as logging\nfrom quantum.openstack.common import rpc\nfrom quantum.openstack.common.rpc import proxy\nfrom quantum.plugins.openvswitch.common import config\nfrom quantum.plugins.openvswitch.common import constants\nfrom quantum.plugins.openvswitch import ovs_db_v2\nfrom quantum import policy\n</code></pre>\n\n<p>其中plugin部分的类关系如下图所示：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/ovs_plugin_uml.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/ovs_plugin_uml-1024x581.jpg\" alt=\"ovs_plugin_uml\" width=\"640\" height=\"363\" class=\"aligncenter size-large wp-image-240\" /></a></p>\n\n<p>其中，<strong>剪头表示类之间的继承关系，而带点的线表示该类的一个实例是作为另外一个类中的一个属性</strong></p>\n\n<h2>3.penvSwitch Agent类关系</h2>\n\n<p>还是先看import的内容：</p>\n\n<pre><code>import sys\nimport time\n\nimport eventlet\nfrom oslo.config import cfg\n\nfrom quantum.agent.linux import ip_lib\nfrom quantum.agent.linux import ovs_lib\nfrom quantum.agent.linux import utils\nfrom quantum.agent import rpc as agent_rpc\nfrom quantum.agent import securitygroups_rpc as sg_rpc\nfrom quantum.common import config as logging_config\nfrom quantum.common import constants as q_const\nfrom quantum.common import topics\nfrom quantum.common import utils as q_utils\nfrom quantum import context\nfrom quantum.extensions import securitygroup as ext_sg\nfrom quantum.openstack.common import log as logging\nfrom quantum.openstack.common import loopingcall\nfrom quantum.openstack.common.rpc import dispatcher\nfrom quantum.plugins.openvswitch.common import config\nfrom quantum.plugins.openvswitch.common import constants\n</code></pre>\n\n<p>相应的UML图：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/ovs_agent_uml.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/ovs_agent_uml.jpg\" alt=\"ovs_agent_uml\" width=\"897\" height=\"917\" class=\"aligncenter size-full wp-image-241\" /></a></p>\n','Quantum OpenvSwitch Plugin代码架构','','inherit','open','open','','238-revision','','','2013-03-27 00:43:56','2013-03-26 16:43:56','','238','http://blog.wachang.net/2013/03/238-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('243','1','2013-03-27 00:43:59','2013-03-26 16:43:59','<blockquote>\n  <p>浅出OpenStack源码系列</p>\n  \n  <p>Quantum OpenvSwitch Plugin代码架构</p>\n</blockquote>\n\n<p>此文主要罗列一下OpenvSwitch Plugin的代码架构，做一点解释，为后续文章做准备。</p>\n\n<h2>1.代码目录结构：</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/quantum-ovs-plugin代码目录.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/quantum-ovs-plugin代码目录.jpg\" alt=\"quantum ovs plugin代码目录\" width=\"315\" height=\"405\" class=\"aligncenter size-full wp-image-239\" /></a></p>\n\n<p><code>ovs_quantum_plugin.py</code>:是plugin部分的主文件，在配置文件中指定选用此文件中类<code>OVSQuantumPluginV2</code>，quantum在启动的时候就会实例化此类，从而plugin可以正常工作。</p>\n\n<p><code>ovs_models_v2.py</code>:是数据库models文件，主要是sqlachemy使用，用于把数据库的一个Table和一个类进行关联。</p>\n\n<p><code>ovs_db_v2.py</code>:openvswitch plugin的数据库支持，通过使用sqlalchemy实现数据库的查找写入等操作。</p>\n\n<p><code>ovs_quantum_agent.py</code>：agent程序文件，在agent端执行</p>\n\n<p><code>common</code>:则包含了解析OVS配置相关的支持。</p>\n\n<h2>2.OpenvSwitch Plugin类关系</h2>\n\n<p>插件主要是ovs_quantum_plugin.py文件，首先查看一下该文件中import的内容：</p>\n\n<pre><code>from quantum.db import quota_db\nfrom quantum.db import securitygroups_rpc_base as sg_db_rpc\nfrom quantum.extensions import portbindings\nfrom quantum.extensions import providernet as provider\nfrom quantum.extensions import securitygroup as ext_sg\nfrom quantum.openstack.common import importutils\nfrom quantum.openstack.common import log as logging\nfrom quantum.openstack.common import rpc\nfrom quantum.openstack.common.rpc import proxy\nfrom quantum.plugins.openvswitch.common import config\nfrom quantum.plugins.openvswitch.common import constants\nfrom quantum.plugins.openvswitch import ovs_db_v2\nfrom quantum import policy\n</code></pre>\n\n<p>其中plugin部分的类关系如下图所示：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/ovs_plugin_uml.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/ovs_plugin_uml-1024x581.jpg\" alt=\"ovs_plugin_uml\" width=\"640\" height=\"363\" class=\"aligncenter size-large wp-image-240\" /></a></p>\n\n<p>其中，<strong>剪头表示类之间的继承关系，而带点的线表示该类的一个实例是作为另外一个类中的一个属性</strong></p>\n\n<h2>3.penvSwitch Agent类关系</h2>\n\n<p>还是先看import的内容：</p>\n\n<pre><code>import sys\nimport time\n\nimport eventlet\nfrom oslo.config import cfg\n\nfrom quantum.agent.linux import ip_lib\nfrom quantum.agent.linux import ovs_lib\nfrom quantum.agent.linux import utils\nfrom quantum.agent import rpc as agent_rpc\nfrom quantum.agent import securitygroups_rpc as sg_rpc\nfrom quantum.common import config as logging_config\nfrom quantum.common import constants as q_const\nfrom quantum.common import topics\nfrom quantum.common import utils as q_utils\nfrom quantum import context\nfrom quantum.extensions import securitygroup as ext_sg\nfrom quantum.openstack.common import log as logging\nfrom quantum.openstack.common import loopingcall\nfrom quantum.openstack.common.rpc import dispatcher\nfrom quantum.plugins.openvswitch.common import config\nfrom quantum.plugins.openvswitch.common import constants\n</code></pre>\n\n<p>相应的UML图：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/ovs_agent_uml.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/ovs_agent_uml.jpg\" alt=\"ovs_agent_uml\" width=\"897\" height=\"917\" class=\"aligncenter size-full wp-image-241\" /></a></p>\n','Quantum OpenvSwitch Plugin代码架构','','inherit','open','open','','238-revision-2','','','2013-03-27 00:43:59','2013-03-26 16:43:59','','238','http://blog.wachang.net/2013/03/238-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('244','1','2013-04-01 13:47:54','2013-04-01 05:47:54','<h1>浅出OpenStack源码系列</h1>\n\n<h2>1.Python基础模块篇</h2>\n\n<p>OpenStack中使用了许多python模块，这一章就先介绍一下主要模块的最用，同时也是后续文章中的一些参考。</p>\n\n<p><a href=\"http://webpython.codepoint.net/wsgi_tutorial\">Python:WSGI介绍</a></p>\n\n<p><a href=\"http://blog.wachang.net/2013/04/python-paste-deploy-1/\">Python.Paste指南之Deploy(1)-概念</a></p>\n\n<h2>2.Quantum篇</h2>\n\n<h3>2.3 OpenvSwitch Plugin</h3>\n\n<p><a href=\"http://blog.wachang.net/2013/03/quantum-ovs-plugin-code-structure/\">Quantum OpenvSwitch Plugin代码架构</a></p>\n\n<p><a href=\"http://blog.wachang.net/2013/03/quantum-ovs-agent-config-file/\">Quantum OpenvSwitch Plugin&amp;Agent读取配置文件</a></p>\n\n<p><a href=\"http://blog.wachang.net/2013/03/quantum-ovs-plugin-agent-rpc-1/\">Quantum OpenvSwitch Plugin和Agent的RPC机制（一）</a></p>\n','浅出OpenStack源码','','inherit','open','open','','209-autosave','','','2013-04-01 13:47:54','2013-04-01 05:47:54','','209','http://blog.wachang.net/2013/03/209-autosave/','0','revision','','0');");
E_D("replace into `wp_posts` values('245','1','2013-03-27 00:44:15','2013-03-26 16:44:15','<blockquote>\n  <p>浅出OpenStack源码系列</p>\n  \n  <p>Quantum OpenvSwitch Plugin代码架构</p>\n</blockquote>\n\n<p>此文主要罗列一下OpenvSwitch Plugin的代码架构，做一点解释，为后续文章做准备。</p>\n\n<h2>1.代码目录结构：</h2>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/quantum-ovs-plugin代码目录.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/quantum-ovs-plugin代码目录.jpg\" alt=\"quantum ovs plugin代码目录\" width=\"315\" height=\"405\" class=\"aligncenter size-full wp-image-239\" /></a></p>\n\n<p><code>ovs_quantum_plugin.py</code>:是plugin部分的主文件，在配置文件中指定选用此文件中类<code>OVSQuantumPluginV2</code>，quantum在启动的时候就会实例化此类，从而plugin可以正常工作。</p>\n\n<p><code>ovs_models_v2.py</code>:是数据库models文件，主要是sqlachemy使用，用于把数据库的一个Table和一个类进行关联。</p>\n\n<p><code>ovs_db_v2.py</code>:openvswitch plugin的数据库支持，通过使用sqlalchemy实现数据库的查找写入等操作。</p>\n\n<p><code>ovs_quantum_agent.py</code>：agent程序文件，在agent端执行</p>\n\n<p><code>common</code>:则包含了解析OVS配置相关的支持。</p>\n\n<!--more-->\n\n<h2>2.OpenvSwitch Plugin类关系</h2>\n\n<p>插件主要是ovs&#95;quantum&#95;plugin.py文件，首先查看一下该文件中import的内容：</p>\n\n<pre><code>from quantum.db import quota_db\nfrom quantum.db import securitygroups_rpc_base as sg_db_rpc\nfrom quantum.extensions import portbindings\nfrom quantum.extensions import providernet as provider\nfrom quantum.extensions import securitygroup as ext_sg\nfrom quantum.openstack.common import importutils\nfrom quantum.openstack.common import log as logging\nfrom quantum.openstack.common import rpc\nfrom quantum.openstack.common.rpc import proxy\nfrom quantum.plugins.openvswitch.common import config\nfrom quantum.plugins.openvswitch.common import constants\nfrom quantum.plugins.openvswitch import ovs_db_v2\nfrom quantum import policy\n</code></pre>\n\n<p>其中plugin部分的类关系如下图所示：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/ovs_plugin_uml.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/ovs_plugin_uml-1024x581.jpg\" alt=\"ovs_plugin_uml\" width=\"640\" height=\"363\" class=\"aligncenter size-large wp-image-240\" /></a></p>\n\n<p>其中，<strong>剪头表示类之间的继承关系，而带点的线表示该类的一个实例是作为另外一个类中的一个属性</strong></p>\n\n<h2>3.penvSwitch Agent类关系</h2>\n\n<p>还是先看import的内容：</p>\n\n<pre><code>import sys\nimport time\n\nimport eventlet\nfrom oslo.config import cfg\n\nfrom quantum.agent.linux import ip_lib\nfrom quantum.agent.linux import ovs_lib\nfrom quantum.agent.linux import utils\nfrom quantum.agent import rpc as agent_rpc\nfrom quantum.agent import securitygroups_rpc as sg_rpc\nfrom quantum.common import config as logging_config\nfrom quantum.common import constants as q_const\nfrom quantum.common import topics\nfrom quantum.common import utils as q_utils\nfrom quantum import context\nfrom quantum.extensions import securitygroup as ext_sg\nfrom quantum.openstack.common import log as logging\nfrom quantum.openstack.common import loopingcall\nfrom quantum.openstack.common.rpc import dispatcher\nfrom quantum.plugins.openvswitch.common import config\nfrom quantum.plugins.openvswitch.common import constants\n</code></pre>\n\n<p>相应的UML图：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/ovs_agent_uml.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/ovs_agent_uml.jpg\" alt=\"ovs_agent_uml\" width=\"897\" height=\"917\" class=\"aligncenter size-full wp-image-241\" /></a></p>\n','Quantum OpenvSwitch Plugin代码架构','','inherit','open','open','','238-revision-3','','','2013-03-27 00:44:15','2013-03-26 16:44:15','','238','http://blog.wachang.net/2013/03/238-revision-3/','0','revision','','0');");
E_D("replace into `wp_posts` values('246','1','2013-03-25 16:50:09','2013-03-25 08:50:09','\n','浅出OpenStack源码','','inherit','open','open','','209-revision-2','','','2013-03-25 16:50:09','2013-03-25 08:50:09','','209','http://blog.wachang.net/2013/03/209-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('247','1','2013-03-27 15:27:08','0000-00-00 00:00:00','<p>apt-get install python-tk</p>\n','Lumpy:Python中的UML工具','','draft','open','open','','','','','2013-03-27 15:27:08','2013-03-27 07:27:08','','0','http://blog.wachang.net/?p=247','0','post','','0');");
E_D("replace into `wp_posts` values('248','1','2013-03-27 15:19:57','2013-03-27 07:19:57','<p>apt-get install python-tk</p>\n','Lumpy:Python中的UML工具','','inherit','open','open','','247-revision','','','2013-03-27 15:19:57','2013-03-27 07:19:57','','247','http://blog.wachang.net/2013/03/247-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('249','1','2013-03-27 16:25:00','0000-00-00 00:00:00','<p>因为自己使用的Linux都没图形界面，想用UML工具的话还有点麻烦，于是就只好换到windows下，顺带就把windows环境下使用python的一些准备工作做一个总结。</p>\n\n<p>修改PATH变量</p>\n\n<p>cmd--》python -V</p>\n\n<p>Microsoft Windows [版本 6.1.7601] 版权所有 (c) 2009 Microsoft Corporation。保留所有权利。</p>\n\n<p>C:>python Python 2.7.3 (default, Apr 10 2012, 23:24:47) [MSC v.1500 64 bit (AMD64)] on win 32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.</p>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>help(''print'') no documentation found for ''print''</p>\n      \n      <p>quit()</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n\n<p>安装相应setuptools https://pypi.python.org/pypi/setuptools#downloads</p>\n\n<p>64为下载 ez_setup.py 文件</p>\n\n<p>然后cmd中python执行</p>\n\n<p>把python2.7\\\\scripts加入到PATH路径</p>\n\n<p>安装帮助文件：就可以使用help()方法查看帮助文档： http://docs.python.org/2/download.html 下载html 然后就没有拉人</p>\n\n<hr />\n\n<p>如何使Python解释器能直接import默认安装路径以外的第三方模块？</p>\n\n<p>为了能import默认安装路径以外的第三方的模块（如自己写的模块），需要新建PYTHONPATH环境变量，值为这个模块所在的目录。 http://www.cnblogs.com/zhuyp1015/archive/2012/07/17/2596495.html http://www.cnblogs.com/qiyeshublog/archive/2012/01/24/2329162.html 安装piphttp://blog.csdn.net/lab2013/article/details/6876967 https://pypi.python.org/pypi/pip</p>\n\n<p>http://www.jb51.net/softjc/34898.html</p>\n\n<p>TMD还是装avtive python暗一点！</p>\n','在Windows 7下构建Python环境','','draft','open','open','','','','','2013-03-27 16:25:00','2013-03-27 08:25:00','','0','http://blog.wachang.net/?p=249','0','post','','0');");
E_D("replace into `wp_posts` values('250','1','2013-03-27 16:20:12','2013-03-27 08:20:12','<p>因为自己使用的Linux都没图形界面，想用UML工具的话还有点麻烦，于是就只好换到windows下，顺带就把windows环境下使用python的一些准备工作做一个总结。</p>\n\n<p>修改PATH变量</p>\n\n<p>cmd--》python -V</p>\n\n<p>Microsoft Windows [版本 6.1.7601]\n版权所有 (c) 2009 Microsoft Corporation。保留所有权利。</p>\n\n<p>C:&#62;python\nPython 2.7.3 (default, Apr 10 2012, 23:24:47) [MSC v.1500 64 bit (AMD64)] on win\n32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.</p>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>help(''print'')\n      no documentation found for ''print''</p>\n      \n      <p>quit()</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n\n<p>安装相应setuptools\nhttps://pypi.python.org/pypi/setuptools#downloads</p>\n\n<p>64为下载 ez_setup.py 文件</p>\n\n<p>然后cmd中python执行</p>\n\n<p>把python2.7\\\\scripts加入到PATH路径</p>\n\n<p>安装帮助文件：就可以使用help()方法查看帮助文档：\nhttp://docs.python.org/2/download.html 下载html\n然后就没有拉人</p>\n\n<hr />\n\n<p>如何使Python解释器能直接import默认安装路径以外的第三方模块？</p>\n\n<p>为了能import默认安装路径以外的第三方的模块（如自己写的模块），需要新建PYTHONPATH环境变量，值为这个模块所在的目录。\nhttp://www.cnblogs.com/zhuyp1015/archive/2012/07/17/2596495.html\nhttp://www.cnblogs.com/qiyeshublog/archive/2012/01/24/2329162.html\n安装piphttp://blog.csdn.net/lab2013/article/details/6876967\nhttps://pypi.python.org/pypi/pip</p>\n\n<p>http://www.jb51.net/softjc/34898.html</p>\n','在Windows 7下构建Python环境','','inherit','open','open','','249-revision','','','2013-03-27 16:20:12','2013-03-27 08:20:12','','249','http://blog.wachang.net/2013/03/249-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('251','1','2013-03-27 16:24:56','2013-03-27 08:24:56','<p>因为自己使用的Linux都没图形界面，想用UML工具的话还有点麻烦，于是就只好换到windows下，顺带就把windows环境下使用python的一些准备工作做一个总结。</p>\n\n<p>修改PATH变量</p>\n\n<p>cmd--》python -V</p>\n\n<p>Microsoft Windows [版本 6.1.7601] 版权所有 (c) 2009 Microsoft Corporation。保留所有权利。</p>\n\n<p>C:>python Python 2.7.3 (default, Apr 10 2012, 23:24:47) [MSC v.1500 64 bit (AMD64)] on win 32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.</p>\n\n<blockquote>\n  <blockquote>\n    <blockquote>\n      <p>help(''print'') no documentation found for ''print''</p>\n      \n      <p>quit()</p>\n    </blockquote>\n  </blockquote>\n</blockquote>\n\n<p>安装相应setuptools https://pypi.python.org/pypi/setuptools#downloads</p>\n\n<p>64为下载 ez_setup.py 文件</p>\n\n<p>然后cmd中python执行</p>\n\n<p>把python2.7\\\\scripts加入到PATH路径</p>\n\n<p>安装帮助文件：就可以使用help()方法查看帮助文档： http://docs.python.org/2/download.html 下载html 然后就没有拉人</p>\n\n<hr />\n\n<p>如何使Python解释器能直接import默认安装路径以外的第三方模块？</p>\n\n<p>为了能import默认安装路径以外的第三方的模块（如自己写的模块），需要新建PYTHONPATH环境变量，值为这个模块所在的目录。 http://www.cnblogs.com/zhuyp1015/archive/2012/07/17/2596495.html http://www.cnblogs.com/qiyeshublog/archive/2012/01/24/2329162.html 安装piphttp://blog.csdn.net/lab2013/article/details/6876967 https://pypi.python.org/pypi/pip</p>\n\n<p>http://www.jb51.net/softjc/34898.html</p>\n\n<p>TMD还是装avtive pythonanyid</p>\n','在Windows 7下构建Python环境','','inherit','open','open','','249-revision-2','','','2013-03-27 16:24:56','2013-03-27 08:24:56','','249','http://blog.wachang.net/2013/03/249-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('252','1','2013-03-28 19:11:22','2013-03-28 11:11:22','<p>用了WordPress一段时间了，还是比较舒爽的，这里推荐一下几个我使用起来很好的插件，顺带也是我自己的一个记录。</p>\n\n<h2>1 WP-Markdown</h2>\n\n<p>经典的Markdown插件，使用以后，文章可以使用MarkDown语法，并且撰写的时候还会有相应的实时预览，插件安装以后到<code>设置</code>&#45;--|》<code>撰写</code>里面可以进行设置。</p>\n\n<h2>2 wp-markdown-syntax-sugar</h2>\n\n<p>WP-Markdown的增强工具，主要提供的是代码方面的简洁，使用的话很类似Github Favoured Markdown。详细的使用可以看插件说明。</p>\n\n<h2>3 StatPressCN</h2>\n\n<p>访问统计，我自己懒得用google分析或者百度统计这种，所以这个插件倒也比较好，插件支持小工具，可以把统计信息显示在Blog的侧栏sidebar上面。</p>\n\n<!--more-->\n\n<h2>4 Add Post URL</h2>\n\n<p>自动在每篇文章中加入文章链接，简单的来讲，就是在文末加上“原创所有，转载请注明出处：xxxxxxxx”这种很多博客都会使用的玩意。安装后在<code>设置</code>--》<code>添加文章内链接</code>出设置。</p>\n\n<h2>5 All in One SEO Pack</h2>\n\n<p>基本都会推荐的SEO插件，有助于更好的被搜索引擎抓取，安装后基本不需要设置，只是说写文章的最后会有一个SEO选项，需要填上相应的信息。最直观的效果就是搜索引擎抓取到你的网页显示的就像是：</p>\n\n<pre><code>Linux IP Command使用笔记| Wang Chang''s Blog\nblog.wachang.net/2013/03/linux-ip-command/ - 网页快照\n4 days ago – ip是iproute2软件包里面的一个强大的网络配置工具，它能够替代一些传统的网络管理工具。例如：ifconfig、route 等。\n</code></pre>\n\n<p>再简单的说下，在撰写文章的SEO插件部分，<code>Title</code>就是显示的文章名称，<code>Description</code>就是上面本文的一个简单描述。</p>\n\n<h2>6 Better WordPress Minify</h2>\n\n<p>这个插件我强烈推荐，比如你使用百度的优化建议功能，告诉你需要合并CSS，或者JS的时候，怎么办，用这个插件就OK了。这个插件能自动把多个CSS或者JS文件合并为一个文件，这样在访问网站的时候就不需要多次请求CSS，JS文件了，一次请求就搞定，能帮提高网站的速度。安装完以后会在<code>设置</code>--》<code>BWP Minify</code>中设置。</p>\n\n<h2>7 Content Index</h2>\n\n<p>自动生成文章内容索引，在文章撰写的时候可以选择打开此功能否。</p>\n\n<p>另外，相同功能的可选插件：Table of Contents Plus</p>\n\n<h2>8 Download Manager</h2>\n\n<p>这个也是有用的，因为WP不支持在文章中添加附件，所以要么你上传了文件以后，在文章中给出地址，大家可以下载，如果要炫一点的话，就用这个插件，它的流程大概是：在Download Manager中上传一个文件，然后会生成一个插入代码，直接黏贴在文章中就OK了，在文章中显示的是一个下载图标，相对来说，友好度就比直接整链接上去好多了。</p>\n\n<h2>9 Google XML Sitemaps</h2>\n\n<p>为站点圣城Sitemap的东西，装一个，几乎不用设置</p>\n\n<h2>10 Lightbox Plus ColorBox</h2>\n\n<p>这个也是强烈推荐，在WP的文章中如果有图片，点击的话直接跳转到新图片窗口，十分不方面用户阅读。使用这个以后用户点击图片就会再文章中填出一个窗口显示图片放大的样子，效果很炫，推荐！</p>\n\n<h2>11 WP Super Cache</h2>\n\n<p>如果是买的WP空间或者主机，由于WP是php脚本写的，一般执行php的时候会占用服务器CPU资源，这是主机上不希望看到的，所以用这个插件以后，会先生成缓存，用户访问的话会先访问缓存，一是加快了网站访问速度，而是减小了主机上的负担（有些主机上你CPU高了的话就会给你停掉），因为有中文的界面，设置起来很简单，当然，有时候配合服务器开启GZIP等压缩就更好了，相关的技巧我以后会将。</p>\n\n<h2>12 WP GitHub Tools</h2>\n\n<p>可以再sidebar增加一个GITHUB栏显示你的GITHUB情况，支持GIST，对于程序员还是不错的！</p>\n\n<h2>13 oEmbed Gist</h2>\n\n<p>上面插件的简化版，支持文章中插入GIST代码。</p>\n','WordPress插件推荐','','publish','open','open','','wordpress-plugins','','','2013-03-28 19:11:53','2013-03-28 11:11:53','','0','http://blog.wachang.net/?p=252','0','post','','0');");
E_D("replace into `wp_posts` values('253','1','2013-03-28 19:06:25','2013-03-28 11:06:25','<p>用了WordPress一段时间了，还是比较舒爽的，这里推荐一下几个我使用起来很好的插件，顺带也是我自己的一个记录。</p>\n\n<h2>1 WP-Markdown</h2>\n\n<p>经典的Markdown插件，使用以后，文章可以使用MarkDown语法，并且撰写的时候还会有相应的实时预览，插件安装以后到<code>设置</code>---》<code>撰写</code>里面可以进行设置。</p>\n\n<h2>2 wp-markdown-syntax-sugar</h2>\n\n<p>WP-Markdown的增强工具，主要提供的是代码方面的简洁，使用的话很类似Github Favoured Markdown。详细的使用可以看插件说明。</p>\n\n<h2>3 StatPressCN</h2>\n\n<p>访问统计，我自己懒得用google分析或者百度统计这种，所以这个插件倒也比较好，插件支持小工具，可以把统计信息显示在Blog的侧栏sidebar上面。</p>\n\n<h2>4 Add Post URL</h2>\n\n<p>自动在每篇文章中加入文章链接，简单的来讲，就是在文末加上“原创所有，转载请注明出处：xxxxxxxx”这种很多博客都会使用的玩意。安装后在<code>设置</code>--》<code>添加文章内链接</code>出设置。</p>\n\n<h2>5 All in One SEO Pack</h2>\n\n<p>基本都会推荐的SEO插件，有助于更好的被搜索引擎抓取，安装后基本不需要设置，只是说写文章的最后会有一个SEO选项，需要填上相应的信息。最直观的效果就是搜索引擎抓取到你的网页显示的就像是：</p>\n\n<pre><code>Linux IP Command使用笔记| Wang Chang''s Blog\nblog.wachang.net/2013/03/linux-ip-command/ - 网页快照\n4 days ago – ip是iproute2软件包里面的一个强大的网络配置工具，它能够替代一些传统的网络管理工具。例如：ifconfig、route 等。\n</code></pre>\n\n<p>再简单的说下，在撰写文章的SEO插件部分，<code>Title</code>就是显示的文章名称，<code>Description</code>就是上面本文的一个简单描述。</p>\n\n<h2>6 Better WordPress Minify</h2>\n\n<p>这个插件我强烈推荐，比如你使用百度的优化建议功能，告诉你需要合并CSS，或者JS的时候，怎么办，用这个插件就OK了。这个插件能自动把多个CSS或者JS文件合并为一个文件，这样在访问网站的时候就不需要多次请求CSS，JS文件了，一次请求就搞定，能帮提高网站的速度。安装完以后会在<code>设置</code>--》<code>BWP Minify</code>中设置。</p>\n\n<h2>7 Content Index</h2>\n\n<p>自动生成文章内容索引，在文章撰写的时候可以选择打开此功能否。</p>\n\n<p>另外，相同功能的可选插件：Table of Contents Plus</p>\n\n<h2>8 Download Manager</h2>\n\n<p>这个也是有用的，因为WP不支持在文章中添加附件，所以要么你上传了文件以后，在文章中给出地址，大家可以下载，如果要炫一点的话，就用这个插件，它的流程大概是：在Download Manager中上传一个文件，然后会生成一个插入代码，直接黏贴在文章中就OK了，在文章中显示的是一个下载图标，相对来说，友好度就比直接整链接上去好多了。</p>\n\n<h2>9 Google XML Sitemaps</h2>\n\n<p>为站点圣城Sitemap的东西，装一个，几乎不用设置</p>\n\n<h2>10 Lightbox Plus ColorBox</h2>\n\n<p>这个也是强烈推荐，在WP的文章中如果有图片，点击的话直接跳转到新图片窗口，十分不方面用户阅读。使用这个以后用户点击图片就会再文章中填出一个窗口显示图片放大的样子，效果很炫，推荐！</p>\n\n<h2>11 WP Super Cache</h2>\n\n<p>如果是买的WP空间或者主机，由于WP是php脚本写的，一般执行php的时候会占用服务器CPU资源，这是主机上不希望看到的，所以用这个插件以后，会先生成缓存，用户访问的话会先访问缓存，一是加快了网站访问速度，而是减小了主机上的负担（有些主机上你CPU高了的话就会给你停掉），因为有中文的界面，设置起来很简单，当然，有时候配合服务器开启GZIP等压缩就更好了，相关的技巧我以后会将。</p>\n\n<h2>12 WP GitHub Tools</h2>\n\n<p>可以再sidebar增加一个GITHUB栏显示你的GITHUB情况，支持GIST，对于程序员还是不错的！</p>\n\n<h2>13 oEmbed Gist</h2>\n\n<p>上面插件的简化版，支持文章中插入GIST代码。</p>\n','WordPress插件推荐','','inherit','open','open','','252-revision','','','2013-03-28 19:06:25','2013-03-28 11:06:25','','252','http://blog.wachang.net/2013/03/252-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('254','1','2013-03-28 19:11:22','2013-03-28 11:11:22','<p>用了WordPress一段时间了，还是比较舒爽的，这里推荐一下几个我使用起来很好的插件，顺带也是我自己的一个记录。</p>\n\n<h2>1 WP-Markdown</h2>\n\n<p>经典的Markdown插件，使用以后，文章可以使用MarkDown语法，并且撰写的时候还会有相应的实时预览，插件安装以后到<code>设置</code>---》<code>撰写</code>里面可以进行设置。</p>\n\n<h2>2 wp-markdown-syntax-sugar</h2>\n\n<p>WP-Markdown的增强工具，主要提供的是代码方面的简洁，使用的话很类似Github Favoured Markdown。详细的使用可以看插件说明。</p>\n\n<h2>3 StatPressCN</h2>\n\n<p>访问统计，我自己懒得用google分析或者百度统计这种，所以这个插件倒也比较好，插件支持小工具，可以把统计信息显示在Blog的侧栏sidebar上面。</p>\n\n<h2>4 Add Post URL</h2>\n\n<p>自动在每篇文章中加入文章链接，简单的来讲，就是在文末加上“原创所有，转载请注明出处：xxxxxxxx”这种很多博客都会使用的玩意。安装后在<code>设置</code>--》<code>添加文章内链接</code>出设置。</p>\n\n<h2>5 All in One SEO Pack</h2>\n\n<p>基本都会推荐的SEO插件，有助于更好的被搜索引擎抓取，安装后基本不需要设置，只是说写文章的最后会有一个SEO选项，需要填上相应的信息。最直观的效果就是搜索引擎抓取到你的网页显示的就像是：</p>\n\n<pre><code>Linux IP Command使用笔记| Wang Chang''s Blog\nblog.wachang.net/2013/03/linux-ip-command/ - 网页快照\n4 days ago – ip是iproute2软件包里面的一个强大的网络配置工具，它能够替代一些传统的网络管理工具。例如：ifconfig、route 等。\n</code></pre>\n\n<p>再简单的说下，在撰写文章的SEO插件部分，<code>Title</code>就是显示的文章名称，<code>Description</code>就是上面本文的一个简单描述。</p>\n\n<h2>6 Better WordPress Minify</h2>\n\n<p>这个插件我强烈推荐，比如你使用百度的优化建议功能，告诉你需要合并CSS，或者JS的时候，怎么办，用这个插件就OK了。这个插件能自动把多个CSS或者JS文件合并为一个文件，这样在访问网站的时候就不需要多次请求CSS，JS文件了，一次请求就搞定，能帮提高网站的速度。安装完以后会在<code>设置</code>--》<code>BWP Minify</code>中设置。</p>\n\n<h2>7 Content Index</h2>\n\n<p>自动生成文章内容索引，在文章撰写的时候可以选择打开此功能否。</p>\n\n<p>另外，相同功能的可选插件：Table of Contents Plus</p>\n\n<h2>8 Download Manager</h2>\n\n<p>这个也是有用的，因为WP不支持在文章中添加附件，所以要么你上传了文件以后，在文章中给出地址，大家可以下载，如果要炫一点的话，就用这个插件，它的流程大概是：在Download Manager中上传一个文件，然后会生成一个插入代码，直接黏贴在文章中就OK了，在文章中显示的是一个下载图标，相对来说，友好度就比直接整链接上去好多了。</p>\n\n<h2>9 Google XML Sitemaps</h2>\n\n<p>为站点圣城Sitemap的东西，装一个，几乎不用设置</p>\n\n<h2>10 Lightbox Plus ColorBox</h2>\n\n<p>这个也是强烈推荐，在WP的文章中如果有图片，点击的话直接跳转到新图片窗口，十分不方面用户阅读。使用这个以后用户点击图片就会再文章中填出一个窗口显示图片放大的样子，效果很炫，推荐！</p>\n\n<h2>11 WP Super Cache</h2>\n\n<p>如果是买的WP空间或者主机，由于WP是php脚本写的，一般执行php的时候会占用服务器CPU资源，这是主机上不希望看到的，所以用这个插件以后，会先生成缓存，用户访问的话会先访问缓存，一是加快了网站访问速度，而是减小了主机上的负担（有些主机上你CPU高了的话就会给你停掉），因为有中文的界面，设置起来很简单，当然，有时候配合服务器开启GZIP等压缩就更好了，相关的技巧我以后会将。</p>\n\n<h2>12 WP GitHub Tools</h2>\n\n<p>可以再sidebar增加一个GITHUB栏显示你的GITHUB情况，支持GIST，对于程序员还是不错的！</p>\n\n<h2>13 oEmbed Gist</h2>\n\n<p>上面插件的简化版，支持文章中插入GIST代码。</p>\n','WordPress插件推荐','','inherit','open','open','','252-revision-2','','','2013-03-28 19:11:22','2013-03-28 11:11:22','','252','http://blog.wachang.net/2013/03/252-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('255','1','2013-03-30 02:48:35','2013-03-29 18:48:35','<p>最近看python一些模块文档的时候发现有doc目录，研究了一下发现两个关键字：一是Sphinx,二是pygments，为了能有更好的文档，于是研究下这两个东西,先说第一个sphinx。</p>\n\n<h2>1 什么是Sphinx</h2>\n\n<p>Sphinx是一个工具，她能够轻易地创建智慧和优雅的文档，她是出自Georg Brandl之手，在BSD许可证下授权。</p>\n\n<p>她最初是为了新版的python文档， 因此在python项目的文档具有完美的特性，但是同样支持c/c++，目前正在计划增加对其他的语言的支持。 Sphinx具有如下的特点：</p>\n\n<ul>\n<li>输出格式： 超文本标记语言 (包括Windows HTML帮助)，LaTeX (可打印的PDF版本)，手册页，纯文本</li>\n<li>丰富的交叉引用： 语义标记以及针对函数，类，引用，词汇表（术语）和相似的信息块的自动链接 *　层次结构： 简单的文本树定义，就能自动地链接到同层（兄弟姐妹）、上一层（父母）以及下一层（子女）的文本位置 *　自动生成目录： 通用索引以及语言模块的目录</li>\n<li>代码高亮： 代码自动高亮，通过使用 Pygments</li>\n<li>扩展功能： 自动测试的代码片段，包括从Python模块（API文档）的文档字符串</li>\n</ul>\n\n<p>Sphinx 使用reStructuredText作为她的标记语言，她的优点大部分是来自于reStructuredText 以及reStructuredText的解析和转换工具（套件）Docutils的强大以及简单明了。</p>\n\n<p>说白了,他就是把reStructuredText文本文档翻译成一些文件格式,类似PDF啊之类的工具,正如我的博客上用的wp-markdown插件能把markdown标记语言写的文章转换成合适的html文档一样。</p>\n\n<p>换一种方式，和编译C程序一样，sphinx可以看成是gcc等编译器，负责把源码（reStructuredText）格式的文档编译成相应的PDF或者html的文件。</p>\n\n<!--more-->\n\n<h2>2 安装</h2>\n\n<p>Sphinx的主页是<a href=\"http://sphinx-doc.org/index.html\">http://sphinx-doc.org/index.html</a></p>\n\n<p>中文站点<a href=\"http://www.pythondoc.com/sphinx/index.html\">http://www.pythondoc.com/sphinx/index.html</a></p>\n\n<p>在Ubuntu下可以直接apt安装：</p>\n\n<pre><code>apt-get install python-sphinx\n</code></pre>\n\n<p>也可以使用：</p>\n\n<pre><code>easy_install -U Sphinx\n</code></pre>\n\n<p>或者在<a href=\"https://pypi.python.org/pypi/Sphinx\">https://pypi.python.org/pypi/Sphinx</a>下载安装。</p>\n\n<p>每个文档工程的源码里面有一个conf.py文件，主要是关于文档如何生成等参数配置。可以自己学习。下面我们做一个简单的例子。</p>\n\n<h2>3 如何使用</h2>\n\n<p>首先我们下载一个olso的python库，这个主要是配置文件解析的，OpenStack中用，不用懂其详细语法，下载完以后解压，可以看到doc目录：</p>\n\n<pre><code>root@Compute2:~/oslo.config-1.1.0/doc# tree\n.\n└── source\n    ├── conf.py\n    ├── index.rst\n    ├── static\n    │   ├── basic.css\n    │   ├── default.css\n    │   ├── header_bg.jpg\n    │   ├── header-line.gif\n    │   ├── jquery.tweet.js\n    │   ├── nature.css\n    │   ├── openstack_logo.png\n    │   └── tweaks.css\n    ├── _templates\n    └── _theme\n        ├── layout.html\n        └── theme.conf\n4 directories, 12 files\n</code></pre>\n\n<p>下面我们开始编译：</p>\n\n<pre><code>root@Compute2:~/oslo.config-1.1.0/doc/source# sphinx-build -b html ./ ./out\nMaking output directory...\nRunning Sphinx v1.1.3\nfatal: Not a git repository (or any of the parent directories): .git\nloading pickled environment... not yet created\nloading intersphinx inventory from http://docs.python.org/objects.inv...\nbuilding [html]: targets for 1 source files that are out of date\nupdating environment: 1 added, 0 changed, 0 removed\nreading sources... [100%] index                                                                                                                                                                                   \n/root/oslo.config-1.1.0/doc/source/index.rst:10: WARNING: toctree contains reference to nonexisting document u''api/autoindex''\nlooking for now-outdated files... none found\npickling environment... done\nchecking consistency... done\npreparing documents... done\nwriting output... [100%] index                                                                                                                                                                                    \nwriting additional files... genindex search\ncopying static files... done\ndumping search index... done\ndumping object inventory... done\nbuild succeeded, 1 warning.\n</code></pre>\n\n<p>最后我们打开out文件夹中的index.html，就如下所示了：是不是有点炫啊~~</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/sphinx-example.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/sphinx-example.jpg\" alt=\"sphinx-example\" width=\"649\" height=\"416\" class=\"aligncenter size-full wp-image-256\" /></a></p>\n\n<p>当然了，因为这个doc中暂时还没内容，所以这个网页目前是空的。</p>\n\n<h2>4 参考资料</h2>\n\n<p><a href=\"http://pygments.org/\">http://pygments.org/</a></p>\n','优雅的文档生成-Sphinx','','publish','open','open','','introduce-to-sphinx','','','2013-03-30 02:49:44','2013-03-29 18:49:44','','0','http://blog.wachang.net/?p=255','0','post','','0');");
E_D("replace into `wp_posts` values('256','1','2013-03-30 02:44:03','2013-03-29 18:44:03','','sphinx-example','','inherit','open','open','','sphinx-example','','','2013-03-30 02:44:03','2013-03-29 18:44:03','','255','http://blog.wachang.net/wp-content/uploads/2013/03/sphinx-example.jpg','0','attachment','image/jpeg','0');");
E_D("replace into `wp_posts` values('257','1','2013-03-30 02:47:42','2013-03-29 18:47:42','<p>最近看python一些模块文档的时候发现有doc目录，研究了一下发现两个关键字：一是Sphinx,二是pygments，为了能有更好的文档，于是研究下这两个东西,先说第一个sphinx。</p>\n\n<h2>1 什么是Sphinx</h2>\n\n<p>Sphinx是一个工具，她能够轻易地创建智慧和优雅的文档，她是出自Georg Brandl之手，在BSD许可证下授权。</p>\n\n<p>她最初是为了新版的python文档， 因此在python项目的文档具有完美的特性，但是同样支持c/c++，目前正在计划增加对其他的语言的支持。 理所当然，本页面也是使用Sphinx创造自reStructuredText格式源！Sphinx具有如下的特点：</p>\n\n<ul>\n<li>输出格式： 超文本标记语言 (包括Windows HTML帮助)，LaTeX (可打印的PDF版本)，手册页，纯文本</li>\n<li>丰富的交叉引用： 语义标记以及针对函数，类，引用，词汇表（术语）和相似的信息块的自动链接\n*　层次结构： 简单的文本树定义，就能自动地链接到同层（兄弟姐妹）、上一层（父母）以及下一层（子女）的文本位置\n*　自动生成目录： 通用索引以及语言模块的目录</li>\n<li>代码高亮： 代码自动高亮，通过使用 Pygments</li>\n<li>扩展功能： 自动测试的代码片段，包括从Python模块（API文档）的文档字符串</li>\n</ul>\n\n<p>Sphinx 使用reStructuredText作为她的标记语言，她的优点大部分是来自于reStructuredText 以及reStructuredText的解析和转换工具（套件）Docutils的强大以及简单明了。</p>\n\n<p>说白了,他就是把reStructuredText文本文档翻译成一些文件格式,类似PDF啊之类的工具,正如我的博客上用的wp-markdown插件能把markdown标记语言写的文章转换成合适的html文档一样。</p>\n\n<p>换一种方式，和编译C程序一样，sphinx可以看成是gcc等编译器，负责把源码（reStructuredText）格式的文档编译成相应的PDF或者html的文件。</p>\n\n<!--more-->\n\n<h2>2 安装</h2>\n\n<p>Sphinx的主页是<a href=\"http://sphinx-doc.org/index.html\">http://sphinx-doc.org/index.html</a>,中文站点<a href=\"http://www.pythondoc.com/sphinx/index.html\">http://www.pythondoc.com/sphinx/index.html</a></p>\n\n<p>在Ubuntu下可以直接apt安装：</p>\n\n<pre><code>apt-get install python-sphinx\n</code></pre>\n\n<p>也可以使用：</p>\n\n<pre><code>easy_install -U Sphinx\n</code></pre>\n\n<p>或者在<a href=\"https://pypi.python.org/pypi/Sphinx\">https://pypi.python.org/pypi/Sphinx</a>下载安装。</p>\n\n<p>每个文档工程的源码里面有一个conf.py文件，主要是关于文档如何生成等参数配置。可以自己学习。下面我们做一个简单的例子。</p>\n\n<h2>3 如何使用</h2>\n\n<p>首先我们下载一个olso的python库，这个主要是配置文件解析的，OpenStack中用，不用懂其详细语法，下载完以后解压，可以看到doc目录：</p>\n\n<pre><code>root@Compute2:~/oslo.config-1.1.0/doc# tree\n.\n└── source\n    ├── conf.py\n    ├── index.rst\n    ├── static\n    │   ├── basic.css\n    │   ├── default.css\n    │   ├── header_bg.jpg\n    │   ├── header-line.gif\n    │   ├── jquery.tweet.js\n    │   ├── nature.css\n    │   ├── openstack_logo.png\n    │   └── tweaks.css\n    ├── _templates\n    └── _theme\n        ├── layout.html\n        └── theme.conf\n4 directories, 12 files\n</code></pre>\n\n<p>下面我们开始编译：</p>\n\n<pre><code>root@Compute2:~/oslo.config-1.1.0/doc/source# sphinx-build -b html ./ ./out\nMaking output directory...\nRunning Sphinx v1.1.3\nfatal: Not a git repository (or any of the parent directories): .git\nloading pickled environment... not yet created\nloading intersphinx inventory from http://docs.python.org/objects.inv...\nbuilding [html]: targets for 1 source files that are out of date\nupdating environment: 1 added, 0 changed, 0 removed\nreading sources... [100%] index                                                                                                                                                                                   \n/root/oslo.config-1.1.0/doc/source/index.rst:10: WARNING: toctree contains reference to nonexisting document u''api/autoindex''\nlooking for now-outdated files... none found\npickling environment... done\nchecking consistency... done\npreparing documents... done\nwriting output... [100%] index                                                                                                                                                                                    \nwriting additional files... genindex search\ncopying static files... done\ndumping search index... done\ndumping object inventory... done\nbuild succeeded, 1 warning.\n</code></pre>\n\n<p>最后我们打开out文件夹中的index.html，就如下所示了：是不是有点炫啊~~</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/sphinx-example.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/sphinx-example.jpg\" alt=\"sphinx-example\" width=\"649\" height=\"416\" class=\"aligncenter size-full wp-image-256\" /></a></p>\n\n<p>当然了，因为这个doc中暂时还没内容，所以这个网页目前是空的。</p>\n\n<h2>4 参考资料：</h2>\n\n<p>http://pygments.org/</p>\n','优雅的文档生成-Sphinx','','inherit','open','open','','255-revision','','','2013-03-30 02:47:42','2013-03-29 18:47:42','','255','http://blog.wachang.net/2013/03/255-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('258','1','2013-03-30 02:48:35','2013-03-29 18:48:35','<p>最近看python一些模块文档的时候发现有doc目录，研究了一下发现两个关键字：一是Sphinx,二是pygments，为了能有更好的文档，于是研究下这两个东西,先说第一个sphinx。</p>\n\n<h2>1 什么是Sphinx</h2>\n\n<p>Sphinx是一个工具，她能够轻易地创建智慧和优雅的文档，她是出自Georg Brandl之手，在BSD许可证下授权。</p>\n\n<p>她最初是为了新版的python文档， 因此在python项目的文档具有完美的特性，但是同样支持c/c++，目前正在计划增加对其他的语言的支持。 Sphinx具有如下的特点：</p>\n\n<ul>\n<li>输出格式： 超文本标记语言 (包括Windows HTML帮助)，LaTeX (可打印的PDF版本)，手册页，纯文本</li>\n<li>丰富的交叉引用： 语义标记以及针对函数，类，引用，词汇表（术语）和相似的信息块的自动链接\n*　层次结构： 简单的文本树定义，就能自动地链接到同层（兄弟姐妹）、上一层（父母）以及下一层（子女）的文本位置\n*　自动生成目录： 通用索引以及语言模块的目录</li>\n<li>代码高亮： 代码自动高亮，通过使用 Pygments</li>\n<li>扩展功能： 自动测试的代码片段，包括从Python模块（API文档）的文档字符串</li>\n</ul>\n\n<p>Sphinx 使用reStructuredText作为她的标记语言，她的优点大部分是来自于reStructuredText 以及reStructuredText的解析和转换工具（套件）Docutils的强大以及简单明了。</p>\n\n<p>说白了,他就是把reStructuredText文本文档翻译成一些文件格式,类似PDF啊之类的工具,正如我的博客上用的wp-markdown插件能把markdown标记语言写的文章转换成合适的html文档一样。</p>\n\n<p>换一种方式，和编译C程序一样，sphinx可以看成是gcc等编译器，负责把源码（reStructuredText）格式的文档编译成相应的PDF或者html的文件。</p>\n\n<!--more-->\n\n<h2>2 安装</h2>\n\n<p>Sphinx的主页是<a href=\"http://sphinx-doc.org/index.html\">http://sphinx-doc.org/index.html</a>,中文站点<a href=\"http://www.pythondoc.com/sphinx/index.html\">http://www.pythondoc.com/sphinx/index.html</a></p>\n\n<p>在Ubuntu下可以直接apt安装：</p>\n\n<pre><code>apt-get install python-sphinx\n</code></pre>\n\n<p>也可以使用：</p>\n\n<pre><code>easy_install -U Sphinx\n</code></pre>\n\n<p>或者在<a href=\"https://pypi.python.org/pypi/Sphinx\">https://pypi.python.org/pypi/Sphinx</a>下载安装。</p>\n\n<p>每个文档工程的源码里面有一个conf.py文件，主要是关于文档如何生成等参数配置。可以自己学习。下面我们做一个简单的例子。</p>\n\n<h2>3 如何使用</h2>\n\n<p>首先我们下载一个olso的python库，这个主要是配置文件解析的，OpenStack中用，不用懂其详细语法，下载完以后解压，可以看到doc目录：</p>\n\n<pre><code>root@Compute2:~/oslo.config-1.1.0/doc# tree\n.\n└── source\n    ├── conf.py\n    ├── index.rst\n    ├── static\n    │   ├── basic.css\n    │   ├── default.css\n    │   ├── header_bg.jpg\n    │   ├── header-line.gif\n    │   ├── jquery.tweet.js\n    │   ├── nature.css\n    │   ├── openstack_logo.png\n    │   └── tweaks.css\n    ├── _templates\n    └── _theme\n        ├── layout.html\n        └── theme.conf\n4 directories, 12 files\n</code></pre>\n\n<p>下面我们开始编译：</p>\n\n<pre><code>root@Compute2:~/oslo.config-1.1.0/doc/source# sphinx-build -b html ./ ./out\nMaking output directory...\nRunning Sphinx v1.1.3\nfatal: Not a git repository (or any of the parent directories): .git\nloading pickled environment... not yet created\nloading intersphinx inventory from http://docs.python.org/objects.inv...\nbuilding [html]: targets for 1 source files that are out of date\nupdating environment: 1 added, 0 changed, 0 removed\nreading sources... [100%] index                                                                                                                                                                                   \n/root/oslo.config-1.1.0/doc/source/index.rst:10: WARNING: toctree contains reference to nonexisting document u''api/autoindex''\nlooking for now-outdated files... none found\npickling environment... done\nchecking consistency... done\npreparing documents... done\nwriting output... [100%] index                                                                                                                                                                                    \nwriting additional files... genindex search\ncopying static files... done\ndumping search index... done\ndumping object inventory... done\nbuild succeeded, 1 warning.\n</code></pre>\n\n<p>最后我们打开out文件夹中的index.html，就如下所示了：是不是有点炫啊~~</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/sphinx-example.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/sphinx-example.jpg\" alt=\"sphinx-example\" width=\"649\" height=\"416\" class=\"aligncenter size-full wp-image-256\" /></a></p>\n\n<p>当然了，因为这个doc中暂时还没内容，所以这个网页目前是空的。</p>\n\n<h2>4 参考资料：</h2>\n\n<p>http://pygments.org/</p>\n','优雅的文档生成-Sphinx','','inherit','open','open','','255-revision-2','','','2013-03-30 02:48:35','2013-03-29 18:48:35','','255','http://blog.wachang.net/2013/03/255-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('259','1','2013-03-30 14:33:04','0000-00-00 00:00:00','<blockquote>\n  <p>浅出OpenStack源码系列</p>\n  \n  <p>OpenStack中的配置解析Oslo(cfg)模块</p>\n</blockquote>\n\n<p>OpenStack中原来有个cfg模块，主要是做<code>命令行参数解析以及各个组件的配置文件读取解析</code>的，最新的OpenStack对cfg进行了一个整合，统一开发出了oslo模块，这样在各个组件中都通用使用这一个模块。下面我们就进行相关的学习。</p>\n\n<p>首先所有的配置，不管是命令行参数还是配置文件中的参数，都叫做一个Option,OpenStack中定义了一个最基本的类：class Option()</p>\n','OpenStack中的配置解析Oslo(cfg)模块','','draft','open','open','','','','','2013-03-30 14:33:04','2013-03-30 06:33:04','','0','http://blog.wachang.net/?p=259','0','post','','0');");
E_D("replace into `wp_posts` values('260','1','2013-03-30 13:38:58','2013-03-30 05:38:58','<blockquote>\n  <p>浅出OpenStack源码系列</p>\n  \n  <p>OpenStack中的配置解析Oslo(cfg)模块</p>\n</blockquote>\n\n<p>OpenStack中原来有个cfg模块，主要是做<code>命令行参数解析以及各个组件的配置文件读取解析</code>的，最新的OpenStack对cfg进行了一个整合，统一开发出了oslo模块，这样在各个组件中都通用使用这一个模块。下面我们就进行相关的学习。</p>\n\n<p>首先所有的配置，不管是命令行参数还是配置文件中的参数，都叫做一个Option,OpenStack中定义了一个最基本的类：class Option()</p>\n','OpenStack中的配置解析Oslo(cfg)模块','','inherit','open','open','','259-revision','','','2013-03-30 13:38:58','2013-03-30 05:38:58','','259','http://blog.wachang.net/2013/03/259-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('262','1','2013-03-30 22:29:25','2013-03-30 14:29:25','<blockquote>\n  <p>浅出OpenStack源码</p>\n  \n  <p>Quantum OpenvSwitch Plugin&amp;Agent读取配置文件</p>\n</blockquote>\n\n<p>本节主要说一下Quantum OpenvSwitch Plugin和Agent是如何处理配置文件的。如果以后你需要自己做基于Quantum的Plugin开发，那么本文就告诉你如何在配置文件中加入你自己的一些变量信息，然后可以正确的让OpenStack的相应组件进行解释并放在程序的变量中。</p>\n\n<p>开始之前，需要阅读一个OpenStack的配置文件处理部分的一些知识，请参考本系列OpenStack基础部分。我就直接以Agent为例进行分析了，这样简单一点，在Plugin端的流程也是一样的。</p>\n\n<!--more-->\n\n<h2>1 OpenvSwitch Agent的配置文件：</h2>\n\n<p>Quantum OpenvSwitch Agent一共需要解析quantum.conf文件以及ovs&#95;quantum&#95;plugin.ini文件，下面是配置文件的一个例子：</p>\n\n<pre><code>#Under the database section\n[DATABASE]\nsql_connection = mysql://quantumUser:quantumPass@100.10.10.51/quantum\n\n#Under the OVS section\n[OVS]\ntenant_network_type = gre\ntunnel_id_ranges = 1:1000\nintegration_bridge = br-int\ntunnel_bridge = br-tun\nlocal_ip = 100.10.10.53\nenable_tunneling = True\n</code></pre>\n\n<p>下面是quantum.conf的部分（agent其实只读这一段）</p>\n\n<pre><code>rabbit_host = 100.10.10.51\n</code></pre>\n\n<h2>2 如何解析配置文件</h2>\n\n<h3>2.1</h3>\n\n<p>首先，给个总览，同时也是一个回顾，要使得OpenStack里面组件，不管是plugin，还是agent或者其他需要解析配置文件参数的程序能获得相应的配置，需要以下几个步骤：</p>\n\n<ul>\n<li>1、创建一个一个配置管理器(通过import oslo.config完成)，一般名字都为CONF</li>\n<li>2、给这个配置管理器注册选项信息，通过CONF的register_opts方法。</li>\n<li>3、读取配置，通过CONF.xxxxx(你注册的配置信息的名字)访问值</li>\n</ul>\n\n<p>为什么要向配置管理器注册配置信息？因为配置管理器在读取配置文件的时候只会读注册配置信息的选项，比如我注册了一个选项名为name,加入到CONF中以后，在配置文件中配置管理器才会读取，而没注册的比如company就不会被读取到。当然，你注册的选项的名字和你在配置文件中这个新选项的名字是一样的，比如我注册了一个选项是name，那么配置文件中就应该是name=xxxxx这种。</p>\n\n<h3>2.2</h3>\n\n<p>以下就是Agent中的操作过程，可以结合理解。</p>\n\n<p>Agent源代码首先：</p>\n\n<pre><code>from oslo.config import cfg\n</code></pre>\n\n<p>import基本的oslo.config模块后，就会产生生成一个CONF实例，这就是一个配置管理器，因为在oslo.config的最后有一行：</p>\n\n<pre><code>CONF = ConfigOpt()\n</code></pre>\n\n<p>这是一个实例化操作，一个配置管理器的作用：</p>\n\n<ul>\n<li>注册配置参数（通过自己的API，就是实例的方法啦）</li>\n<li>读取配置文件</li>\n</ul>\n\n<p>接下来</p>\n\n<pre><code>from quantum.plugins.openvswitch.common import config\n</code></pre>\n\n<p>在这个文件中，你可以看到：</p>\n\n<pre><code>ovs_opts = [\ncfg.StrOpt(''integration_bridge'', default=''br-int'',\n           help=_(\"Integration bridge to use\")),\ncfg.BoolOpt(''enable_tunneling'', default=False,\n            help=_(\"Enable tunneling support\")),]\n</code></pre>\n\n<p>这是定义配置文件中有哪些选项，之后还有：</p>\n\n<pre><code>cfg.CONF.register_opts(ovs_opts, \"OVS\")\n</code></pre>\n\n<p>这就是对ovs&#95;quantum&#95;plugin.ini文件中的选项进行注册，其中，后面这个OVS表示选项所在的组是OVS，那么在配置文件中的表现就是，ovs_opts中所定义的选项都是位于OVS这个Section下的。参考上面的配置文件。</p>\n\n<p>当然，在这个config文件中，还import了几个模块，如下解释：</p>\n\n<pre><code>from quantum.plugins.openvswitch.common import config 作用如上解释\n     |（在上面的config文件中存在的import）\n     |from quantum.agent.common import config 主要定义了root_help以及agent有关的状态state\n         |（在上面的config文件中存在的import）\n         |form oslo.config import cfg\n         |from quantum.common import config 注册quantum核心选项，也就是quantum.conf中使用的选项\n</code></pre>\n\n<h2>3 解析</h2>\n\n<p>在2中可以看到，实际上整个配置管理器注册了大大类的选项，一个quantum.conf中用的叫做core&#95;opts，一种是ovs&#95;quantum&#95;plugin.ini中使用的ovs&#95;opts和agent_opts。接下来就是如何触发读取操作了，在Agent的main()函数中，有一个：</p>\n\n<pre><code>cfg.CONF(project=''quantum'')\n</code></pre>\n\n<p>这个不是实例化类哈，这是一个类的call方法的使用，这样以后cfg.CONF这个配置管理器就读取完配置文件了，之后你就可以获得配置文件中的值了，如下：</p>\n\n<pre><code>integ_br=config.OVS.integration_bridge\ntun_br=config.OVS.tunnel_bridge\nlocal_ip=config.OVS.local_ip\n</code></pre>\n','Quantum OpenvSwitch Plugin&Agent读取配置文件','','publish','open','open','','quantum-ovs-plugin-agent-config-file','','','2013-04-01 11:09:16','2013-04-01 03:09:16','','0','http://blog.wachang.net/?p=262','0','post','','1');");
E_D("replace into `wp_posts` values('263','1','2013-03-30 22:26:47','2013-03-30 14:26:47','<blockquote>\n  <p>浅出OpenStack源码</p>\n  \n  <p>Quantum OpenvSwitch Agent读取配置文件</p>\n</blockquote>\n\n<p>本节主要说一下Quantum OpenvSwitch Plugin的Agent是如何处理配置文件的。如果以后你需要自己做基于Quantum的Plugin开发，那么本文就告诉你如何在配置文件中加入你自己的一些变量信息，然后可以正确的让OpenStack的相应组件进行解释并放在程序的变量中。</p>\n\n<p>开始之前，需要阅读一个OpenStack的配置文件处理部分的一些知识，请参考本系列OpenStack基础部分。</p>\n\n<h2>1 OpenvSwitch Agent的配置文件：</h2>\n\n<p>Quantum OpenvSwitch Agent一共需要解析quantum.conf文件以及ovs_quantum_plugin.ini文件，下面是配置文件的一个例子：</p>\n\n<pre><code>#Under the database section\n[DATABASE]\nsql_connection = mysql://quantumUser:quantumPass@100.10.10.51/quantum\n\n#Under the OVS section\n[OVS]\ntenant_network_type = gre\ntunnel_id_ranges = 1:1000\nintegration_bridge = br-int\ntunnel_bridge = br-tun\nlocal_ip = 100.10.10.53\nenable_tunneling = True\n</code></pre>\n\n<p>下面是quantum.conf的部分（agent其实只读这一段）</p>\n\n<pre><code>rabbit_host = 100.10.10.51\n</code></pre>\n\n<h2>2 如何解析配置文件</h2>\n\n<h3>2.1</h3>\n\n<p>首先，给个总览，同时也是一个回顾，要使得OpenStack里面组件，不管是plugin，还是agent或者其他需要解析配置文件参数的程序能获得相应的配置，需要以下几个步骤：</p>\n\n<ul>\n<li>1、创建一个一个配置管理器(通过import oslo.config完成)，一般名字都为CONF</li>\n<li>2、给这个配置管理器注册选项信息，通过CONF的register_opts方法。</li>\n<li>3、读取配置，通过CONF.xxxxx(你注册的配置信息的名字)访问值</li>\n</ul>\n\n<p>为什么要向配置管理器注册配置信息？因为配置管理器在读取配置文件的时候只会读注册配置信息的选项，比如我注册了一个选项名为name,加入到CONF中以后，在配置文件中配置管理器才会读取，而没注册的比如company就不会被读取到。当然，你注册的选项的名字和你在配置文件中这个新选项的名字是一样的，比如我注册了一个选项是name，那么配置文件中就应该是name=xxxxx这种。</p>\n\n<h3>2.2</h3>\n\n<p>以下就是Agent中的操作过程，可以结合理解。</p>\n\n<p>Agent源代码首先：</p>\n\n<pre><code>from oslo.config import cfg\n</code></pre>\n\n<p>import基本的oslo.config模块后，就会产生生成一个CONF实例，这就是一个配置管理器，因为在oslo.config的最后有一行：</p>\n\n<pre><code>CONF = ConfigOpt()\n</code></pre>\n\n<p>这是一个实例化操作，一个配置管理器的作用：</p>\n\n<ul>\n<li>注册配置参数（通过自己的API，就是实例的方法啦）</li>\n<li>读取配置文件</li>\n</ul>\n\n<p>接下来</p>\n\n<pre><code>from quantum.plugins.openvswitch.common import config\n</code></pre>\n\n<p>在这个文件中，你可以看到：</p>\n\n<pre><code>ovs_opts = [\ncfg.StrOpt(''integration_bridge'', default=''br-int'',\n           help=_(\"Integration bridge to use\")),\ncfg.BoolOpt(''enable_tunneling'', default=False,\n            help=_(\"Enable tunneling support\")),]\n</code></pre>\n\n<p>这是定义配置文件中有哪些选项，之后还有：</p>\n\n<pre><code>cfg.CONF.register_opts(ovs_opts, \"OVS\")\n</code></pre>\n\n<p>这就是对选项进行注册，其中，后面这个OVS表示选项所在的组是OVS，那么在配置文件中的表现就是，ovs_opts中所定义的选项都是位于OVS这个Section下的。参考上面的配置文件。</p>\n\n<p>当然，在这个config文件中，还import了几个模块，如下解释：</p>\n\n<pre><code>from quantum.plugins.openvswitch.common import config 作用如上解释\n     |（在上面的config文件中存在的import）\n     |from quantum.agent.common import config 主要定义了root_help以及agent有关的状态state\n         |（在上面的config文件中存在的import）\n         |form oslo.config import cfg\n         |from quantum.common import config 注册quantum核心选项，也就是quantum.conf中使用的选项\n</code></pre>\n\n<h2>3 解析</h2>\n\n<p>在2中可以看到，实际上整个配置管理器注册了大大类的选项，一个quantum.conf中用的叫做core_opts，一种是ovs_quantum_plugin.ini中使用的ovs_opts和agent_opts。接下来就是如何触发读取操作了，在Agent的main()函数中，有一个：</p>\n\n<pre><code>cfg.CONF(project=''quantum'')\n</code></pre>\n\n<p>这个不是实例化类哈，这是一个类的call方法的使用，这样以后cfg.CONF这个配置管理器就读取完配置文件了，之后你就可以获得配置文件中的值了，如下：</p>\n\n<pre><code>integ_br=config.OVS.integration_bridge\ntun_br=config.OVS.tunnel_bridge\nlocal_ip=config.OVS.local_ip\n</code></pre>\n','Quantum OpenvSwitch Agent读取配置文件','','inherit','open','open','','262-revision','','','2013-03-30 22:26:47','2013-03-30 14:26:47','','262','http://blog.wachang.net/2013/03/262-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('264','1','2013-03-30 22:29:16','2013-03-30 14:29:16','<blockquote>\n  <p>浅出OpenStack源码</p>\n  \n  <p>Quantum OpenvSwitch Agent读取配置文件</p>\n</blockquote>\n\n<p>本节主要说一下Quantum OpenvSwitch Plugin的Agent是如何处理配置文件的。如果以后你需要自己做基于Quantum的Plugin开发，那么本文就告诉你如何在配置文件中加入你自己的一些变量信息，然后可以正确的让OpenStack的相应组件进行解释并放在程序的变量中。</p>\n\n<p>开始之前，需要阅读一个OpenStack的配置文件处理部分的一些知识，请参考本系列OpenStack基础部分。</p>\n\n<!--more-->\n\n<h2>1 OpenvSwitch Agent的配置文件：</h2>\n\n<p>Quantum OpenvSwitch Agent一共需要解析quantum.conf文件以及ovs&#95;quantum&#95;plugin.ini文件，下面是配置文件的一个例子：</p>\n\n<pre><code>#Under the database section\n[DATABASE]\nsql_connection = mysql://quantumUser:quantumPass@100.10.10.51/quantum\n\n#Under the OVS section\n[OVS]\ntenant_network_type = gre\ntunnel_id_ranges = 1:1000\nintegration_bridge = br-int\ntunnel_bridge = br-tun\nlocal_ip = 100.10.10.53\nenable_tunneling = True\n</code></pre>\n\n<p>下面是quantum.conf的部分（agent其实只读这一段）</p>\n\n<pre><code>rabbit_host = 100.10.10.51\n</code></pre>\n\n<h2>2 如何解析配置文件</h2>\n\n<h3>2.1</h3>\n\n<p>首先，给个总览，同时也是一个回顾，要使得OpenStack里面组件，不管是plugin，还是agent或者其他需要解析配置文件参数的程序能获得相应的配置，需要以下几个步骤：</p>\n\n<ul>\n<li>1、创建一个一个配置管理器(通过import oslo.config完成)，一般名字都为CONF</li>\n<li>2、给这个配置管理器注册选项信息，通过CONF的register_opts方法。</li>\n<li>3、读取配置，通过CONF.xxxxx(你注册的配置信息的名字)访问值</li>\n</ul>\n\n<p>为什么要向配置管理器注册配置信息？因为配置管理器在读取配置文件的时候只会读注册配置信息的选项，比如我注册了一个选项名为name,加入到CONF中以后，在配置文件中配置管理器才会读取，而没注册的比如company就不会被读取到。当然，你注册的选项的名字和你在配置文件中这个新选项的名字是一样的，比如我注册了一个选项是name，那么配置文件中就应该是name=xxxxx这种。</p>\n\n<h3>2.2</h3>\n\n<p>以下就是Agent中的操作过程，可以结合理解。</p>\n\n<p>Agent源代码首先：</p>\n\n<pre><code>from oslo.config import cfg\n</code></pre>\n\n<p>import基本的oslo.config模块后，就会产生生成一个CONF实例，这就是一个配置管理器，因为在oslo.config的最后有一行：</p>\n\n<pre><code>CONF = ConfigOpt()\n</code></pre>\n\n<p>这是一个实例化操作，一个配置管理器的作用：</p>\n\n<ul>\n<li>注册配置参数（通过自己的API，就是实例的方法啦）</li>\n<li>读取配置文件</li>\n</ul>\n\n<p>接下来</p>\n\n<pre><code>from quantum.plugins.openvswitch.common import config\n</code></pre>\n\n<p>在这个文件中，你可以看到：</p>\n\n<pre><code>ovs_opts = [\ncfg.StrOpt(''integration_bridge'', default=''br-int'',\n           help=_(\"Integration bridge to use\")),\ncfg.BoolOpt(''enable_tunneling'', default=False,\n            help=_(\"Enable tunneling support\")),]\n</code></pre>\n\n<p>这是定义配置文件中有哪些选项，之后还有：</p>\n\n<pre><code>cfg.CONF.register_opts(ovs_opts, \"OVS\")\n</code></pre>\n\n<p>这就是对选项进行注册，其中，后面这个OVS表示选项所在的组是OVS，那么在配置文件中的表现就是，ovs_opts中所定义的选项都是位于OVS这个Section下的。参考上面的配置文件。</p>\n\n<p>当然，在这个config文件中，还import了几个模块，如下解释：</p>\n\n<pre><code>from quantum.plugins.openvswitch.common import config 作用如上解释\n     |（在上面的config文件中存在的import）\n     |from quantum.agent.common import config 主要定义了root_help以及agent有关的状态state\n         |（在上面的config文件中存在的import）\n         |form oslo.config import cfg\n         |from quantum.common import config 注册quantum核心选项，也就是quantum.conf中使用的选项\n</code></pre>\n\n<h2>3 解析</h2>\n\n<p>在2中可以看到，实际上整个配置管理器注册了大大类的选项，一个quantum.conf中用的叫做core&#95;opts，一种是ovs&#95;quantum&#95;plugin.ini中使用的ovs&#95;opts和agent_opts。接下来就是如何触发读取操作了，在Agent的main()函数中，有一个：</p>\n\n<pre><code>cfg.CONF(project=''quantum'')\n</code></pre>\n\n<p>这个不是实例化类哈，这是一个类的call方法的使用，这样以后cfg.CONF这个配置管理器就读取完配置文件了，之后你就可以获得配置文件中的值了，如下：</p>\n\n<pre><code>integ_br=config.OVS.integration_bridge\ntun_br=config.OVS.tunnel_bridge\nlocal_ip=config.OVS.local_ip\n</code></pre>\n','Quantum OpenvSwitch Agent读取配置文件','','inherit','open','open','','262-revision-2','','','2013-03-30 22:29:16','2013-03-30 14:29:16','','262','http://blog.wachang.net/2013/03/262-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('265','1','2013-03-30 22:29:25','2013-03-30 14:29:25','<blockquote>\n  <p>浅出OpenStack源码</p>\n  \n  <p>Quantum OpenvSwitch Agent读取配置文件</p>\n</blockquote>\n\n<p>本节主要说一下Quantum OpenvSwitch Plugin的Agent是如何处理配置文件的。如果以后你需要自己做基于Quantum的Plugin开发，那么本文就告诉你如何在配置文件中加入你自己的一些变量信息，然后可以正确的让OpenStack的相应组件进行解释并放在程序的变量中。</p>\n\n<p>开始之前，需要阅读一个OpenStack的配置文件处理部分的一些知识，请参考本系列OpenStack基础部分。</p>\n\n<!--more-->\n\n<h2>1 OpenvSwitch Agent的配置文件：</h2>\n\n<p>Quantum OpenvSwitch Agent一共需要解析quantum.conf文件以及ovs&#95;quantum&#95;plugin.ini文件，下面是配置文件的一个例子：</p>\n\n<pre><code>#Under the database section\n[DATABASE]\nsql_connection = mysql://quantumUser:quantumPass@100.10.10.51/quantum\n\n#Under the OVS section\n[OVS]\ntenant_network_type = gre\ntunnel_id_ranges = 1:1000\nintegration_bridge = br-int\ntunnel_bridge = br-tun\nlocal_ip = 100.10.10.53\nenable_tunneling = True\n</code></pre>\n\n<p>下面是quantum.conf的部分（agent其实只读这一段）</p>\n\n<pre><code>rabbit_host = 100.10.10.51\n</code></pre>\n\n<h2>2 如何解析配置文件</h2>\n\n<h3>2.1</h3>\n\n<p>首先，给个总览，同时也是一个回顾，要使得OpenStack里面组件，不管是plugin，还是agent或者其他需要解析配置文件参数的程序能获得相应的配置，需要以下几个步骤：</p>\n\n<ul>\n<li>1、创建一个一个配置管理器(通过import oslo.config完成)，一般名字都为CONF</li>\n<li>2、给这个配置管理器注册选项信息，通过CONF的register_opts方法。</li>\n<li>3、读取配置，通过CONF.xxxxx(你注册的配置信息的名字)访问值</li>\n</ul>\n\n<p>为什么要向配置管理器注册配置信息？因为配置管理器在读取配置文件的时候只会读注册配置信息的选项，比如我注册了一个选项名为name,加入到CONF中以后，在配置文件中配置管理器才会读取，而没注册的比如company就不会被读取到。当然，你注册的选项的名字和你在配置文件中这个新选项的名字是一样的，比如我注册了一个选项是name，那么配置文件中就应该是name=xxxxx这种。</p>\n\n<h3>2.2</h3>\n\n<p>以下就是Agent中的操作过程，可以结合理解。</p>\n\n<p>Agent源代码首先：</p>\n\n<pre><code>from oslo.config import cfg\n</code></pre>\n\n<p>import基本的oslo.config模块后，就会产生生成一个CONF实例，这就是一个配置管理器，因为在oslo.config的最后有一行：</p>\n\n<pre><code>CONF = ConfigOpt()\n</code></pre>\n\n<p>这是一个实例化操作，一个配置管理器的作用：</p>\n\n<ul>\n<li>注册配置参数（通过自己的API，就是实例的方法啦）</li>\n<li>读取配置文件</li>\n</ul>\n\n<p>接下来</p>\n\n<pre><code>from quantum.plugins.openvswitch.common import config\n</code></pre>\n\n<p>在这个文件中，你可以看到：</p>\n\n<pre><code>ovs_opts = [\ncfg.StrOpt(''integration_bridge'', default=''br-int'',\n           help=_(\"Integration bridge to use\")),\ncfg.BoolOpt(''enable_tunneling'', default=False,\n            help=_(\"Enable tunneling support\")),]\n</code></pre>\n\n<p>这是定义配置文件中有哪些选项，之后还有：</p>\n\n<pre><code>cfg.CONF.register_opts(ovs_opts, \"OVS\")\n</code></pre>\n\n<p>这就是对选项进行注册，其中，后面这个OVS表示选项所在的组是OVS，那么在配置文件中的表现就是，ovs_opts中所定义的选项都是位于OVS这个Section下的。参考上面的配置文件。</p>\n\n<p>当然，在这个config文件中，还import了几个模块，如下解释：</p>\n\n<pre><code>from quantum.plugins.openvswitch.common import config 作用如上解释\n     |（在上面的config文件中存在的import）\n     |from quantum.agent.common import config 主要定义了root_help以及agent有关的状态state\n         |（在上面的config文件中存在的import）\n         |form oslo.config import cfg\n         |from quantum.common import config 注册quantum核心选项，也就是quantum.conf中使用的选项\n</code></pre>\n\n<h2>3 解析</h2>\n\n<p>在2中可以看到，实际上整个配置管理器注册了大大类的选项，一个quantum.conf中用的叫做core&#95;opts，一种是ovs&#95;quantum&#95;plugin.ini中使用的ovs&#95;opts和agent_opts。接下来就是如何触发读取操作了，在Agent的main()函数中，有一个：</p>\n\n<pre><code>cfg.CONF(project=''quantum'')\n</code></pre>\n\n<p>这个不是实例化类哈，这是一个类的call方法的使用，这样以后cfg.CONF这个配置管理器就读取完配置文件了，之后你就可以获得配置文件中的值了，如下：</p>\n\n<pre><code>integ_br=config.OVS.integration_bridge\ntun_br=config.OVS.tunnel_bridge\nlocal_ip=config.OVS.local_ip\n</code></pre>\n','Quantum OpenvSwitch Agent读取配置文件','','inherit','open','open','','262-revision-3','','','2013-03-30 22:29:25','2013-03-30 14:29:25','','262','http://blog.wachang.net/2013/03/262-revision-3/','0','revision','','0');");
E_D("replace into `wp_posts` values('266','1','2013-03-27 00:50:07','2013-03-26 16:50:07','<h1>浅出OpenStack源码系列</h1>\n\n<h2>2.Quantum篇</h2>\n\n<h3>2.3 OpenvSwitch Plugin</h3>\n\n<p><a href=\"http://blog.wachang.net/2013/03/quantum-ovs-plugin-code-structure/\">Quantum OpenvSwitch Plugin代码架构</a></p>\n\n<p><a href=\"http://blog.wachang.net/2013/03/quantum-ovs-plugin-agent-rpc-1/\">Quantum OpenvSwitch Plugin和Agent的RPC机制（一）</a></p>\n','浅出OpenStack源码','','inherit','open','open','','209-revision-3','','','2013-03-27 00:50:07','2013-03-26 16:50:07','','209','http://blog.wachang.net/2013/03/209-revision-3/','0','revision','','0');");
E_D("replace into `wp_posts` values('267','1','2013-04-01 11:08:47','2013-04-01 03:08:47','<blockquote>\n  <p>浅出OpenStack源码</p>\n  \n  <p>Quantum OpenvSwitch Plugin&amp;Agent读取配置文件</p>\n</blockquote>\n\n<p>本节主要说一下Quantum OpenvSwitch Plugin和Agent是如何处理配置文件的。如果以后你需要自己做基于Quantum的Plugin开发，那么本文就告诉你如何在配置文件中加入你自己的一些变量信息，然后可以正确的让OpenStack的相应组件进行解释并放在程序的变量中。</p>\n\n<p>开始之前，需要阅读一个OpenStack的配置文件处理部分的一些知识，请参考本系列OpenStack基础部分。我就直接以Agent为例进行分析了，这样简单一点，在Plugin端的流程也是一样的。</p>\n\n<!--more-->\n\n<h2>1 OpenvSwitch Agent的配置文件：</h2>\n\n<p>Quantum OpenvSwitch Agent一共需要解析quantum.conf文件以及ovs&#95;quantum&#95;plugin.ini文件，下面是配置文件的一个例子：</p>\n\n<pre><code>#Under the database section\n[DATABASE]\nsql_connection = mysql://quantumUser:quantumPass@100.10.10.51/quantum\n\n#Under the OVS section\n[OVS]\ntenant_network_type = gre\ntunnel_id_ranges = 1:1000\nintegration_bridge = br-int\ntunnel_bridge = br-tun\nlocal_ip = 100.10.10.53\nenable_tunneling = True\n</code></pre>\n\n<p>下面是quantum.conf的部分（agent其实只读这一段）</p>\n\n<pre><code>rabbit_host = 100.10.10.51\n</code></pre>\n\n<h2>2 如何解析配置文件</h2>\n\n<h3>2.1</h3>\n\n<p>首先，给个总览，同时也是一个回顾，要使得OpenStack里面组件，不管是plugin，还是agent或者其他需要解析配置文件参数的程序能获得相应的配置，需要以下几个步骤：</p>\n\n<ul>\n<li>1、创建一个一个配置管理器(通过import oslo.config完成)，一般名字都为CONF</li>\n<li>2、给这个配置管理器注册选项信息，通过CONF的register_opts方法。</li>\n<li>3、读取配置，通过CONF.xxxxx(你注册的配置信息的名字)访问值</li>\n</ul>\n\n<p>为什么要向配置管理器注册配置信息？因为配置管理器在读取配置文件的时候只会读注册配置信息的选项，比如我注册了一个选项名为name,加入到CONF中以后，在配置文件中配置管理器才会读取，而没注册的比如company就不会被读取到。当然，你注册的选项的名字和你在配置文件中这个新选项的名字是一样的，比如我注册了一个选项是name，那么配置文件中就应该是name=xxxxx这种。</p>\n\n<h3>2.2</h3>\n\n<p>以下就是Agent中的操作过程，可以结合理解。</p>\n\n<p>Agent源代码首先：</p>\n\n<pre><code>from oslo.config import cfg\n</code></pre>\n\n<p>import基本的oslo.config模块后，就会产生生成一个CONF实例，这就是一个配置管理器，因为在oslo.config的最后有一行：</p>\n\n<pre><code>CONF = ConfigOpt()\n</code></pre>\n\n<p>这是一个实例化操作，一个配置管理器的作用：</p>\n\n<ul>\n<li>注册配置参数（通过自己的API，就是实例的方法啦）</li>\n<li>读取配置文件</li>\n</ul>\n\n<p>接下来</p>\n\n<pre><code>from quantum.plugins.openvswitch.common import config\n</code></pre>\n\n<p>在这个文件中，你可以看到：</p>\n\n<pre><code>ovs_opts = [\ncfg.StrOpt(''integration_bridge'', default=''br-int'',\n           help=_(\"Integration bridge to use\")),\ncfg.BoolOpt(''enable_tunneling'', default=False,\n            help=_(\"Enable tunneling support\")),]\n</code></pre>\n\n<p>这是定义配置文件中有哪些选项，之后还有：</p>\n\n<pre><code>cfg.CONF.register_opts(ovs_opts, \"OVS\")\n</code></pre>\n\n<p>这就是对ovs&#95;quantum&#95;plugin.ini文件中的选项进行注册，其中，后面这个OVS表示选项所在的组是OVS，那么在配置文件中的表现就是，ovs_opts中所定义的选项都是位于OVS这个Section下的。参考上面的配置文件。</p>\n\n<p>当然，在这个config文件中，还import了几个模块，如下解释：</p>\n\n<pre><code>from quantum.plugins.openvswitch.common import config 作用如上解释\n     |（在上面的config文件中存在的import）\n     |from quantum.agent.common import config 主要定义了root_help以及agent有关的状态state\n         |（在上面的config文件中存在的import）\n         |form oslo.config import cfg\n         |from quantum.common import config 注册quantum核心选项，也就是quantum.conf中使用的选项\n</code></pre>\n\n<h2>3 解析</h2>\n\n<p>在2中可以看到，实际上整个配置管理器注册了大大类的选项，一个quantum.conf中用的叫做core&#95;opts，一种是ovs&#95;quantum&#95;plugin.ini中使用的ovs&#95;opts和agent_opts。接下来就是如何触发读取操作了，在Agent的main()函数中，有一个：</p>\n\n<pre><code>cfg.CONF(project=''quantum'')\n</code></pre>\n\n<p>这个不是实例化类哈，这是一个类的call方法的使用，这样以后cfg.CONF这个配置管理器就读取完配置文件了，之后你就可以获得配置文件中的值了，如下：</p>\n\n<pre><code>integ_br=config.OVS.integration_bridge\ntun_br=config.OVS.tunnel_bridge\nlocal_ip=config.OVS.local_ip\n</code></pre>\n','Quantum OpenvSwitch Plugin&Agent读取配置文件','','inherit','open','open','','262-autosave','','','2013-04-01 11:08:47','2013-04-01 03:08:47','','262','http://blog.wachang.net/2013/04/262-autosave/','0','revision','','0');");
E_D("replace into `wp_posts` values('268','1','2013-03-30 22:31:51','2013-03-30 14:31:51','<blockquote>\n  <p>浅出OpenStack源码</p>\n  \n  <p>Quantum OpenvSwitch Agent读取配置文件</p>\n</blockquote>\n\n<p>本节主要说一下Quantum OpenvSwitch Plugin的Agent是如何处理配置文件的。如果以后你需要自己做基于Quantum的Plugin开发，那么本文就告诉你如何在配置文件中加入你自己的一些变量信息，然后可以正确的让OpenStack的相应组件进行解释并放在程序的变量中。</p>\n\n<p>开始之前，需要阅读一个OpenStack的配置文件处理部分的一些知识，请参考本系列OpenStack基础部分。</p>\n\n<!--more-->\n\n<h2>1 OpenvSwitch Agent的配置文件：</h2>\n\n<p>Quantum OpenvSwitch Agent一共需要解析quantum.conf文件以及ovs&#95;quantum&#95;plugin.ini文件，下面是配置文件的一个例子：</p>\n\n<pre><code>#Under the database section\n[DATABASE]\nsql_connection = mysql://quantumUser:quantumPass@100.10.10.51/quantum\n\n#Under the OVS section\n[OVS]\ntenant_network_type = gre\ntunnel_id_ranges = 1:1000\nintegration_bridge = br-int\ntunnel_bridge = br-tun\nlocal_ip = 100.10.10.53\nenable_tunneling = True\n</code></pre>\n\n<p>下面是quantum.conf的部分（agent其实只读这一段）</p>\n\n<pre><code>rabbit_host = 100.10.10.51\n</code></pre>\n\n<h2>2 如何解析配置文件</h2>\n\n<h3>2.1</h3>\n\n<p>首先，给个总览，同时也是一个回顾，要使得OpenStack里面组件，不管是plugin，还是agent或者其他需要解析配置文件参数的程序能获得相应的配置，需要以下几个步骤：</p>\n\n<ul>\n<li>1、创建一个一个配置管理器(通过import oslo.config完成)，一般名字都为CONF</li>\n<li>2、给这个配置管理器注册选项信息，通过CONF的register_opts方法。</li>\n<li>3、读取配置，通过CONF.xxxxx(你注册的配置信息的名字)访问值</li>\n</ul>\n\n<p>为什么要向配置管理器注册配置信息？因为配置管理器在读取配置文件的时候只会读注册配置信息的选项，比如我注册了一个选项名为name,加入到CONF中以后，在配置文件中配置管理器才会读取，而没注册的比如company就不会被读取到。当然，你注册的选项的名字和你在配置文件中这个新选项的名字是一样的，比如我注册了一个选项是name，那么配置文件中就应该是name=xxxxx这种。</p>\n\n<h3>2.2</h3>\n\n<p>以下就是Agent中的操作过程，可以结合理解。</p>\n\n<p>Agent源代码首先：</p>\n\n<pre><code>from oslo.config import cfg\n</code></pre>\n\n<p>import基本的oslo.config模块后，就会产生生成一个CONF实例，这就是一个配置管理器，因为在oslo.config的最后有一行：</p>\n\n<pre><code>CONF = ConfigOpt()\n</code></pre>\n\n<p>这是一个实例化操作，一个配置管理器的作用：</p>\n\n<ul>\n<li>注册配置参数（通过自己的API，就是实例的方法啦）</li>\n<li>读取配置文件</li>\n</ul>\n\n<p>接下来</p>\n\n<pre><code>from quantum.plugins.openvswitch.common import config\n</code></pre>\n\n<p>在这个文件中，你可以看到：</p>\n\n<pre><code>ovs_opts = [\ncfg.StrOpt(''integration_bridge'', default=''br-int'',\n           help=_(\"Integration bridge to use\")),\ncfg.BoolOpt(''enable_tunneling'', default=False,\n            help=_(\"Enable tunneling support\")),]\n</code></pre>\n\n<p>这是定义配置文件中有哪些选项，之后还有：</p>\n\n<pre><code>cfg.CONF.register_opts(ovs_opts, \"OVS\")\n</code></pre>\n\n<p>这就是对ovs_quantum_plugin.ini文件中的选项进行注册，其中，后面这个OVS表示选项所在的组是OVS，那么在配置文件中的表现就是，ovs_opts中所定义的选项都是位于OVS这个Section下的。参考上面的配置文件。</p>\n\n<p>当然，在这个config文件中，还import了几个模块，如下解释：</p>\n\n<pre><code>from quantum.plugins.openvswitch.common import config 作用如上解释\n     |（在上面的config文件中存在的import）\n     |from quantum.agent.common import config 主要定义了root_help以及agent有关的状态state\n         |（在上面的config文件中存在的import）\n         |form oslo.config import cfg\n         |from quantum.common import config 注册quantum核心选项，也就是quantum.conf中使用的选项\n</code></pre>\n\n<h2>3 解析</h2>\n\n<p>在2中可以看到，实际上整个配置管理器注册了大大类的选项，一个quantum.conf中用的叫做core&#95;opts，一种是ovs&#95;quantum&#95;plugin.ini中使用的ovs&#95;opts和agent_opts。接下来就是如何触发读取操作了，在Agent的main()函数中，有一个：</p>\n\n<pre><code>cfg.CONF(project=''quantum'')\n</code></pre>\n\n<p>这个不是实例化类哈，这是一个类的call方法的使用，这样以后cfg.CONF这个配置管理器就读取完配置文件了，之后你就可以获得配置文件中的值了，如下：</p>\n\n<pre><code>integ_br=config.OVS.integration_bridge\ntun_br=config.OVS.tunnel_bridge\nlocal_ip=config.OVS.local_ip\n</code></pre>\n','Quantum OpenvSwitch Agent读取配置文件','','inherit','open','open','','262-revision-4','','','2013-03-30 22:31:51','2013-03-30 14:31:51','','262','http://blog.wachang.net/2013/03/262-revision-4/','0','revision','','0');");
E_D("replace into `wp_posts` values('269','1','2013-03-30 22:33:05','2013-03-30 14:33:05','<h1>浅出OpenStack源码系列</h1>\n\n<h2>2.Quantum篇</h2>\n\n<h3>2.3 OpenvSwitch Plugin</h3>\n\n<p><a href=\"http://blog.wachang.net/2013/03/quantum-ovs-plugin-code-structure/\">Quantum OpenvSwitch Plugin代码架构</a></p>\n\n<p><a href=\"http://blog.wachang.net/2013/03/quantum-ovs-agent-config-file/\">Quantum OpenvSwitch Agent读取配置文件</a></p>\n\n<p><a href=\"http://blog.wachang.net/2013/03/quantum-ovs-plugin-agent-rpc-1/\">Quantum OpenvSwitch Plugin和Agent的RPC机制（一）</a></p>\n','浅出OpenStack源码','','inherit','open','open','','209-revision-4','','','2013-03-30 22:33:05','2013-03-30 14:33:05','','209','http://blog.wachang.net/2013/03/209-revision-4/','0','revision','','0');");
E_D("replace into `wp_posts` values('270','1','2013-04-01 13:38:51','2013-04-01 05:38:51','<blockquote>\n  <p>浅出OpenStack源码系列</p>\n  \n  <p>Python模块基础篇：Python.Paste指南之Deploy(1)-概念</p>\n</blockquote>\n\n<p>Paste.Deploy主要是用来载入WSGI中的Web App使用，所谓WSGI的app，就是用来处理客户端发送过来的请求的，Python.Paste的核心函数是loadapp(),下文中PD就指代Paste.Deploy。</p>\n\n<h2>1 简介及安装</h2>\n\n<p>Paste Deployment是一种机制，通过loadapp函数和一个配置文件或者egg包来载入WSGI应用。安装很简单，如下两种方式：</p>\n\n<pre><code>\$ sudo pip install PasteDeploy\n</code></pre>\n\n<p>或者可以从github上进行源码安装</p>\n\n<pre><code>\$ hg clone http://bitbucket.org/ianb/pastedeploy\n\$ cd pastedeploy\n\$ sudo python setup.py develop\n</code></pre>\n\n<!--more-->\n\n<h2>2 配置文件Config Flie</h2>\n\n<p>一个配置文件后缀为ini，内容被分为很多段（section），PD只关心带有前缀的段，比如<code>[app:main]</code>或者<code>[filter:errors]</code>，总的来说，一个section的标识就是<code>[type:name]</code>,不是这种类型的section将会被忽略。</p>\n\n<p>一个section的内容是以<code>键=值</code>来标示的。#是一个注释。在段的定义中，有以下几类：</p>\n\n<ul>\n<li><p>[app:main]:定义WSGI应用，main表示只有一个应用，有多个应用的话main改为应用名字</p></li>\n<li><p>[server:main]:定义WSGI的一个server。</p></li>\n<li><p>[composite:xxx]：表示需要将一个请求调度定向（dispatched）到多个,或者多种应用上。以下是一个简单的例子，例子中，使用了composite，通过urlmap来实现载入多应用。</p></li>\n<li><p>[fliter:]：定义“过滤器”，将应用进行进一步的封装。</p></li>\n<li><p>[DEFAULT]：定义一些默认变量的值。</p></li>\n</ul>\n\n<p>以下是一个例子：</p>\n\n<pre><code>[composite:main]\nuse = egg:Paste#urlmap\n/ = home\n/blog = blog\n/wiki = wiki\n/cms = config:cms.ini\n\n[app:home]\nuse = egg:Paste#static\ndocument_root = %(here)s/htdocs\n\n[filter-app:blog]\nuse = egg:Authentication#auth\nnext = blogapp\nroles = admin\nhtpasswd = /home/me/users.htpasswd\n\n[app:blogapp]\nuse = egg:BlogApp\ndatabase = sqlite:/home/me/blog.db\n\n[app:wiki]\nuse = call:mywiki.main:application\ndatabase = sqlite:/home/me/wiki.db\n</code></pre>\n\n<p>下面会进行分段的讲解</p>\n\n<h3>2.1 composite</h3>\n\n<pre><code>[composite:main]\nuse = egg:Paste#urlmap\n/ = home\n/blog = blog\n/wiki = wiki\n/cms = config:cms.ini\n</code></pre>\n\n<p>这是一个composite段，表示这将会根据一些条件将web请求调度到不同的应用。<code>use = egg:Paste#urlmap</code>表示我们奖使用<code>Paste</code>egg包中<code>urlmap</code>来实现composite，这一个段(urlmap)可以算是一个通用的composite程序了。根据web请求的path的前缀进行一个到应用的映射(map)。这些被映射的程序就包括blog,home,wiki,config:cms.ini（映射到了另外一个配置文件，PD再根据这个文件进行载入）</p>\n\n<h3>2.2 App type1</h3>\n\n<pre><code>[app:home]\nuse = egg:Paste#static\ndocument_root = %(here)s/htdocs\n</code></pre>\n\n<p>app是一个callable object，接受的参数(environ,start&#95;response)，这是paste系统交给application的，符合WSGI规范的参数. app需要完成的任务是响应envrion中的请求，准备好响应头和消息体，然后交给start&#95;response处理，并返回响应消息体。<code>egg:Paste#static</code>也是Paste包中的一个简单程序，它只处理静态文件。它需要一个配置文件document_root,后面的值可以是一个变量,形式为%（var）s相应的值应该在[DEFAULT]字段指明以便Paste读取。比如：</p>\n\n<pre><code>[app:test]\nuse = egg:Paste#static\ndocument_root = %(path)s/htdocs\n[DEFAULT]\npath = /etc/test\n</code></pre>\n\n<h3>2.3 fliter</h3>\n\n<p>filter是一个callable object，其唯一参数是(app)，这是WSGI的application对象，filter需要完成的工作是将application包装成另一个application（“过滤”），并返回这个包装后的application。</p>\n\n<pre><code>[filter-app:blog]\nuse = egg:Authentication#auth\nnext = blogapp\nroles = admin\nhtpasswd = /home/me/users.htpasswd\n\n[app:blogapp]\nuse = egg:BlogApp\ndatabase = sqlite:/home/me/blog.db\n</code></pre>\n\n<p><code>[filter-app:blog]</code>fliter-app字段表明你希望对某个应用进行包装，需要包装的应用通过next指明（表明在下一个段中），这个字段的意思就是，在正式调用blogapp之前，我会调用egg:Authentication#auth进行一个用户的验证，随后才会调用blogapp进行处理。后面的[app:blogapp]则是定义了blogapp，并指明了需要的database参数。</p>\n\n<h3>2.4 App type2</h3>\n\n<pre><code>[app:wiki]\nuse = call:mywiki.main:application\ndatabase = sqlite:/home/me/wiki.db\n</code></pre>\n\n<p>这个段和之前的app段定义类似，不同的是对于wiki这个应用，我们没有使用egg包，而是直接对mywiki.main这个模块中的application对象使用了call方法。python，中一切皆对象，作为WSGI app的可以是一个函数，一个类，或者一个实例，使用call的话，相应的函数，类，实例中必须实现<strong>call</strong>()方法。此类app的格式用冒号分割: <code>call(表示使用call方法):模块的完成路径名字:应用变量的完整名字</code></p>\n\n<h2>3 基本使用</h2>\n\n<p>PD的主要使用就是通过读取配置文件载入WSGI应用。如下：</p>\n\n<pre><code>from paste.deploy import loadapp\nwsgi_app = loadapp(''config:/path/to/config.ini'')\n</code></pre>\n\n<p>注意，这里需要指明绝对路径。</p>\n\n<h2>4 更多关于配置文件</h2>\n\n<h3>4.1 App</h3>\n\n<p>单个配置文件中可以定义多个应用个，每个应用有自己独立的段。应用的定义以[app:name]的格式，[app:main]表示只有一个应用。应用的定义支持以下五种格式：</p>\n\n<pre><code>[app:myapp]\nuse = config:another_config_file.ini#app_name\n#使用另外一个配置文件\n\n[app:myotherapp]\nuse = egg:MyApp\n#使用egg包中的内容\n\n[app:mythirdapp]\nuse = call:my.project:myapplication\n#使用模块中的callable对象\n\n[app:mylastapp]\nuse = myotherapp\n#使用另外一个section\n\n[app:myfacapp]\npaste.app_factory = myapp.modulename:app_factory\n#使用工厂函数\n</code></pre>\n\n<p>其中，最后一种方式，将一个app指向了某些python代码。此模式下，必须执行app协议，以app&#95;factory表示，后面的值需要import的东西，在这个例子中myapp.modulename被载入，并从其中取得了app&#95;factory的实例。</p>\n\n<p>app_factory是一个callable object，其接受的参数是一些关于application的配置信息：<code>(global_conf,**kwargs)</code>，<code>global_conf</code>是在ini文件中default section中定义的一系列key-value对，而<code>**kwargs</code>，即一些本地配置，是在ini文件中，app:xxx section中定义的一系列key-value对。app_factory返回值是一个application对象</p>\n\n<p>在app的配置中，use参数以后配置就算结束了。其余的键值参数将会作为参数，传递到factory中，如下：</p>\n\n<pre><code>[app:blog]\nuse = egg:MyBlog\ndatabase = mysql://localhost/blogdb #这是参数\nblogname = This Is My Blog! #这是参数\n</code></pre>\n\n<h3>4.2 全局配置</h3>\n\n<p>全局配置主要是用于多个应用共用一些变量，这些变量我们规定放在段[DEFAULT]中，如果需要覆盖，可以在自己的app中重新定义，如下：</p>\n\n<pre><code>[DEFAULT]\nadmin_email = webmaster@example.com\n[app:main]\nuse = ...\nset admin_email = bob@example.com\n</code></pre>\n\n<h3>4.3 composite app</h3>\n\n<p>composite是一个运行着像是app，但是实际上是由多个应用组成的。urlmap就是composite app的一个例子，url不同的path对应了不同的应用。如下：</p>\n\n<pre><code>[composite:main]\nuse = egg:Paste#urlmap\n/ = mainapp\n/files = staticapp\n\n[app:mainapp]\nuse = egg:MyApp\n\n[app:staticapp]\nuse = egg:Paste#static\ndocument_root = /path/to/docroot\n</code></pre>\n\n<p>在loadapp函数的执行中，composite app被实例化，它同时还会访问配置文件中定义的其他应用。</p>\n\n<h3>4.4 app定义高级用法</h3>\n\n<p>在app段中，你可以定义fliters和servers，通过<code>fliter:</code>和<code>server:</code> PD通过loadserver和loadfilter函数进行调用，工作机制都一样，返回不同的对象。</p>\n\n<h4>4.4.1 filter composition</h4>\n\n<p>应用filter的方式很多，重要的是看你filter的数量和组织形式。下面会一一介绍应用fliter的几种方式：</p>\n\n<p>1.使用<code>filter-with</code></p>\n\n<pre><code>[app:main]\nuse = egg:MyEgg\nfilter-with = printdebug\n\n[filter:printdebug]\nuse = egg:Paste#printdebug\n# and you could have another filter-with here, and so on...\n</code></pre>\n\n<p>2.使用<code>fliter-app</code></p>\n\n<pre><code>[fliter-app:printdebug]\nuse = egg:Paste\nnext = main\n\n[app:main]\nuse = egg:MyEgg\n</code></pre>\n\n<p>3.使用pipeline</p>\n\n<p>当使用多个filter的时候需要使用pipeline的方式，它需要提供一个key参数pipeline,后面的值是一个列表，最后以应用结尾。如下：</p>\n\n<pre><code>[pipeline:main]\npipeline = filter1 egg:FilterEgg#filter2 filter3 app\n\n[filter:filter1]\n...\n</code></pre>\n\n<p>假设在ini文件中, 某条pipeline的顺序是filter1, filter2, filter3，app, 那么，最终运行的app&#95;real是这样组织的： app&#95;real = filter1(filter2(filter3(app)))</p>\n\n<p>在app真正被调用的过程中，filter1.&#95;&#95;call&#95;&#95;(environ,start&#95;response)被首先调用，若某种检查未通过，filter1做出反应；否则交给filter2.&#92;_&#95;call&#92;_&#95;(environ,start&#95;response)进一步处理，若某种检查未通过，filter2做出反应，中断链条，否则交给filter3.&#95;&#95;call&#92;_&#95;(environ,start&#95;response)处理，若filter3的某种检查都通过了，最后交给app.&#92;&#95;&#95;call_&#95;(environ,start&#95;response)进行处理。</p>\n\n<h3>4.5 读取配置文件</h3>\n\n<p>如果希望在不创建应用的情况下得到配置文件，可以使用appconfig(uri)函数，将会以字典形式返回使用的配置。这个字典包括了全局很本地的配置信息，所以可以通过属性方法获得相应的attributes （.local&#95;conf and .global&#95;conf）</p>\n\n<h2>5 其他</h2>\n\n<h3>5.1 如何引用Egg包</h3>\n\n<p>egg是python的一个包，pip easy_install等都是安装egg包的方式。关注egg包要注意：</p>\n\n<ul>\n<li><p>某一egg包是有标准说明的</p>\n\n<p>python setup.py name</p></li>\n<li><p>有entry point，不用太在意，这个只是说明调用程序的参数。</p></li>\n</ul>\n\n<h3>5.2 定义factory函数</h3>\n\n<p>工厂函数的定义还是遵循之前提到的应用的协议。目前，用于工厂函数的协议有以下：</p>\n\n<p>*paste.app_factory</p>\n\n<p>*paste.composite_factory</p>\n\n<p>*paste.filter_factory</p>\n\n<p>*paste.server_factory</p>\n\n<p>所有的这些都希望有一个含有&#95;&#95;call&#95;&#95;方法的（函数，方法，类）。</p>\n\n<p>1.<code>paste.app_factory</code></p>\n\n<pre><code>def app_factory(global_config, **local_conf):\n    return wsgi_app\n</code></pre>\n\n<p>global&#95;config是一个字典，而local&#95;conf则是关键字参数。返回一个wsgi_app（含有<strong>call</strong>方法。）</p>\n\n<p>2.paste.composite_factory`</p>\n\n<pre><code>def composite_factory(loader, global_config, **local_conf):\n   return wsgi_app\n</code></pre>\n\n<p>loader是一个对象，有几个有趣的方法,get&#95;app(name&#95;or&#95;uri, global&#95;conf=None)根据name返回一个wsgi应用，get&#95;filter（）和get&#95;server（）也是一样。看一个更加复杂的例子，举例一个pipeline应用：</p>\n\n<pre><code>def pipeline_factory(loader, global_config, pipeline):\n    # space-separated list of filter and app names:\n    pipeline = pipeline.split()\n    filters = [loader.get_filter(n) for n in pipeline[:-1]]\n    app = loader.get_app(pipeline[-1])\n    filters.reverse() # apply in reverse order!\n    for filter in filters:\n      app = filter(app)\n    return app\n</code></pre>\n\n<p>相应的配置文件如下：</p>\n\n<pre><code>[composite:main]\nuse = \npipeline = egg:Paste#printdebug session myapp\n\n[filter:session]\nuse = egg:Paste#session\nstore = memory\n\n[app:myapp]\nuse = egg:MyApp\n</code></pre>\n\n<p>3.<code>paste.filter_factory</code></p>\n\n<p>fliter的工厂函数和app的共产函数类似，除了它返回的是一个filter,fliter是一个仅仅把一个wsgi应用作为唯一参数的callable对象，返回一个被filter了的应用。 以下是一个例子，这个filter会检查CGI中REMOTE_USER变量是否存在，并创建一个简单的认证过滤器。</p>\n\n<pre><code>def auth_filter_factory(global_conf, req_usernames):\n    # space-separated list of usernames:\n    req_usernames = req_usernames.split()\n    def filter(app):\n        return AuthFilter(app, req_usernames)\n    return filter\n\nclass AuthFilter(object):\n    def __init__(self, app, req_usernames):\n        self.app = app\n        self.req_usernames = req_usernames\n\n    def __call__(self, environ, start_response):\n        if environ.get(''REMOTE_USER'') in self.req_usernames:\n                return self.app(environ, start_response)\n        start_response(\n                ''403 Forbidden'', [(''Content-type'', ''text/html'')])\n        return [''You are forbidden to view this resource'']\n</code></pre>\n\n<p>4.<code>paste.filter_app_factory</code></p>\n\n<p>和paste.filter_factory类似，接受一个wsgi应用参数，返回一个WSGI应用，所以如果改变以上代码的：</p>\n\n<pre><code>class AuthFilter(object):\n    def __init__(self, app, global_conf, req_usernames):\n        ....\n</code></pre>\n\n<p>那么，类 AuthFilter就会作为一个filter&#95;app&#95;factory函数使用。</p>\n\n<p>5.<code>paste.server_factory</code></p>\n\n<p>与以上不同的是，函数返回的是一个server,一个server也是一个callable对象，以一个WSGI应用作为参数，而后为这个应用服务。</p>\n\n<pre><code>def server_factory(global_conf, host, port):\n    port = int(port)\n    def serve(app):\n        s = Server(app, host=host, port=port)\n        s.serve_forever()\n    return serve\n</code></pre>\n\n<p>Server的实现用户可以自定义，可以参考python包wsgiref</p>\n\n<p>6.<code>paste.server_runner</code></p>\n\n<p>与 paste.server_factory类似，不同的是参数格式。</p>\n\n<h2>6 其他一些值得讨论的问题</h2>\n\n<p>ConfigParser（PD底层用到这个来解析ini文件）解析ini文件不是很有效率，是否需要更改？</p>\n\n<p>在配置文件中的对象是否需要是python风格的，而不是字符串的形式？</p>\n\n<p>备注：Paste Deployment currently does not require other parts of Paste, and is distributed as a separate package.</p>\n','Python.Paste指南之Deploy(1)-概念','','publish','open','open','','python-paste-deploy-1','','','2013-04-01 13:42:59','2013-04-01 05:42:59','','0','http://blog.wachang.net/?p=270','0','post','','0');");
E_D("replace into `wp_posts` values('271','1','2013-04-01 13:37:25','2013-04-01 05:37:25','<blockquote>\n  <p>浅出OpenStack源码系列</p>\n  \n  <p>Python模块基础篇：Python.Paste指南之Deploy(1)-概念</p>\n</blockquote>\n\n<p>Paste.Deploy主要是用来载入WSGI中的Web App使用，所谓WSGI的app，就是用来处理客户端发送过来的请求的，Python.Paste的核心函数是loadapp(),下文中PD就指代Paste.Deploy。</p>\n\n<h2>1 简介及安装</h2>\n\n<p>Paste Deployment是一种机制，通过loadapp函数和一个配置文件或者egg包来载入WSGI应用。安装很简单，如下两种方式：</p>\n\n<pre><code>\$ sudo pip install PasteDeploy\n</code></pre>\n\n<p>或者可以从github上进行源码安装</p>\n\n<pre><code>\$ hg clone http://bitbucket.org/ianb/pastedeploy\n\$ cd pastedeploy\n\$ sudo python setup.py develop\n</code></pre>\n\n<h2>2 配置文件Config Flie</h2>\n\n<p>一个配置文件后缀为ini，内容被分为很多段（section），PD只关心带有前缀的段，比如<code>[app:main]</code>或者<code>[filter:errors]</code>，总的来说，一个section的标识就是<code>[type:name]</code>,不是这种类型的section将会被忽略。</p>\n\n<p>一个section的内容是以<code>键=值</code>来标示的。#是一个注释。在段的定义中，有以下几类：</p>\n\n<ul>\n<li><p>[app:main]:定义WSGI应用，main表示只有一个应用，有多个应用的话main改为应用名字</p></li>\n<li><p>[server:main]:定义WSGI的一个server。</p></li>\n<li><p>[composite:xxx]：表示需要将一个请求调度定向（dispatched）到多个,或者多种应用上。以下是一个简单的例子，例子中，使用了composite，通过urlmap来实现载入多应用。</p></li>\n<li><p>[fliter:]：定义“过滤器”，将应用进行进一步的封装。</p></li>\n<li><p>[DEFAULT]：定义一些默认变量的值。</p></li>\n</ul>\n\n<p>以下是一个例子：</p>\n\n<pre><code>[composite:main]\nuse = egg:Paste#urlmap\n/ = home\n/blog = blog\n/wiki = wiki\n/cms = config:cms.ini\n\n[app:home]\nuse = egg:Paste#static\ndocument_root = %(here)s/htdocs\n\n[filter-app:blog]\nuse = egg:Authentication#auth\nnext = blogapp\nroles = admin\nhtpasswd = /home/me/users.htpasswd\n\n[app:blogapp]\nuse = egg:BlogApp\ndatabase = sqlite:/home/me/blog.db\n\n[app:wiki]\nuse = call:mywiki.main:application\ndatabase = sqlite:/home/me/wiki.db\n</code></pre>\n\n<p>下面会进行分段的讲解</p>\n\n<h3>2.1 composite</h3>\n\n<pre><code>[composite:main]\nuse = egg:Paste#urlmap\n/ = home\n/blog = blog\n/wiki = wiki\n/cms = config:cms.ini\n</code></pre>\n\n<p>这是一个composite段，表示这将会根据一些条件将web请求调度到不同的应用。<code>use = egg:Paste#urlmap</code>表示我们奖使用<code>Paste</code>egg包中<code>urlmap</code>来实现composite，这一个段(urlmap)可以算是一个通用的composite程序了。根据web请求的path的前缀进行一个到应用的映射(map)。这些被映射的程序就包括blog,home,wiki,config:cms.ini（映射到了另外一个配置文件，PD再根据这个文件进行载入）</p>\n\n<h3>2.2 App type1</h3>\n\n<pre><code>[app:home]\nuse = egg:Paste#static\ndocument_root = %(here)s/htdocs\n</code></pre>\n\n<p>app是一个callable object，接受的参数(environ,start_response)，这是paste系统交给application的，符合WSGI规范的参数. app需要完成的任务是响应envrion中的请求，准备好响应头和消息体，然后交给start_response处理，并返回响应消息体。<code>egg:Paste#static</code>也是Paste包中的一个简单程序，它只处理静态文件。它需要一个配置文件document_root,后面的值可以是一个变量,形式为%（var）s相应的值应该在[DEFAULT]字段指明以便Paste读取。比如：</p>\n\n<pre><code>[app:test]\nuse = egg:Paste#static\ndocument_root = %(path)s/htdocs\n[DEFAULT]\npath = /etc/test\n</code></pre>\n\n<h3>2.3 fliter</h3>\n\n<p>filter是一个callable object，其唯一参数是(app)，这是WSGI的application对象，filter需要完成的工作是将application包装成另一个application（“过滤”），并返回这个包装后的application。</p>\n\n<pre><code>[filter-app:blog]\nuse = egg:Authentication#auth\nnext = blogapp\nroles = admin\nhtpasswd = /home/me/users.htpasswd\n\n[app:blogapp]\nuse = egg:BlogApp\ndatabase = sqlite:/home/me/blog.db\n</code></pre>\n\n<p><code>[filter-app:blog]</code>fliter-app字段表明你希望对某个应用进行包装，需要包装的应用通过next指明（表明在下一个段中），这个字段的意思就是，在正式调用blogapp之前，我会调用egg:Authentication#auth进行一个用户的验证，随后才会调用blogapp进行处理。后面的[app:blogapp]则是定义了blogapp，并指明了需要的database参数。</p>\n\n<h3>2.4 App type2</h3>\n\n<pre><code>[app:wiki]\nuse = call:mywiki.main:application\ndatabase = sqlite:/home/me/wiki.db\n</code></pre>\n\n<p>这个段和之前的app段定义类似，不同的是对于wiki这个应用，我们没有使用egg包，而是直接对mywiki.main这个模块中的application对象使用了call方法。python，中一切皆对象，作为WSGI app的可以是一个函数，一个类，或者一个实例，使用call的话，相应的函数，类，实例中必须实现<strong>call</strong>()方法。此类app的格式用冒号分割: <code>call(表示使用call方法):模块的完成路径名字:应用变量的完整名字</code></p>\n\n<h2>3 基本使用</h2>\n\n<p>PD的主要使用就是通过读取配置文件载入WSGI应用。如下：</p>\n\n<pre><code>from paste.deploy import loadapp\nwsgi_app = loadapp(''config:/path/to/config.ini'')\n</code></pre>\n\n<p>注意，这里需要指明绝对路径。</p>\n\n<h2>4 更多关于配置文件</h2>\n\n<h3>4.1 App</h3>\n\n<p>单个配置文件中可以定义多个应用个，每个应用有自己独立的段。应用的定义以[app:name]的格式，[app:main]表示只有一个应用。应用的定义支持以下五种格式：</p>\n\n<pre><code>[app:myapp]\nuse = config:another_config_file.ini#app_name\n#使用另外一个配置文件\n\n[app:myotherapp]\nuse = egg:MyApp\n#使用egg包中的内容\n\n[app:mythirdapp]\nuse = call:my.project:myapplication\n#使用模块中的callable对象\n\n[app:mylastapp]\nuse = myotherapp\n#使用另外一个section\n\n[app:myfacapp]\npaste.app_factory = myapp.modulename:app_factory\n#使用工厂函数\n</code></pre>\n\n<p>其中，最后一种方式，将一个app指向了某些python代码。此模式下，必须执行app协议，以app_factory表示，后面的值需要import的东西，在这个例子中myapp.modulename被载入，并从其中取得了app_factory的实例。</p>\n\n<p>app_factory是一个callable object，其接受的参数是一些关于application的配置信息：<code>(global_conf,**kwargs)</code>，<code>global_conf</code>是在ini文件中default section中定义的一系列key-value对，而<code>**kwargs</code>，即一些本地配置，是在ini文件中，app:xxx section中定义的一系列key-value对。app_factory返回值是一个application对象</p>\n\n<p>在app的配置中，use参数以后配置就算结束了。其余的键值参数将会作为参数，传递到factory中，如下：</p>\n\n<pre><code>[app:blog]\nuse = egg:MyBlog\ndatabase = mysql://localhost/blogdb #这是参数\nblogname = This Is My Blog! #这是参数\n</code></pre>\n\n<h3>4.2 全局配置</h3>\n\n<p>全局配置主要是用于多个应用共用一些变量，这些变量我们规定放在段[DEFAULT]中，如果需要覆盖，可以在自己的app中重新定义，如下：</p>\n\n<pre><code>[DEFAULT]\nadmin_email = webmaster@example.com\n[app:main]\nuse = ...\nset admin_email = bob@example.com\n</code></pre>\n\n<h3>4.3 composite app</h3>\n\n<p>composite是一个运行着像是app，但是实际上是由多个应用组成的。urlmap就是composite app的一个例子，url不同的path对应了不同的应用。如下：</p>\n\n<pre><code>[composite:main]\nuse = egg:Paste#urlmap\n/ = mainapp\n/files = staticapp\n\n[app:mainapp]\nuse = egg:MyApp\n\n[app:staticapp]\nuse = egg:Paste#static\ndocument_root = /path/to/docroot\n</code></pre>\n\n<p>在loadapp函数的执行中，composite app被实例化，它同时还会访问配置文件中定义的其他应用。</p>\n\n<h3>4.4 app定义高级用法</h3>\n\n<p>在app段中，你可以定义fliters和servers，通过<code>fliter:</code>和<code>server:</code> PD通过loadserver和loadfilter函数进行调用，工作机制都一样，返回不同的对象。</p>\n\n<h4>4.4.1 filter composition</h4>\n\n<p>应用filter的方式很多，重要的是看你filter的数量和组织形式。下面会一一介绍应用fliter的几种方式：</p>\n\n<p>1.使用<code>filter-with</code></p>\n\n<pre><code>[app:main]\nuse = egg:MyEgg\nfilter-with = printdebug\n\n[filter:printdebug]\nuse = egg:Paste#printdebug\n# and you could have another filter-with here, and so on...\n</code></pre>\n\n<p>2.使用<code>fliter-app</code></p>\n\n<pre><code>[fliter-app:printdebug]\nuse = egg:Paste\nnext = main\n\n[app:main]\nuse = egg:MyEgg\n</code></pre>\n\n<p>3.使用pipeline</p>\n\n<p>当使用多个filter的时候需要使用pipeline的方式，它需要提供一个key参数pipeline,后面的值是一个列表，最后以应用结尾。如下：</p>\n\n<pre><code>[pipeline:main]\npipeline = filter1 egg:FilterEgg#filter2 filter3 app\n\n[filter:filter1]\n...\n</code></pre>\n\n<p>假设在ini文件中, 某条pipeline的顺序是filter1, filter2, filter3，app, 那么，最终运行的app_real是这样组织的：\napp_real = filter1(filter2(filter3(app)))</p>\n\n<p>在app真正被调用的过程中，filter1.&#95;_call&#95;_(environ,start_response)被首先调用，若某种检查未通过，filter1做出反应；否则交给filter2.&#95;_call&#95;_(environ,start_response)进一步处理，若某种检查未通过，filter2做出反应，中断链条，否则交给filter3.&#95;_call&#95;_(environ,start_response)处理，若filter3的某种检查都通过了，最后交给app.&#95;_call&#95;_(environ,start_response)进行处理。</p>\n\n<h3>4.5 读取配置文件</h3>\n\n<p>如果希望在不创建应用的情况下得到配置文件，可以使用appconfig(uri)函数，将会以字典形式返回使用的配置。这个字典包括了全局很本地的配置信息，所以可以通过属性方法获得相应的attributes （.local_conf and .global_conf）</p>\n\n<h2>5 其他</h2>\n\n<h3>5.1 如何引用Egg包</h3>\n\n<p>egg是python的一个包，pip easy_install等都是安装egg包的方式。关注egg包要注意：</p>\n\n<ul>\n<li><p>某一egg包是有标准说明的</p>\n\n<p>python setup.py name</p></li>\n<li><p>有entry point，不用太在意，这个只是说明调用程序的参数。</p></li>\n</ul>\n\n<h3>5.2 定义factory函数</h3>\n\n<p>工厂函数的定义还是遵循之前提到的应用的协议。目前，用于工厂函数的协议有以下：</p>\n\n<p>*paste.app_factory</p>\n\n<p>*paste.composite_factory</p>\n\n<p>*paste.filter_factory</p>\n\n<p>*paste.server_factory</p>\n\n<p>所有的这些都希望有一个含有&#95;_call__方法的（函数，方法，类）。</p>\n\n<p>1.<code>paste.app_factory</code></p>\n\n<pre><code>def app_factory(global_config, **local_conf):\n    return wsgi_app\n</code></pre>\n\n<p>global_config是一个字典，而local_conf则是关键字参数。返回一个wsgi_app（含有<strong>call</strong>方法。）</p>\n\n<p>2.paste.composite_factory`</p>\n\n<pre><code>def composite_factory(loader, global_config, **local_conf):\n   return wsgi_app\n</code></pre>\n\n<p>loader是一个对象，有几个有趣的方法,get_app(name_or_uri, global_conf=None)根据name返回一个wsgi应用，get_filter（）和get_server（）也是一样。看一个更加复杂的例子，举例一个pipeline应用：</p>\n\n<pre><code>def pipeline_factory(loader, global_config, pipeline):\n    # space-separated list of filter and app names:\n    pipeline = pipeline.split()\n    filters = [loader.get_filter(n) for n in pipeline[:-1]]\n    app = loader.get_app(pipeline[-1])\n    filters.reverse() # apply in reverse order!\n    for filter in filters:\n      app = filter(app)\n    return app\n</code></pre>\n\n<p>相应的配置文件如下：</p>\n\n<pre><code>[composite:main]\nuse = \npipeline = egg:Paste#printdebug session myapp\n\n[filter:session]\nuse = egg:Paste#session\nstore = memory\n\n[app:myapp]\nuse = egg:MyApp\n</code></pre>\n\n<p>3.<code>paste.filter_factory</code>\nfliter的工厂函数和app的共产函数类似，除了它返回的是一个filter,fliter是一个仅仅把一个wsgi应用作为唯一参数的callable对象，返回一个被filter了的应用。\n以下是一个例子，这个filter会检查CGI中REMOTE_USER变量是否存在，并创建一个简单的认证过滤器。</p>\n\n<pre><code>def auth_filter_factory(global_conf, req_usernames):\n    # space-separated list of usernames:\n    req_usernames = req_usernames.split()\n    def filter(app):\n        return AuthFilter(app, req_usernames)\n    return filter\n\nclass AuthFilter(object):\n    def __init__(self, app, req_usernames):\n        self.app = app\n        self.req_usernames = req_usernames\n\n    def __call__(self, environ, start_response):\n        if environ.get(''REMOTE_USER'') in self.req_usernames:\n                return self.app(environ, start_response)\n        start_response(\n                ''403 Forbidden'', [(''Content-type'', ''text/html'')])\n        return [''You are forbidden to view this resource'']\n</code></pre>\n\n<p>4.<code>paste.filter_app_factory</code>\n和paste.filter_factory类似，接受一个wsgi应用参数，返回一个WSGI应用，所以如果改变以上代码的：</p>\n\n<pre><code>class AuthFilter(object):\n    def __init__(self, app, global_conf, req_usernames):\n        ....\n</code></pre>\n\n<p>那么，类 AuthFilter就会作为一个filter_app_factory函数使用。</p>\n\n<p>5.<code>paste.server_factory</code></p>\n\n<p>与以上不同的是，函数返回的是一个server,一个server也是一个callable对象，以一个WSGI应用作为参数，而后为这个应用服务。</p>\n\n<pre><code>def server_factory(global_conf, host, port):\n    port = int(port)\n    def serve(app):\n        s = Server(app, host=host, port=port)\n        s.serve_forever()\n    return serve\n</code></pre>\n\n<p>Server的实现用户可以自定义，可以参考python包wsgiref</p>\n\n<p>6.<code>paste.server_runner</code>\n与 paste.server_factory类似，不同的是参数格式。</p>\n\n<h2>6 其他一些值得讨论的问题</h2>\n\n<p>ConfigParser（PD底层用到这个来解析ini文件）解析ini文件不是很有效率，是否需要更改？</p>\n\n<p>在配置文件中的对象是否需要是python风格的，而不是字符串的形式？</p>\n\n<p>备注：Paste Deployment currently does not require other parts of Paste, and is distributed as a separate package.</p>\n','Python.Paste指南之Deploy(1)-概念','','inherit','open','open','','270-revision','','','2013-04-01 13:37:25','2013-04-01 05:37:25','','270','http://blog.wachang.net/2013/04/270-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('272','1','2013-04-01 13:38:22','2013-04-01 05:38:22','<blockquote>\n  <p>浅出OpenStack源码系列</p>\n  \n  <p>Python模块基础篇：Python.Paste指南之Deploy(1)-概念</p>\n</blockquote>\n\n<p>Paste.Deploy主要是用来载入WSGI中的Web App使用，所谓WSGI的app，就是用来处理客户端发送过来的请求的，Python.Paste的核心函数是loadapp(),下文中PD就指代Paste.Deploy。</p>\n\n<h2>1 简介及安装</h2>\n\n<p>Paste Deployment是一种机制，通过loadapp函数和一个配置文件或者egg包来载入WSGI应用。安装很简单，如下两种方式：</p>\n\n<pre><code>\$ sudo pip install PasteDeploy\n</code></pre>\n\n<p>或者可以从github上进行源码安装</p>\n\n<pre><code>\$ hg clone http://bitbucket.org/ianb/pastedeploy\n\$ cd pastedeploy\n\$ sudo python setup.py develop\n</code></pre>\n\n<!--more-->\n\n<h2>2 配置文件Config Flie</h2>\n\n<p>一个配置文件后缀为ini，内容被分为很多段（section），PD只关心带有前缀的段，比如<code>[app:main]</code>或者<code>[filter:errors]</code>，总的来说，一个section的标识就是<code>[type:name]</code>,不是这种类型的section将会被忽略。</p>\n\n<p>一个section的内容是以<code>键=值</code>来标示的。#是一个注释。在段的定义中，有以下几类：</p>\n\n<ul>\n<li><p>[app:main]:定义WSGI应用，main表示只有一个应用，有多个应用的话main改为应用名字</p></li>\n<li><p>[server:main]:定义WSGI的一个server。</p></li>\n<li><p>[composite:xxx]：表示需要将一个请求调度定向（dispatched）到多个,或者多种应用上。以下是一个简单的例子，例子中，使用了composite，通过urlmap来实现载入多应用。</p></li>\n<li><p>[fliter:]：定义“过滤器”，将应用进行进一步的封装。</p></li>\n<li><p>[DEFAULT]：定义一些默认变量的值。</p></li>\n</ul>\n\n<p>以下是一个例子：</p>\n\n<pre><code>[composite:main]\nuse = egg:Paste#urlmap\n/ = home\n/blog = blog\n/wiki = wiki\n/cms = config:cms.ini\n\n[app:home]\nuse = egg:Paste#static\ndocument_root = %(here)s/htdocs\n\n[filter-app:blog]\nuse = egg:Authentication#auth\nnext = blogapp\nroles = admin\nhtpasswd = /home/me/users.htpasswd\n\n[app:blogapp]\nuse = egg:BlogApp\ndatabase = sqlite:/home/me/blog.db\n\n[app:wiki]\nuse = call:mywiki.main:application\ndatabase = sqlite:/home/me/wiki.db\n</code></pre>\n\n<p>下面会进行分段的讲解</p>\n\n<h3>2.1 composite</h3>\n\n<pre><code>[composite:main]\nuse = egg:Paste#urlmap\n/ = home\n/blog = blog\n/wiki = wiki\n/cms = config:cms.ini\n</code></pre>\n\n<p>这是一个composite段，表示这将会根据一些条件将web请求调度到不同的应用。<code>use = egg:Paste#urlmap</code>表示我们奖使用<code>Paste</code>egg包中<code>urlmap</code>来实现composite，这一个段(urlmap)可以算是一个通用的composite程序了。根据web请求的path的前缀进行一个到应用的映射(map)。这些被映射的程序就包括blog,home,wiki,config:cms.ini（映射到了另外一个配置文件，PD再根据这个文件进行载入）</p>\n\n<h3>2.2 App type1</h3>\n\n<pre><code>[app:home]\nuse = egg:Paste#static\ndocument_root = %(here)s/htdocs\n</code></pre>\n\n<p>app是一个callable object，接受的参数(environ,start_response)，这是paste系统交给application的，符合WSGI规范的参数. app需要完成的任务是响应envrion中的请求，准备好响应头和消息体，然后交给start_response处理，并返回响应消息体。<code>egg:Paste#static</code>也是Paste包中的一个简单程序，它只处理静态文件。它需要一个配置文件document_root,后面的值可以是一个变量,形式为%（var）s相应的值应该在[DEFAULT]字段指明以便Paste读取。比如：</p>\n\n<pre><code>[app:test]\nuse = egg:Paste#static\ndocument_root = %(path)s/htdocs\n[DEFAULT]\npath = /etc/test\n</code></pre>\n\n<h3>2.3 fliter</h3>\n\n<p>filter是一个callable object，其唯一参数是(app)，这是WSGI的application对象，filter需要完成的工作是将application包装成另一个application（“过滤”），并返回这个包装后的application。</p>\n\n<pre><code>[filter-app:blog]\nuse = egg:Authentication#auth\nnext = blogapp\nroles = admin\nhtpasswd = /home/me/users.htpasswd\n\n[app:blogapp]\nuse = egg:BlogApp\ndatabase = sqlite:/home/me/blog.db\n</code></pre>\n\n<p><code>[filter-app:blog]</code>fliter-app字段表明你希望对某个应用进行包装，需要包装的应用通过next指明（表明在下一个段中），这个字段的意思就是，在正式调用blogapp之前，我会调用egg:Authentication#auth进行一个用户的验证，随后才会调用blogapp进行处理。后面的[app:blogapp]则是定义了blogapp，并指明了需要的database参数。</p>\n\n<h3>2.4 App type2</h3>\n\n<pre><code>[app:wiki]\nuse = call:mywiki.main:application\ndatabase = sqlite:/home/me/wiki.db\n</code></pre>\n\n<p>这个段和之前的app段定义类似，不同的是对于wiki这个应用，我们没有使用egg包，而是直接对mywiki.main这个模块中的application对象使用了call方法。python，中一切皆对象，作为WSGI app的可以是一个函数，一个类，或者一个实例，使用call的话，相应的函数，类，实例中必须实现<strong>call</strong>()方法。此类app的格式用冒号分割: <code>call(表示使用call方法):模块的完成路径名字:应用变量的完整名字</code></p>\n\n<h2>3 基本使用</h2>\n\n<p>PD的主要使用就是通过读取配置文件载入WSGI应用。如下：</p>\n\n<pre><code>from paste.deploy import loadapp\nwsgi_app = loadapp(''config:/path/to/config.ini'')\n</code></pre>\n\n<p>注意，这里需要指明绝对路径。</p>\n\n<h2>4 更多关于配置文件</h2>\n\n<h3>4.1 App</h3>\n\n<p>单个配置文件中可以定义多个应用个，每个应用有自己独立的段。应用的定义以[app:name]的格式，[app:main]表示只有一个应用。应用的定义支持以下五种格式：</p>\n\n<pre><code>[app:myapp]\nuse = config:another_config_file.ini#app_name\n#使用另外一个配置文件\n\n[app:myotherapp]\nuse = egg:MyApp\n#使用egg包中的内容\n\n[app:mythirdapp]\nuse = call:my.project:myapplication\n#使用模块中的callable对象\n\n[app:mylastapp]\nuse = myotherapp\n#使用另外一个section\n\n[app:myfacapp]\npaste.app_factory = myapp.modulename:app_factory\n#使用工厂函数\n</code></pre>\n\n<p>其中，最后一种方式，将一个app指向了某些python代码。此模式下，必须执行app协议，以app_factory表示，后面的值需要import的东西，在这个例子中myapp.modulename被载入，并从其中取得了app_factory的实例。</p>\n\n<p>app_factory是一个callable object，其接受的参数是一些关于application的配置信息：<code>(global_conf,**kwargs)</code>，<code>global_conf</code>是在ini文件中default section中定义的一系列key-value对，而<code>**kwargs</code>，即一些本地配置，是在ini文件中，app:xxx section中定义的一系列key-value对。app_factory返回值是一个application对象</p>\n\n<p>在app的配置中，use参数以后配置就算结束了。其余的键值参数将会作为参数，传递到factory中，如下：</p>\n\n<pre><code>[app:blog]\nuse = egg:MyBlog\ndatabase = mysql://localhost/blogdb #这是参数\nblogname = This Is My Blog! #这是参数\n</code></pre>\n\n<h3>4.2 全局配置</h3>\n\n<p>全局配置主要是用于多个应用共用一些变量，这些变量我们规定放在段[DEFAULT]中，如果需要覆盖，可以在自己的app中重新定义，如下：</p>\n\n<pre><code>[DEFAULT]\nadmin_email = webmaster@example.com\n[app:main]\nuse = ...\nset admin_email = bob@example.com\n</code></pre>\n\n<h3>4.3 composite app</h3>\n\n<p>composite是一个运行着像是app，但是实际上是由多个应用组成的。urlmap就是composite app的一个例子，url不同的path对应了不同的应用。如下：</p>\n\n<pre><code>[composite:main]\nuse = egg:Paste#urlmap\n/ = mainapp\n/files = staticapp\n\n[app:mainapp]\nuse = egg:MyApp\n\n[app:staticapp]\nuse = egg:Paste#static\ndocument_root = /path/to/docroot\n</code></pre>\n\n<p>在loadapp函数的执行中，composite app被实例化，它同时还会访问配置文件中定义的其他应用。</p>\n\n<h3>4.4 app定义高级用法</h3>\n\n<p>在app段中，你可以定义fliters和servers，通过<code>fliter:</code>和<code>server:</code> PD通过loadserver和loadfilter函数进行调用，工作机制都一样，返回不同的对象。</p>\n\n<h4>4.4.1 filter composition</h4>\n\n<p>应用filter的方式很多，重要的是看你filter的数量和组织形式。下面会一一介绍应用fliter的几种方式：</p>\n\n<p>1.使用<code>filter-with</code></p>\n\n<pre><code>[app:main]\nuse = egg:MyEgg\nfilter-with = printdebug\n\n[filter:printdebug]\nuse = egg:Paste#printdebug\n# and you could have another filter-with here, and so on...\n</code></pre>\n\n<p>2.使用<code>fliter-app</code></p>\n\n<pre><code>[fliter-app:printdebug]\nuse = egg:Paste\nnext = main\n\n[app:main]\nuse = egg:MyEgg\n</code></pre>\n\n<p>3.使用pipeline</p>\n\n<p>当使用多个filter的时候需要使用pipeline的方式，它需要提供一个key参数pipeline,后面的值是一个列表，最后以应用结尾。如下：</p>\n\n<pre><code>[pipeline:main]\npipeline = filter1 egg:FilterEgg#filter2 filter3 app\n\n[filter:filter1]\n...\n</code></pre>\n\n<p>假设在ini文件中, 某条pipeline的顺序是filter1, filter2, filter3，app, 那么，最终运行的app_real是这样组织的：\napp_real = filter1(filter2(filter3(app)))</p>\n\n<p>在app真正被调用的过程中，filter1.&#95;_call&#95;_(environ,start_response)被首先调用，若某种检查未通过，filter1做出反应；否则交给filter2.&#95;_call&#95;_(environ,start_response)进一步处理，若某种检查未通过，filter2做出反应，中断链条，否则交给filter3.&#95;_call&#95;_(environ,start_response)处理，若filter3的某种检查都通过了，最后交给app.&#95;_call&#95;_(environ,start_response)进行处理。</p>\n\n<h3>4.5 读取配置文件</h3>\n\n<p>如果希望在不创建应用的情况下得到配置文件，可以使用appconfig(uri)函数，将会以字典形式返回使用的配置。这个字典包括了全局很本地的配置信息，所以可以通过属性方法获得相应的attributes （.local_conf and .global_conf）</p>\n\n<h2>5 其他</h2>\n\n<h3>5.1 如何引用Egg包</h3>\n\n<p>egg是python的一个包，pip easy_install等都是安装egg包的方式。关注egg包要注意：</p>\n\n<ul>\n<li><p>某一egg包是有标准说明的</p>\n\n<p>python setup.py name</p></li>\n<li><p>有entry point，不用太在意，这个只是说明调用程序的参数。</p></li>\n</ul>\n\n<h3>5.2 定义factory函数</h3>\n\n<p>工厂函数的定义还是遵循之前提到的应用的协议。目前，用于工厂函数的协议有以下：</p>\n\n<p>*paste.app_factory</p>\n\n<p>*paste.composite_factory</p>\n\n<p>*paste.filter_factory</p>\n\n<p>*paste.server_factory</p>\n\n<p>所有的这些都希望有一个含有&#95;_call__方法的（函数，方法，类）。</p>\n\n<p>1.<code>paste.app_factory</code></p>\n\n<pre><code>def app_factory(global_config, **local_conf):\n    return wsgi_app\n</code></pre>\n\n<p>global_config是一个字典，而local_conf则是关键字参数。返回一个wsgi_app（含有<strong>call</strong>方法。）</p>\n\n<p>2.paste.composite_factory`</p>\n\n<pre><code>def composite_factory(loader, global_config, **local_conf):\n   return wsgi_app\n</code></pre>\n\n<p>loader是一个对象，有几个有趣的方法,get_app(name_or_uri, global_conf=None)根据name返回一个wsgi应用，get_filter（）和get_server（）也是一样。看一个更加复杂的例子，举例一个pipeline应用：</p>\n\n<pre><code>def pipeline_factory(loader, global_config, pipeline):\n    # space-separated list of filter and app names:\n    pipeline = pipeline.split()\n    filters = [loader.get_filter(n) for n in pipeline[:-1]]\n    app = loader.get_app(pipeline[-1])\n    filters.reverse() # apply in reverse order!\n    for filter in filters:\n      app = filter(app)\n    return app\n</code></pre>\n\n<p>相应的配置文件如下：</p>\n\n<pre><code>[composite:main]\nuse = \npipeline = egg:Paste#printdebug session myapp\n\n[filter:session]\nuse = egg:Paste#session\nstore = memory\n\n[app:myapp]\nuse = egg:MyApp\n</code></pre>\n\n<p>3.<code>paste.filter_factory</code>\nfliter的工厂函数和app的共产函数类似，除了它返回的是一个filter,fliter是一个仅仅把一个wsgi应用作为唯一参数的callable对象，返回一个被filter了的应用。\n以下是一个例子，这个filter会检查CGI中REMOTE_USER变量是否存在，并创建一个简单的认证过滤器。</p>\n\n<pre><code>def auth_filter_factory(global_conf, req_usernames):\n    # space-separated list of usernames:\n    req_usernames = req_usernames.split()\n    def filter(app):\n        return AuthFilter(app, req_usernames)\n    return filter\n\nclass AuthFilter(object):\n    def __init__(self, app, req_usernames):\n        self.app = app\n        self.req_usernames = req_usernames\n\n    def __call__(self, environ, start_response):\n        if environ.get(''REMOTE_USER'') in self.req_usernames:\n                return self.app(environ, start_response)\n        start_response(\n                ''403 Forbidden'', [(''Content-type'', ''text/html'')])\n        return [''You are forbidden to view this resource'']\n</code></pre>\n\n<p>4.<code>paste.filter_app_factory</code>\n和paste.filter_factory类似，接受一个wsgi应用参数，返回一个WSGI应用，所以如果改变以上代码的：</p>\n\n<pre><code>class AuthFilter(object):\n    def __init__(self, app, global_conf, req_usernames):\n        ....\n</code></pre>\n\n<p>那么，类 AuthFilter就会作为一个filter_app_factory函数使用。</p>\n\n<p>5.<code>paste.server_factory</code></p>\n\n<p>与以上不同的是，函数返回的是一个server,一个server也是一个callable对象，以一个WSGI应用作为参数，而后为这个应用服务。</p>\n\n<pre><code>def server_factory(global_conf, host, port):\n    port = int(port)\n    def serve(app):\n        s = Server(app, host=host, port=port)\n        s.serve_forever()\n    return serve\n</code></pre>\n\n<p>Server的实现用户可以自定义，可以参考python包wsgiref</p>\n\n<p>6.<code>paste.server_runner</code>\n与 paste.server_factory类似，不同的是参数格式。</p>\n\n<h2>6 其他一些值得讨论的问题</h2>\n\n<p>ConfigParser（PD底层用到这个来解析ini文件）解析ini文件不是很有效率，是否需要更改？</p>\n\n<p>在配置文件中的对象是否需要是python风格的，而不是字符串的形式？</p>\n\n<p>备注：Paste Deployment currently does not require other parts of Paste, and is distributed as a separate package.</p>\n','Python.Paste指南之Deploy(1)-概念','','inherit','open','open','','270-revision-2','','','2013-04-01 13:38:22','2013-04-01 05:38:22','','270','http://blog.wachang.net/2013/04/270-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('273','1','2013-04-01 13:38:51','2013-04-01 05:38:51','<blockquote>\n  <p>浅出OpenStack源码系列</p>\n  \n  <p>Python模块基础篇：Python.Paste指南之Deploy(1)-概念</p>\n</blockquote>\n\n<p>Paste.Deploy主要是用来载入WSGI中的Web App使用，所谓WSGI的app，就是用来处理客户端发送过来的请求的，Python.Paste的核心函数是loadapp(),下文中PD就指代Paste.Deploy。</p>\n\n<h2>1 简介及安装</h2>\n\n<p>Paste Deployment是一种机制，通过loadapp函数和一个配置文件或者egg包来载入WSGI应用。安装很简单，如下两种方式：</p>\n\n<pre><code>\$ sudo pip install PasteDeploy\n</code></pre>\n\n<p>或者可以从github上进行源码安装</p>\n\n<pre><code>\$ hg clone http://bitbucket.org/ianb/pastedeploy\n\$ cd pastedeploy\n\$ sudo python setup.py develop\n</code></pre>\n\n<!--more-->\n\n<h2>2 配置文件Config Flie</h2>\n\n<p>一个配置文件后缀为ini，内容被分为很多段（section），PD只关心带有前缀的段，比如<code>[app:main]</code>或者<code>[filter:errors]</code>，总的来说，一个section的标识就是<code>[type:name]</code>,不是这种类型的section将会被忽略。</p>\n\n<p>一个section的内容是以<code>键=值</code>来标示的。#是一个注释。在段的定义中，有以下几类：</p>\n\n<ul>\n<li><p>[app:main]:定义WSGI应用，main表示只有一个应用，有多个应用的话main改为应用名字</p></li>\n<li><p>[server:main]:定义WSGI的一个server。</p></li>\n<li><p>[composite:xxx]：表示需要将一个请求调度定向（dispatched）到多个,或者多种应用上。以下是一个简单的例子，例子中，使用了composite，通过urlmap来实现载入多应用。</p></li>\n<li><p>[fliter:]：定义“过滤器”，将应用进行进一步的封装。</p></li>\n<li><p>[DEFAULT]：定义一些默认变量的值。</p></li>\n</ul>\n\n<p>以下是一个例子：</p>\n\n<pre><code>[composite:main]\nuse = egg:Paste#urlmap\n/ = home\n/blog = blog\n/wiki = wiki\n/cms = config:cms.ini\n\n[app:home]\nuse = egg:Paste#static\ndocument_root = %(here)s/htdocs\n\n[filter-app:blog]\nuse = egg:Authentication#auth\nnext = blogapp\nroles = admin\nhtpasswd = /home/me/users.htpasswd\n\n[app:blogapp]\nuse = egg:BlogApp\ndatabase = sqlite:/home/me/blog.db\n\n[app:wiki]\nuse = call:mywiki.main:application\ndatabase = sqlite:/home/me/wiki.db\n</code></pre>\n\n<p>下面会进行分段的讲解</p>\n\n<h3>2.1 composite</h3>\n\n<pre><code>[composite:main]\nuse = egg:Paste#urlmap\n/ = home\n/blog = blog\n/wiki = wiki\n/cms = config:cms.ini\n</code></pre>\n\n<p>这是一个composite段，表示这将会根据一些条件将web请求调度到不同的应用。<code>use = egg:Paste#urlmap</code>表示我们奖使用<code>Paste</code>egg包中<code>urlmap</code>来实现composite，这一个段(urlmap)可以算是一个通用的composite程序了。根据web请求的path的前缀进行一个到应用的映射(map)。这些被映射的程序就包括blog,home,wiki,config:cms.ini（映射到了另外一个配置文件，PD再根据这个文件进行载入）</p>\n\n<h3>2.2 App type1</h3>\n\n<pre><code>[app:home]\nuse = egg:Paste#static\ndocument_root = %(here)s/htdocs\n</code></pre>\n\n<p>app是一个callable object，接受的参数(environ,start&#95;response)，这是paste系统交给application的，符合WSGI规范的参数. app需要完成的任务是响应envrion中的请求，准备好响应头和消息体，然后交给start&#95;response处理，并返回响应消息体。<code>egg:Paste#static</code>也是Paste包中的一个简单程序，它只处理静态文件。它需要一个配置文件document_root,后面的值可以是一个变量,形式为%（var）s相应的值应该在[DEFAULT]字段指明以便Paste读取。比如：</p>\n\n<pre><code>[app:test]\nuse = egg:Paste#static\ndocument_root = %(path)s/htdocs\n[DEFAULT]\npath = /etc/test\n</code></pre>\n\n<h3>2.3 fliter</h3>\n\n<p>filter是一个callable object，其唯一参数是(app)，这是WSGI的application对象，filter需要完成的工作是将application包装成另一个application（“过滤”），并返回这个包装后的application。</p>\n\n<pre><code>[filter-app:blog]\nuse = egg:Authentication#auth\nnext = blogapp\nroles = admin\nhtpasswd = /home/me/users.htpasswd\n\n[app:blogapp]\nuse = egg:BlogApp\ndatabase = sqlite:/home/me/blog.db\n</code></pre>\n\n<p><code>[filter-app:blog]</code>fliter-app字段表明你希望对某个应用进行包装，需要包装的应用通过next指明（表明在下一个段中），这个字段的意思就是，在正式调用blogapp之前，我会调用egg:Authentication#auth进行一个用户的验证，随后才会调用blogapp进行处理。后面的[app:blogapp]则是定义了blogapp，并指明了需要的database参数。</p>\n\n<h3>2.4 App type2</h3>\n\n<pre><code>[app:wiki]\nuse = call:mywiki.main:application\ndatabase = sqlite:/home/me/wiki.db\n</code></pre>\n\n<p>这个段和之前的app段定义类似，不同的是对于wiki这个应用，我们没有使用egg包，而是直接对mywiki.main这个模块中的application对象使用了call方法。python，中一切皆对象，作为WSGI app的可以是一个函数，一个类，或者一个实例，使用call的话，相应的函数，类，实例中必须实现<strong>call</strong>()方法。此类app的格式用冒号分割: <code>call(表示使用call方法):模块的完成路径名字:应用变量的完整名字</code></p>\n\n<h2>3 基本使用</h2>\n\n<p>PD的主要使用就是通过读取配置文件载入WSGI应用。如下：</p>\n\n<pre><code>from paste.deploy import loadapp\nwsgi_app = loadapp(''config:/path/to/config.ini'')\n</code></pre>\n\n<p>注意，这里需要指明绝对路径。</p>\n\n<h2>4 更多关于配置文件</h2>\n\n<h3>4.1 App</h3>\n\n<p>单个配置文件中可以定义多个应用个，每个应用有自己独立的段。应用的定义以[app:name]的格式，[app:main]表示只有一个应用。应用的定义支持以下五种格式：</p>\n\n<pre><code>[app:myapp]\nuse = config:another_config_file.ini#app_name\n#使用另外一个配置文件\n\n[app:myotherapp]\nuse = egg:MyApp\n#使用egg包中的内容\n\n[app:mythirdapp]\nuse = call:my.project:myapplication\n#使用模块中的callable对象\n\n[app:mylastapp]\nuse = myotherapp\n#使用另外一个section\n\n[app:myfacapp]\npaste.app_factory = myapp.modulename:app_factory\n#使用工厂函数\n</code></pre>\n\n<p>其中，最后一种方式，将一个app指向了某些python代码。此模式下，必须执行app协议，以app&#95;factory表示，后面的值需要import的东西，在这个例子中myapp.modulename被载入，并从其中取得了app&#95;factory的实例。</p>\n\n<p>app_factory是一个callable object，其接受的参数是一些关于application的配置信息：<code>(global_conf,**kwargs)</code>，<code>global_conf</code>是在ini文件中default section中定义的一系列key-value对，而<code>**kwargs</code>，即一些本地配置，是在ini文件中，app:xxx section中定义的一系列key-value对。app_factory返回值是一个application对象</p>\n\n<p>在app的配置中，use参数以后配置就算结束了。其余的键值参数将会作为参数，传递到factory中，如下：</p>\n\n<pre><code>[app:blog]\nuse = egg:MyBlog\ndatabase = mysql://localhost/blogdb #这是参数\nblogname = This Is My Blog! #这是参数\n</code></pre>\n\n<h3>4.2 全局配置</h3>\n\n<p>全局配置主要是用于多个应用共用一些变量，这些变量我们规定放在段[DEFAULT]中，如果需要覆盖，可以在自己的app中重新定义，如下：</p>\n\n<pre><code>[DEFAULT]\nadmin_email = webmaster@example.com\n[app:main]\nuse = ...\nset admin_email = bob@example.com\n</code></pre>\n\n<h3>4.3 composite app</h3>\n\n<p>composite是一个运行着像是app，但是实际上是由多个应用组成的。urlmap就是composite app的一个例子，url不同的path对应了不同的应用。如下：</p>\n\n<pre><code>[composite:main]\nuse = egg:Paste#urlmap\n/ = mainapp\n/files = staticapp\n\n[app:mainapp]\nuse = egg:MyApp\n\n[app:staticapp]\nuse = egg:Paste#static\ndocument_root = /path/to/docroot\n</code></pre>\n\n<p>在loadapp函数的执行中，composite app被实例化，它同时还会访问配置文件中定义的其他应用。</p>\n\n<h3>4.4 app定义高级用法</h3>\n\n<p>在app段中，你可以定义fliters和servers，通过<code>fliter:</code>和<code>server:</code> PD通过loadserver和loadfilter函数进行调用，工作机制都一样，返回不同的对象。</p>\n\n<h4>4.4.1 filter composition</h4>\n\n<p>应用filter的方式很多，重要的是看你filter的数量和组织形式。下面会一一介绍应用fliter的几种方式：</p>\n\n<p>1.使用<code>filter-with</code></p>\n\n<pre><code>[app:main]\nuse = egg:MyEgg\nfilter-with = printdebug\n\n[filter:printdebug]\nuse = egg:Paste#printdebug\n# and you could have another filter-with here, and so on...\n</code></pre>\n\n<p>2.使用<code>fliter-app</code></p>\n\n<pre><code>[fliter-app:printdebug]\nuse = egg:Paste\nnext = main\n\n[app:main]\nuse = egg:MyEgg\n</code></pre>\n\n<p>3.使用pipeline</p>\n\n<p>当使用多个filter的时候需要使用pipeline的方式，它需要提供一个key参数pipeline,后面的值是一个列表，最后以应用结尾。如下：</p>\n\n<pre><code>[pipeline:main]\npipeline = filter1 egg:FilterEgg#filter2 filter3 app\n\n[filter:filter1]\n...\n</code></pre>\n\n<p>假设在ini文件中, 某条pipeline的顺序是filter1, filter2, filter3，app, 那么，最终运行的app&#95;real是这样组织的： app&#95;real = filter1(filter2(filter3(app)))</p>\n\n<p>在app真正被调用的过程中，filter1.&#95;&#95;call&#95;&#95;(environ,start&#95;response)被首先调用，若某种检查未通过，filter1做出反应；否则交给filter2.&#92;_&#95;call&#95;&#95;(environ,start&#95;response)进一步处理，若某种检查未通过，filter2做出反应，中断链条，否则交给filter3.&#92;_&#95;call&#95;&#95;(environ,start&#95;response)处理，若filter3的某种检查都通过了，最后交给app.&#92;_&#95;call&#95;&#95;(environ,start_response)进行处理。</p>\n\n<h3>4.5 读取配置文件</h3>\n\n<p>如果希望在不创建应用的情况下得到配置文件，可以使用appconfig(uri)函数，将会以字典形式返回使用的配置。这个字典包括了全局很本地的配置信息，所以可以通过属性方法获得相应的attributes （.local&#95;conf and .global&#95;conf）</p>\n\n<h2>5 其他</h2>\n\n<h3>5.1 如何引用Egg包</h3>\n\n<p>egg是python的一个包，pip easy_install等都是安装egg包的方式。关注egg包要注意：</p>\n\n<ul>\n<li><p>某一egg包是有标准说明的</p>\n\n<p>python setup.py name</p></li>\n<li><p>有entry point，不用太在意，这个只是说明调用程序的参数。</p></li>\n</ul>\n\n<h3>5.2 定义factory函数</h3>\n\n<p>工厂函数的定义还是遵循之前提到的应用的协议。目前，用于工厂函数的协议有以下：</p>\n\n<p>*paste.app_factory</p>\n\n<p>*paste.composite_factory</p>\n\n<p>*paste.filter_factory</p>\n\n<p>*paste.server_factory</p>\n\n<p>所有的这些都希望有一个含有&#95;&#95;call&#95;&#95;方法的（函数，方法，类）。</p>\n\n<p>1.<code>paste.app_factory</code></p>\n\n<pre><code>def app_factory(global_config, **local_conf):\n    return wsgi_app\n</code></pre>\n\n<p>global&#95;config是一个字典，而local&#95;conf则是关键字参数。返回一个wsgi_app（含有<strong>call</strong>方法。）</p>\n\n<p>2.paste.composite_factory`</p>\n\n<pre><code>def composite_factory(loader, global_config, **local_conf):\n   return wsgi_app\n</code></pre>\n\n<p>loader是一个对象，有几个有趣的方法,get&#95;app(name&#95;or&#95;uri, global&#95;conf=None)根据name返回一个wsgi应用，get&#95;filter（）和get&#95;server（）也是一样。看一个更加复杂的例子，举例一个pipeline应用：</p>\n\n<pre><code>def pipeline_factory(loader, global_config, pipeline):\n    # space-separated list of filter and app names:\n    pipeline = pipeline.split()\n    filters = [loader.get_filter(n) for n in pipeline[:-1]]\n    app = loader.get_app(pipeline[-1])\n    filters.reverse() # apply in reverse order!\n    for filter in filters:\n      app = filter(app)\n    return app\n</code></pre>\n\n<p>相应的配置文件如下：</p>\n\n<pre><code>[composite:main]\nuse = \npipeline = egg:Paste#printdebug session myapp\n\n[filter:session]\nuse = egg:Paste#session\nstore = memory\n\n[app:myapp]\nuse = egg:MyApp\n</code></pre>\n\n<p>3.<code>paste.filter_factory</code> fliter的工厂函数和app的共产函数类似，除了它返回的是一个filter,fliter是一个仅仅把一个wsgi应用作为唯一参数的callable对象，返回一个被filter了的应用。 以下是一个例子，这个filter会检查CGI中REMOTE_USER变量是否存在，并创建一个简单的认证过滤器。</p>\n\n<pre><code>def auth_filter_factory(global_conf, req_usernames):\n    # space-separated list of usernames:\n    req_usernames = req_usernames.split()\n    def filter(app):\n        return AuthFilter(app, req_usernames)\n    return filter\n\nclass AuthFilter(object):\n    def __init__(self, app, req_usernames):\n        self.app = app\n        self.req_usernames = req_usernames\n\n    def __call__(self, environ, start_response):\n        if environ.get(''REMOTE_USER'') in self.req_usernames:\n                return self.app(environ, start_response)\n        start_response(\n                ''403 Forbidden'', [(''Content-type'', ''text/html'')])\n        return [''You are forbidden to view this resource'']\n</code></pre>\n\n<p>4.<code>paste.filter_app_factory</code> 和paste.filter_factory类似，接受一个wsgi应用参数，返回一个WSGI应用，所以如果改变以上代码的：</p>\n\n<pre><code>class AuthFilter(object):\n    def __init__(self, app, global_conf, req_usernames):\n        ....\n</code></pre>\n\n<p>那么，类 AuthFilter就会作为一个filter&#95;app&#95;factory函数使用。</p>\n\n<p>5.<code>paste.server_factory</code></p>\n\n<p>与以上不同的是，函数返回的是一个server,一个server也是一个callable对象，以一个WSGI应用作为参数，而后为这个应用服务。</p>\n\n<pre><code>def server_factory(global_conf, host, port):\n    port = int(port)\n    def serve(app):\n        s = Server(app, host=host, port=port)\n        s.serve_forever()\n    return serve\n</code></pre>\n\n<p>Server的实现用户可以自定义，可以参考python包wsgiref</p>\n\n<p>6.<code>paste.server_runner</code> 与 paste.server_factory类似，不同的是参数格式。</p>\n\n<h2>6 其他一些值得讨论的问题</h2>\n\n<p>ConfigParser（PD底层用到这个来解析ini文件）解析ini文件不是很有效率，是否需要更改？</p>\n\n<p>在配置文件中的对象是否需要是python风格的，而不是字符串的形式？</p>\n\n<p>备注：Paste Deployment currently does not require other parts of Paste, and is distributed as a separate package.</p>\n','Python.Paste指南之Deploy(1)-概念','','inherit','open','open','','270-revision-3','','','2013-04-01 13:38:51','2013-04-01 05:38:51','','270','http://blog.wachang.net/2013/04/270-revision-3/','0','revision','','0');");
E_D("replace into `wp_posts` values('274','1','2013-04-01 13:42:46','2013-04-01 05:42:46','<blockquote>\n  <p>浅出OpenStack源码系列</p>\n  \n  <p>Python模块基础篇：Python.Paste指南之Deploy(1)-概念</p>\n</blockquote>\n\n<p>Paste.Deploy主要是用来载入WSGI中的Web App使用，所谓WSGI的app，就是用来处理客户端发送过来的请求的，Python.Paste的核心函数是loadapp(),下文中PD就指代Paste.Deploy。</p>\n\n<h2>1 简介及安装</h2>\n\n<p>Paste Deployment是一种机制，通过loadapp函数和一个配置文件或者egg包来载入WSGI应用。安装很简单，如下两种方式：</p>\n\n<pre><code>\$ sudo pip install PasteDeploy\n</code></pre>\n\n<p>或者可以从github上进行源码安装</p>\n\n<pre><code>\$ hg clone http://bitbucket.org/ianb/pastedeploy\n\$ cd pastedeploy\n\$ sudo python setup.py develop\n</code></pre>\n\n<!--more-->\n\n<h2>2 配置文件Config Flie</h2>\n\n<p>一个配置文件后缀为ini，内容被分为很多段（section），PD只关心带有前缀的段，比如<code>[app:main]</code>或者<code>[filter:errors]</code>，总的来说，一个section的标识就是<code>[type:name]</code>,不是这种类型的section将会被忽略。</p>\n\n<p>一个section的内容是以<code>键=值</code>来标示的。#是一个注释。在段的定义中，有以下几类：</p>\n\n<ul>\n<li><p>[app:main]:定义WSGI应用，main表示只有一个应用，有多个应用的话main改为应用名字</p></li>\n<li><p>[server:main]:定义WSGI的一个server。</p></li>\n<li><p>[composite:xxx]：表示需要将一个请求调度定向（dispatched）到多个,或者多种应用上。以下是一个简单的例子，例子中，使用了composite，通过urlmap来实现载入多应用。</p></li>\n<li><p>[fliter:]：定义“过滤器”，将应用进行进一步的封装。</p></li>\n<li><p>[DEFAULT]：定义一些默认变量的值。</p></li>\n</ul>\n\n<p>以下是一个例子：</p>\n\n<pre><code>[composite:main]\nuse = egg:Paste#urlmap\n/ = home\n/blog = blog\n/wiki = wiki\n/cms = config:cms.ini\n\n[app:home]\nuse = egg:Paste#static\ndocument_root = %(here)s/htdocs\n\n[filter-app:blog]\nuse = egg:Authentication#auth\nnext = blogapp\nroles = admin\nhtpasswd = /home/me/users.htpasswd\n\n[app:blogapp]\nuse = egg:BlogApp\ndatabase = sqlite:/home/me/blog.db\n\n[app:wiki]\nuse = call:mywiki.main:application\ndatabase = sqlite:/home/me/wiki.db\n</code></pre>\n\n<p>下面会进行分段的讲解</p>\n\n<h3>2.1 composite</h3>\n\n<pre><code>[composite:main]\nuse = egg:Paste#urlmap\n/ = home\n/blog = blog\n/wiki = wiki\n/cms = config:cms.ini\n</code></pre>\n\n<p>这是一个composite段，表示这将会根据一些条件将web请求调度到不同的应用。<code>use = egg:Paste#urlmap</code>表示我们奖使用<code>Paste</code>egg包中<code>urlmap</code>来实现composite，这一个段(urlmap)可以算是一个通用的composite程序了。根据web请求的path的前缀进行一个到应用的映射(map)。这些被映射的程序就包括blog,home,wiki,config:cms.ini（映射到了另外一个配置文件，PD再根据这个文件进行载入）</p>\n\n<h3>2.2 App type1</h3>\n\n<pre><code>[app:home]\nuse = egg:Paste#static\ndocument_root = %(here)s/htdocs\n</code></pre>\n\n<p>app是一个callable object，接受的参数(environ,start&#95;response)，这是paste系统交给application的，符合WSGI规范的参数. app需要完成的任务是响应envrion中的请求，准备好响应头和消息体，然后交给start&#95;response处理，并返回响应消息体。<code>egg:Paste#static</code>也是Paste包中的一个简单程序，它只处理静态文件。它需要一个配置文件document_root,后面的值可以是一个变量,形式为%（var）s相应的值应该在[DEFAULT]字段指明以便Paste读取。比如：</p>\n\n<pre><code>[app:test]\nuse = egg:Paste#static\ndocument_root = %(path)s/htdocs\n[DEFAULT]\npath = /etc/test\n</code></pre>\n\n<h3>2.3 fliter</h3>\n\n<p>filter是一个callable object，其唯一参数是(app)，这是WSGI的application对象，filter需要完成的工作是将application包装成另一个application（“过滤”），并返回这个包装后的application。</p>\n\n<pre><code>[filter-app:blog]\nuse = egg:Authentication#auth\nnext = blogapp\nroles = admin\nhtpasswd = /home/me/users.htpasswd\n\n[app:blogapp]\nuse = egg:BlogApp\ndatabase = sqlite:/home/me/blog.db\n</code></pre>\n\n<p><code>[filter-app:blog]</code>fliter-app字段表明你希望对某个应用进行包装，需要包装的应用通过next指明（表明在下一个段中），这个字段的意思就是，在正式调用blogapp之前，我会调用egg:Authentication#auth进行一个用户的验证，随后才会调用blogapp进行处理。后面的[app:blogapp]则是定义了blogapp，并指明了需要的database参数。</p>\n\n<h3>2.4 App type2</h3>\n\n<pre><code>[app:wiki]\nuse = call:mywiki.main:application\ndatabase = sqlite:/home/me/wiki.db\n</code></pre>\n\n<p>这个段和之前的app段定义类似，不同的是对于wiki这个应用，我们没有使用egg包，而是直接对mywiki.main这个模块中的application对象使用了call方法。python，中一切皆对象，作为WSGI app的可以是一个函数，一个类，或者一个实例，使用call的话，相应的函数，类，实例中必须实现<strong>call</strong>()方法。此类app的格式用冒号分割: <code>call(表示使用call方法):模块的完成路径名字:应用变量的完整名字</code></p>\n\n<h2>3 基本使用</h2>\n\n<p>PD的主要使用就是通过读取配置文件载入WSGI应用。如下：</p>\n\n<pre><code>from paste.deploy import loadapp\nwsgi_app = loadapp(''config:/path/to/config.ini'')\n</code></pre>\n\n<p>注意，这里需要指明绝对路径。</p>\n\n<h2>4 更多关于配置文件</h2>\n\n<h3>4.1 App</h3>\n\n<p>单个配置文件中可以定义多个应用个，每个应用有自己独立的段。应用的定义以[app:name]的格式，[app:main]表示只有一个应用。应用的定义支持以下五种格式：</p>\n\n<pre><code>[app:myapp]\nuse = config:another_config_file.ini#app_name\n#使用另外一个配置文件\n\n[app:myotherapp]\nuse = egg:MyApp\n#使用egg包中的内容\n\n[app:mythirdapp]\nuse = call:my.project:myapplication\n#使用模块中的callable对象\n\n[app:mylastapp]\nuse = myotherapp\n#使用另外一个section\n\n[app:myfacapp]\npaste.app_factory = myapp.modulename:app_factory\n#使用工厂函数\n</code></pre>\n\n<p>其中，最后一种方式，将一个app指向了某些python代码。此模式下，必须执行app协议，以app&#95;factory表示，后面的值需要import的东西，在这个例子中myapp.modulename被载入，并从其中取得了app&#95;factory的实例。</p>\n\n<p>app_factory是一个callable object，其接受的参数是一些关于application的配置信息：<code>(global_conf,**kwargs)</code>，<code>global_conf</code>是在ini文件中default section中定义的一系列key-value对，而<code>**kwargs</code>，即一些本地配置，是在ini文件中，app:xxx section中定义的一系列key-value对。app_factory返回值是一个application对象</p>\n\n<p>在app的配置中，use参数以后配置就算结束了。其余的键值参数将会作为参数，传递到factory中，如下：</p>\n\n<pre><code>[app:blog]\nuse = egg:MyBlog\ndatabase = mysql://localhost/blogdb #这是参数\nblogname = This Is My Blog! #这是参数\n</code></pre>\n\n<h3>4.2 全局配置</h3>\n\n<p>全局配置主要是用于多个应用共用一些变量，这些变量我们规定放在段[DEFAULT]中，如果需要覆盖，可以在自己的app中重新定义，如下：</p>\n\n<pre><code>[DEFAULT]\nadmin_email = webmaster@example.com\n[app:main]\nuse = ...\nset admin_email = bob@example.com\n</code></pre>\n\n<h3>4.3 composite app</h3>\n\n<p>composite是一个运行着像是app，但是实际上是由多个应用组成的。urlmap就是composite app的一个例子，url不同的path对应了不同的应用。如下：</p>\n\n<pre><code>[composite:main]\nuse = egg:Paste#urlmap\n/ = mainapp\n/files = staticapp\n\n[app:mainapp]\nuse = egg:MyApp\n\n[app:staticapp]\nuse = egg:Paste#static\ndocument_root = /path/to/docroot\n</code></pre>\n\n<p>在loadapp函数的执行中，composite app被实例化，它同时还会访问配置文件中定义的其他应用。</p>\n\n<h3>4.4 app定义高级用法</h3>\n\n<p>在app段中，你可以定义fliters和servers，通过<code>fliter:</code>和<code>server:</code> PD通过loadserver和loadfilter函数进行调用，工作机制都一样，返回不同的对象。</p>\n\n<h4>4.4.1 filter composition</h4>\n\n<p>应用filter的方式很多，重要的是看你filter的数量和组织形式。下面会一一介绍应用fliter的几种方式：</p>\n\n<p>1.使用<code>filter-with</code></p>\n\n<pre><code>[app:main]\nuse = egg:MyEgg\nfilter-with = printdebug\n\n[filter:printdebug]\nuse = egg:Paste#printdebug\n# and you could have another filter-with here, and so on...\n</code></pre>\n\n<p>2.使用<code>fliter-app</code></p>\n\n<pre><code>[fliter-app:printdebug]\nuse = egg:Paste\nnext = main\n\n[app:main]\nuse = egg:MyEgg\n</code></pre>\n\n<p>3.使用pipeline</p>\n\n<p>当使用多个filter的时候需要使用pipeline的方式，它需要提供一个key参数pipeline,后面的值是一个列表，最后以应用结尾。如下：</p>\n\n<pre><code>[pipeline:main]\npipeline = filter1 egg:FilterEgg#filter2 filter3 app\n\n[filter:filter1]\n...\n</code></pre>\n\n<p>假设在ini文件中, 某条pipeline的顺序是filter1, filter2, filter3，app, 那么，最终运行的app&#95;real是这样组织的： app&#95;real = filter1(filter2(filter3(app)))</p>\n\n<p>在app真正被调用的过程中，filter1.&#95;&#95;call&#95;&#95;(environ,start&#95;response)被首先调用，若某种检查未通过，filter1做出反应；否则交给filter2.&#92;_&#95;call&#92;_&#95;(environ,start&#95;response)进一步处理，若某种检查未通过，filter2做出反应，中断链条，否则交给filter3.&#92;&#95;&#95;call&#95;&#95;(environ,start&#95;response)处理，若filter3的某种检查都通过了，最后交给app.&#92;&#95;&#95;call_&#95;(environ,start&#95;response)进行处理。</p>\n\n<h3>4.5 读取配置文件</h3>\n\n<p>如果希望在不创建应用的情况下得到配置文件，可以使用appconfig(uri)函数，将会以字典形式返回使用的配置。这个字典包括了全局很本地的配置信息，所以可以通过属性方法获得相应的attributes （.local&#95;conf and .global&#95;conf）</p>\n\n<h2>5 其他</h2>\n\n<h3>5.1 如何引用Egg包</h3>\n\n<p>egg是python的一个包，pip easy_install等都是安装egg包的方式。关注egg包要注意：</p>\n\n<ul>\n<li><p>某一egg包是有标准说明的</p>\n\n<p>python setup.py name</p></li>\n<li><p>有entry point，不用太在意，这个只是说明调用程序的参数。</p></li>\n</ul>\n\n<h3>5.2 定义factory函数</h3>\n\n<p>工厂函数的定义还是遵循之前提到的应用的协议。目前，用于工厂函数的协议有以下：</p>\n\n<p>*paste.app_factory</p>\n\n<p>*paste.composite_factory</p>\n\n<p>*paste.filter_factory</p>\n\n<p>*paste.server_factory</p>\n\n<p>所有的这些都希望有一个含有&#95;&#95;call&#95;&#95;方法的（函数，方法，类）。</p>\n\n<p>1.<code>paste.app_factory</code></p>\n\n<pre><code>def app_factory(global_config, **local_conf):\n    return wsgi_app\n</code></pre>\n\n<p>global&#95;config是一个字典，而local&#95;conf则是关键字参数。返回一个wsgi_app（含有<strong>call</strong>方法。）</p>\n\n<p>2.paste.composite_factory`</p>\n\n<pre><code>def composite_factory(loader, global_config, **local_conf):\n   return wsgi_app\n</code></pre>\n\n<p>loader是一个对象，有几个有趣的方法,get&#95;app(name&#95;or&#95;uri, global&#95;conf=None)根据name返回一个wsgi应用，get&#95;filter（）和get&#95;server（）也是一样。看一个更加复杂的例子，举例一个pipeline应用：</p>\n\n<pre><code>def pipeline_factory(loader, global_config, pipeline):\n    # space-separated list of filter and app names:\n    pipeline = pipeline.split()\n    filters = [loader.get_filter(n) for n in pipeline[:-1]]\n    app = loader.get_app(pipeline[-1])\n    filters.reverse() # apply in reverse order!\n    for filter in filters:\n      app = filter(app)\n    return app\n</code></pre>\n\n<p>相应的配置文件如下：</p>\n\n<pre><code>[composite:main]\nuse = \npipeline = egg:Paste#printdebug session myapp\n\n[filter:session]\nuse = egg:Paste#session\nstore = memory\n\n[app:myapp]\nuse = egg:MyApp\n</code></pre>\n\n<p>3.<code>paste.filter_factory</code></p>\n\n<p>fliter的工厂函数和app的共产函数类似，除了它返回的是一个filter,fliter是一个仅仅把一个wsgi应用作为唯一参数的callable对象，返回一个被filter了的应用。 以下是一个例子，这个filter会检查CGI中REMOTE_USER变量是否存在，并创建一个简单的认证过滤器。</p>\n\n<pre><code>def auth_filter_factory(global_conf, req_usernames):\n    # space-separated list of usernames:\n    req_usernames = req_usernames.split()\n    def filter(app):\n        return AuthFilter(app, req_usernames)\n    return filter\n\nclass AuthFilter(object):\n    def __init__(self, app, req_usernames):\n        self.app = app\n        self.req_usernames = req_usernames\n\n    def __call__(self, environ, start_response):\n        if environ.get(''REMOTE_USER'') in self.req_usernames:\n                return self.app(environ, start_response)\n        start_response(\n                ''403 Forbidden'', [(''Content-type'', ''text/html'')])\n        return [''You are forbidden to view this resource'']\n</code></pre>\n\n<p>4.<code>paste.filter_app_factory</code></p>\n\n<p>和paste.filter_factory类似，接受一个wsgi应用参数，返回一个WSGI应用，所以如果改变以上代码的：</p>\n\n<pre><code>class AuthFilter(object):\n    def __init__(self, app, global_conf, req_usernames):\n        ....\n</code></pre>\n\n<p>那么，类 AuthFilter就会作为一个filter&#95;app&#95;factory函数使用。</p>\n\n<p>5.<code>paste.server_factory</code></p>\n\n<p>与以上不同的是，函数返回的是一个server,一个server也是一个callable对象，以一个WSGI应用作为参数，而后为这个应用服务。</p>\n\n<pre><code>def server_factory(global_conf, host, port):\n    port = int(port)\n    def serve(app):\n        s = Server(app, host=host, port=port)\n        s.serve_forever()\n    return serve\n</code></pre>\n\n<p>Server的实现用户可以自定义，可以参考python包wsgiref</p>\n\n<p>6.<code>paste.server_runner</code></p>\n\n<p>与 paste.server_factory类似，不同的是参数格式。</p>\n\n<h2>6 其他一些值得讨论的问题</h2>\n\n<p>ConfigParser（PD底层用到这个来解析ini文件）解析ini文件不是很有效率，是否需要更改？</p>\n\n<p>在配置文件中的对象是否需要是python风格的，而不是字符串的形式？</p>\n\n<p>备注：Paste Deployment currently does not require other parts of Paste, and is distributed as a separate package.</p>\n','Python.Paste指南之Deploy(1)-概念','','inherit','open','open','','270-revision-4','','','2013-04-01 13:42:46','2013-04-01 05:42:46','','270','http://blog.wachang.net/2013/04/270-revision-4/','0','revision','','0');");
E_D("replace into `wp_posts` values('275','1','2013-04-01 13:53:23','2013-04-01 05:53:23','<p>上一节中梳理了Python Paste中Deploy机制的概念，这一节就做一点小小的实践。首先，我们举一个使用了Deploy的例子，这个就是OpenStack的Quantum组件的WSGI部分。我们先来看关于WSGI部分的配置文件，以ini后缀，那么就是api-paste.ini文件，决定了API的处理流程。我加入了适当的注释。</p>\n\n<!--more-->\n\n<h2>1 OpenStack Quantum配置文件api-paste.ini</h2>\n\n<pre><code>[composite:quantum]\nuse = egg:Paste#urlmap\n/: quantumversions\n/v2.0: quantumapi_v2_0\n#使用composite分解机制，composite使用了usrlmap，xxxxx/xxx的API交给quantumversions处理。xxxx/v2.0/xxxx的API交给quantumapi_v2_0处理。\n\n[composite:quantumapi_v2_0]\nuse = call:quantum.auth:pipeline_factory\nnoauth = extensions quantumapiapp_v2_0\nkeystone = authtoken keystonecontext extensions quantumapiapp_v2_0\n#quantumapi_v2_0依然是一个分解组件，使用了quantum.auth模块下的pipeline_factory，对于这个factory，传递了两个参数，一个是noauth,一个是keystone。\n\n[filter:keystonecontext]\npaste.filter_factory = quantum.auth:QuantumKeystoneContext.factory\n#对于keystonecontext，实际上是一个过滤器，使用了quantum.auth模块下的类的QuantumKeystoneContext的factory函数\n\n[filter:authtoken]\npaste.filter_factory = keystone.middleware.auth_token:filter_factory\nauth_host = 127.0.0.1\nauth_port = 35357\nauth_protocol = http\nadmin_tenant_name = %SERVICE_TENANT_NAME%\nadmin_user = %SERVICE_USER%\nadmin_password = %SERVICE_PASSWORD%\n#定义了另外一个filter\n\n[filter:extensions]\npaste.filter_factory = quantum.extensions.extensions:plugin_aware_extension_middleware_factory\n#定义了另外一个filter,这个filter是为了支持扩展quantum api的\n\n[app:quantumversions]\npaste.app_factory = quantum.api.versions:Versions.factory\n#核心的app部分，使用工厂函数，将app指向python代码。app_factory表明这个函数接收一系列参数，[DEFAULET]以及[app:]下面的，本部分本section没有参数，并返回一个函数对象。\n\n[app:quantumapiapp_v2_0]\npaste.app_factory = quantum.api.v2.router:APIRouter.factory\n#同上\n</code></pre>\n\n<p>我们来总结一下，整个Quantum处理api的流程如下,其中，强调的部分为函数代码，其他为配置文件中的section部分。</p>\n\n<p>对于路径为<code>/</code>类的API-->quantumversions处理-->调用<code>quantum.api.versions:Version</code>类的<code>factory函数</code>处理。</p>\n\n<p>对于路径为<code>/2.0</code>类的API-->quantumapi&#95;v2&#95;0处理-->调用<code>quantum.auth</code>中的<code>pipeline_factory</code>处理,同时传递了两个参数noauth和keystone,类型为字典。</p>\n\n<p>这个pipeline_factory中会读取另外一个变量CONF.auth（来自另外一个配置文件，不考虑），选择采用的认证方式，然后选择noauth或者keystone，并读取参数的值.</p>\n\n<p>那么，就有两种情况：</p>\n\n<p>noauth: 应用将会先经过extensions这个filter处理&#45;--|||-调用了<code>quantum.extensions.extensions:plugin_aware_extension_middleware_factory</code>，用来处理扩展api请求，这是第一次包装&#45;--|||-quantumapiapp&#95;v2&#95;0，这才是实际的WSGI应用，调用了<code>quantum.api.v2.router:APIRouter.factory</code>，并处理返回结果。</p>\n\n<p>keystone：和上面类似，不同的是多了几个filter,authtoken keystonecontext extensions quantumapiapp&#95;v2&#95;0,并且在每个filter中可能还会有参数传递给这个fliter。</p>\n\n<p>总的来说，通过pipeline装载多个filter,将最基本的app--APIRouter，层层包装，使其变为一个具有处理认证，扩展API等的应用（逻辑上看），filter的好处就是可以自定义，比如可以不要认证功能，这比写一个囊括全部功能的应用明显要好的多。</p>\n\n<h2>2 代码实践</h2>\n\n<h3>2.1 配置文件</h3>\n\n<pre><code>[DEFAULT]\ncompany = UESTC\nschool = Commuication and Information\n\n[composite:common]\nuse = egg:Paste#urlmap\n/:showversion\n/detail:showdetail\n\n[pipeline:showdetail]\npipeline = filter1 filter2 showstudetail\n\n[filter:filter1]\n#filter1 deal with auth,read args below\npaste.filter_factory = python_paste:AuthFilter.factory\nuser = admin\npasswd = admin\n\n[filter:filter2]\n#filter2 deal with time,read args below\npaste.filter_factory = python_paste:LogFilter.factory\n#all value is string\ndate = 20121120\n\n[app:showstudetail]\nname = wangchang\nage = 23\npaste.app_factory = python_paste:ShowStuDetail.factory\n\n[app:showversion]\nversion = 1.0.0\n</code></pre>\n\n<p>从配置文件可以看出，这个程序会有如下操作：</p>\n\n<ul>\n<li>对于http://localhost/的访问，会调用showversion这个应用，应用读取ini文件中的version值并返回。__注意，在ini中的所有值都是字符串。</li>\n<li>对于http://localhost/detail的访问，会先经过filter1以及filter2，这两个filter分别处理认证和LOG信息，他们会读取ini配置中的用户信息以及时间。最后才是交给showstudetail处理，showstudetail会读取ini中的用户信息并返回。__注意，使用多个filter的时候需要使用pipeline方式。</li>\n</ul>\n\n<h3>2.2 代码</h3>\n\n<pre><code>import sys\nimport os\nimport webob\nfrom webob import Request\nfrom webob import Response\n#from webob import environ\nfrom paste.deploy import loadapp\nfrom wsgiref.simple_server import make_server\nfrom pprint import pprint\n\nclass AuthFilter(object):\n      ''''''filter1,auth\n         1.factory read args and print,return self instance\n         2.call method return app\n         3.AuthFilter(app)\n      ''''''\n      def __init__(self,app):\n          self.app = app\n\n      def __call__(self,environ,start_response):\n          print ''this is Auth call filter1''\n          #pass environ and start_response to app\n          return self.app(environ,start_response)\n      @classmethod\n      def factory(cls,global_conf,**kwargs):\n          ''''''global_conf and kwargs are dict''''''\n          print ''######filter1##########''\n          print ''global_conf type:'',type(global_conf)\n          print ''[DEFAULT]'',global_conf\n          print ''kwargs type:'',type(kwargs)\n          print ''Auth Info'',kwargs\n          return AuthFilter\n\nclass LogFilter(object):\n      ''''''\n      filter2,Log\n      ''''''\n      def __init__(self,app):\n          self.app = app\n      def __call__(self,environ,start_response):\n          print ''This is call LogFilter filter2''\n          return self.app(environ,start_response)\n      @classmethod\n      def factory(cls,global_conf,**kwargs):\n          #print type(global_conf)\n          #print type(kwargs)\n          print ''######filter2###########''\n          print ''[DEFAULT]'',global_conf\n          print ''Log Info'',kwargs\n          return LogFilter\n\nclass ShowStuDetail(object):\n      ''''''\n      app\n      ''''''\n      def __init__(self,name,age):\n          self.name = name\n          self.age = age\n      def __call__(self,environ,start_response):\n          print ''this is call ShowStuDetail''\n          #pprint(environ)\n          #pprint environ\n          start_response(\"200 OK\",[(\"Content-type\",\"text/plain\")])\n          content = []\n          content.append(\"name: %s age:%s\\\\n\" % (self.name,self.age))\n          content.append(\"**********WSGI INFO***********\\\\n\")\n          for k,v in environ.iteritems():\n              content.append(''%s:%s \\\\n'' % (k,v))\n          return [''\\\\n''.join(content)] #return a list\n\n      @classmethod\n      def factory(cls,global_conf,**kwargs):\n          #self.name = kwargs[''name'']\n          #self.age = kwargs[''age'']\n          return ShowStuDetail(kwargs[''name''],kwargs[''age''])\n\nclass ShowVersion(object):\n      ''''''\n      app\n      ''''''\n      def __init__(self,version):\n          self.version = version\n      def __call__(self,environ,start_response):\n          print ''this is call ShowVersion''\n          req = Request(environ)\n          res = Response()\n          res.status = ''200 OK''\n          res.content_type = \"text/plain\"\n          content = []\n          #pprint(req.environ)\n          content.append(\"%s\\\\n\" % self.version)\n          content.append(\"*********WSGI INFO*********\")\n          for k,v in environ.iteritems():\n              content.append(''%s:%s\\\\n'' % (k,v))\n          res.body = ''\\\\n''.join(content)\n          return res(environ,start_response)\n      @classmethod\n      def factory(cls,global_conf,**kwargs):\n          #self.version = kwargs[''version'']\n          return ShowVersion(kwargs[''version''])\n\nif __name__ == ''__main__'':\n     config = \"python_paste.ini\"\n     appname = \"common\"\n     wsgi_app = loadapp(\"config:%s\" % os.path.abspath(config), appname)\n     server = make_server(''localhost'',7070,wsgi_app)\n     server.serve_forever()\n     pass\n</code></pre>\n\n<p>在程序中，对于web请求的处理，我分别采用了webob和普通WSGI定义的方式，后续我会补上webob的使用。</p>\n\n<h3>2.3 结果</h3>\n\n<p>先从服务端结果分析一下调用流程：</p>\n\n<pre><code>Ubuntu:~/python\$ python python_paste.py\n######filter1##########\nglobal_conf type: \n[DEFAULT] {''school'': ''Commuication and Information'', ''company'': ''UESTC'', ''here'':         ''/home/wachang/python'', ''__file__'': ''/home/wachang/python/python_paste.ini''}\nkwargs type: \nAuth Info {''passwd'': ''admin'', ''user'': ''admin''}\n######filter2###########\n[DEFAULT] {''school'': ''Commuication and Information'', ''company'': ''UESTC'', ''here'':     ''/home/wachang/python'', ''__file__'': ''/home/wachang/python/python_paste.ini''}\nLog Info {''date'': ''20121120''}\n以上是PD载入应用时，调用filter的factory方法输出的结果，可以看到，此读出了相关的变量信息。\n\n\nthis is call ShowVersion\nlocalhost - - [21/Nov/2012 13:23:40] \"GET / HTTP/1.1\" 200 2938\nthis is call ShowVersion\nlocalhost - - [21/Nov/2012 13:23:40] \"GET /favicon.ico HTTP/1.1\" 200 2889\n以上是接收/请求，因为没有使用filter，直接交予showversion应用处理，并返回。\n\nthis is Auth call filter1\nThis is call LogFilter filter2\nthis is call ShowStuDetail\nlocalhost - - [21/Nov/2012 13:24:23] \"GET /detail HTTP/1.1\" 200 3016\nthis is call ShowVersion\nlocalhost - - [21/Nov/2012 13:24:24] \"GET /favicon.ico HTTP/1.1\" 200 2889\nfilter的调用时重点啊，可以看到，调用的顺序和pipeline中一样。最后才调用应用。\n</code></pre>\n\n<p>需要继续折腾的话，就看看<a href=\"http://docs.webob.org/en/latest/do-it-yourself.html\">webob:do-it-yourselfrself</a></p>\n','Python.Paste指南之Deploy(2)-实践','','publish','open','open','','python-paste-deploy-2','','','2013-04-01 14:03:11','2013-04-01 06:03:11','','0','http://blog.wachang.net/?p=275','0','post','','0');");
E_D("replace into `wp_posts` values('276','1','2013-04-01 11:09:37','2013-04-01 03:09:37','<h1>浅出OpenStack源码系列</h1>\n\n<h2>2.Quantum篇</h2>\n\n<h3>2.3 OpenvSwitch Plugin</h3>\n\n<p><a href=\"http://blog.wachang.net/2013/03/quantum-ovs-plugin-code-structure/\">Quantum OpenvSwitch Plugin代码架构</a></p>\n\n<p><a href=\"http://blog.wachang.net/2013/03/quantum-ovs-agent-config-file/\">Quantum OpenvSwitch Plugin&amp;Agent读取配置文件</a></p>\n\n<p><a href=\"http://blog.wachang.net/2013/03/quantum-ovs-plugin-agent-rpc-1/\">Quantum OpenvSwitch Plugin和Agent的RPC机制（一）</a></p>\n','浅出OpenStack源码','','inherit','open','open','','209-revision-5','','','2013-04-01 11:09:37','2013-04-01 03:09:37','','209','http://blog.wachang.net/2013/04/209-revision-5/','0','revision','','0');");
E_D("replace into `wp_posts` values('277','1','2013-04-01 13:53:14','2013-04-01 05:53:14','<p>上一节中梳理了Python Paste中Deploy机制的概念，这一节就做一点小小的实践。首先，我们举一个使用了Deploy的例子，这个就是OpenStack的Quantum组件的WSGI部分。我们先来看关于WSGI部分的配置文件，以ini后缀，那么就是api-paste.ini文件，决定了API的处理流程。我加入了适当的注释。</p>\n\n<!--more-->\n\n<h2>1 OpenStack Quantum配置文件api-paste.ini</h2>\n\n<pre><code>[composite:quantum]\nuse = egg:Paste#urlmap\n/: quantumversions\n/v2.0: quantumapi_v2_0\n#使用composite分解机制，composite使用了usrlmap，xxxxx/xxx的API交给quantumversions处理。xxxx/v2.0/xxxx的API交给quantumapi_v2_0处理。\n\n[composite:quantumapi_v2_0]\nuse = call:quantum.auth:pipeline_factory\nnoauth = extensions quantumapiapp_v2_0\nkeystone = authtoken keystonecontext extensions quantumapiapp_v2_0\n#quantumapi_v2_0依然是一个分解组件，使用了quantum.auth模块下的pipeline_factory，对于这个factory，传递了两个参数，一个是noauth,一个是keystone。\n\n[filter:keystonecontext]\npaste.filter_factory = quantum.auth:QuantumKeystoneContext.factory\n#对于keystonecontext，实际上是一个过滤器，使用了quantum.auth模块下的类的QuantumKeystoneContext的factory函数\n\n[filter:authtoken]\npaste.filter_factory = keystone.middleware.auth_token:filter_factory\nauth_host = 127.0.0.1\nauth_port = 35357\nauth_protocol = http\nadmin_tenant_name = %SERVICE_TENANT_NAME%\nadmin_user = %SERVICE_USER%\nadmin_password = %SERVICE_PASSWORD%\n#定义了另外一个filter\n\n[filter:extensions]\npaste.filter_factory = quantum.extensions.extensions:plugin_aware_extension_middleware_factory\n#定义了另外一个filter,这个filter是为了支持扩展quantum api的\n\n[app:quantumversions]\npaste.app_factory = quantum.api.versions:Versions.factory\n#核心的app部分，使用工厂函数，将app指向python代码。app_factory表明这个函数接收一系列参数，[DEFAULET]以及[app:]下面的，本部分本section没有参数，并返回一个函数对象。\n\n[app:quantumapiapp_v2_0]\npaste.app_factory = quantum.api.v2.router:APIRouter.factory\n#同上\n</code></pre>\n\n<p>我们来总结一下，整个Quantum处理api的流程如下,其中，强调的部分为函数代码，其他为配置文件中的section部分。</p>\n\n<p>对于路径为<code>/</code>类的API----quantumversions处理----调用<code>quantum.api.versions:Version</code>类的<code>factory函数</code>处理。</p>\n\n<p>对于路径为<code>/2.0</code>类的API----quantumapi_v2_0处理----调用<code>quantum.auth</code>中的<code>pipeline_factory</code>处理,同时传递了两个参数noauth和keystone,类型为字典。</p>\n\n<p>这个pipeline_factory中会读取另外一个变量CONF.auth（来自另外一个配置文件，不考虑），选择采用的认证方式，然后选择noauth或者keystone，并读取参数的值.</p>\n\n<p>那么，就有两种情况：</p>\n\n<p>noauth: 应用将会先经过extensions这个filter处理----调用了<code>quantum.extensions.extensions:plugin_aware_extension_middleware_factory</code>，用来处理扩展api请求，这是第一次包装----quantumapiapp_v2_0，这才是实际的WSGI应用，调用了<code>quantum.api.v2.router:APIRouter.factory</code>，并处理返回结果。</p>\n\n<p>keystone：和上面类似，不同的是多了几个filter,authtoken keystonecontext extensions quantumapiapp_v2_0,并且在每个filter中可能还会有参数传递给这个fliter。</p>\n\n<p>总的来说，通过pipeline装载多个filter,将最基本的app--APIRouter，层层包装，使其变为一个具有处理认证，扩展API等的应用（逻辑上看），filter的好处就是可以自定义，比如可以不要认证功能，这比写一个囊括全部功能的应用明显要好的多。</p>\n\n<h2>2 代码实践</h2>\n\n<h3>2.1 配置文件</h3>\n\n<pre><code>[DEFAULT]\ncompany = UESTC\nschool = Commuication and Information\n\n[composite:common]\nuse = egg:Paste#urlmap\n/:showversion\n/detail:showdetail\n\n[pipeline:showdetail]\npipeline = filter1 filter2 showstudetail\n\n[filter:filter1]\n#filter1 deal with auth,read args below\npaste.filter_factory = python_paste:AuthFilter.factory\nuser = admin\npasswd = admin\n\n[filter:filter2]\n#filter2 deal with time,read args below\npaste.filter_factory = python_paste:LogFilter.factory\n#all value is string\ndate = 20121120\n\n[app:showstudetail]\nname = wangchang\nage = 23\npaste.app_factory = python_paste:ShowStuDetail.factory\n\n[app:showversion]\nversion = 1.0.0\n</code></pre>\n\n<p>从配置文件可以看出，这个程序会有如下操作：\n*对于http://localhost/的访问，会调用showversion这个应用，应用读取ini文件中的version值并返回。__注意，在ini中的所有值都是字符串。</p>\n\n<p>对于http://localhost/detail的访问，会先经过filter1以及filter2，这两个filter分别处理认证和LOG信息，他们会读取ini配置中的用户信息以及时间。最后才是交给showstudetail处理，showstudetail会读取ini中的用户信息并返回。__注意，使用多个filter的时候需要使用pipeline方式。</p>\n\n<h3>2.2 代码</h3>\n\n<pre><code>import sys\nimport os\nimport webob\nfrom webob import Request\nfrom webob import Response\n#from webob import environ\nfrom paste.deploy import loadapp\nfrom wsgiref.simple_server import make_server\nfrom pprint import pprint\n\nclass AuthFilter(object):\n      ''''''filter1,auth\n         1.factory read args and print,return self instance\n         2.call method return app\n         3.AuthFilter(app)\n      ''''''\n      def __init__(self,app):\n          self.app = app\n\n      def __call__(self,environ,start_response):\n          print ''this is Auth call filter1''\n          #pass environ and start_response to app\n          return self.app(environ,start_response)\n      @classmethod\n      def factory(cls,global_conf,**kwargs):\n          ''''''global_conf and kwargs are dict''''''\n          print ''######filter1##########''\n          print ''global_conf type:'',type(global_conf)\n          print ''[DEFAULT]'',global_conf\n          print ''kwargs type:'',type(kwargs)\n          print ''Auth Info'',kwargs\n          return AuthFilter\n\nclass LogFilter(object):\n      ''''''\n      filter2,Log\n      ''''''\n      def __init__(self,app):\n          self.app = app\n      def __call__(self,environ,start_response):\n          print ''This is call LogFilter filter2''\n          return self.app(environ,start_response)\n      @classmethod\n      def factory(cls,global_conf,**kwargs):\n          #print type(global_conf)\n          #print type(kwargs)\n          print ''######filter2###########''\n          print ''[DEFAULT]'',global_conf\n          print ''Log Info'',kwargs\n          return LogFilter\n\nclass ShowStuDetail(object):\n      ''''''\n      app\n      ''''''\n      def __init__(self,name,age):\n          self.name = name\n          self.age = age\n      def __call__(self,environ,start_response):\n          print ''this is call ShowStuDetail''\n          #pprint(environ)\n          #pprint environ\n          start_response(\"200 OK\",[(\"Content-type\",\"text/plain\")])\n          content = []\n          content.append(\"name: %s age:%s\\\\n\" % (self.name,self.age))\n          content.append(\"**********WSGI INFO***********\\\\n\")\n          for k,v in environ.iteritems():\n              content.append(''%s:%s \\\\n'' % (k,v))\n          return [''\\\\n''.join(content)] #return a list\n\n      @classmethod\n      def factory(cls,global_conf,**kwargs):\n          #self.name = kwargs[''name'']\n          #self.age = kwargs[''age'']\n          return ShowStuDetail(kwargs[''name''],kwargs[''age''])\n\nclass ShowVersion(object):\n      ''''''\n      app\n      ''''''\n      def __init__(self,version):\n          self.version = version\n      def __call__(self,environ,start_response):\n          print ''this is call ShowVersion''\n          req = Request(environ)\n          res = Response()\n          res.status = ''200 OK''\n          res.content_type = \"text/plain\"\n          content = []\n          #pprint(req.environ)\n          content.append(\"%s\\\\n\" % self.version)\n          content.append(\"*********WSGI INFO*********\")\n          for k,v in environ.iteritems():\n              content.append(''%s:%s\\\\n'' % (k,v))\n          res.body = ''\\\\n''.join(content)\n          return res(environ,start_response)\n      @classmethod\n      def factory(cls,global_conf,**kwargs):\n          #self.version = kwargs[''version'']\n          return ShowVersion(kwargs[''version''])\n\nif __name__ == ''__main__'':\n     config = \"python_paste.ini\"\n     appname = \"common\"\n     wsgi_app = loadapp(\"config:%s\" % os.path.abspath(config), appname)\n     server = make_server(''localhost'',7070,wsgi_app)\n     server.serve_forever()\n     pass\n</code></pre>\n\n<p>在程序中，对于web请求的处理，我分别采用了webob和普通WSGI定义的方式，后续我会补上webob的使用。</p>\n\n<h3>2.3 结果</h3>\n\n<p>先从服务端结果分析一下调用流程：</p>\n\n<pre><code>Ubuntu:~/python\$ python python_paste.py\n######filter1##########\nglobal_conf type: \n[DEFAULT] {''school'': ''Commuication and Information'', ''company'': ''UESTC'', ''here'':         ''/home/wachang/python'', ''__file__'': ''/home/wachang/python/python_paste.ini''}\nkwargs type: \nAuth Info {''passwd'': ''admin'', ''user'': ''admin''}\n######filter2###########\n[DEFAULT] {''school'': ''Commuication and Information'', ''company'': ''UESTC'', ''here'':     ''/home/wachang/python'', ''__file__'': ''/home/wachang/python/python_paste.ini''}\nLog Info {''date'': ''20121120''}\n以上是PD载入应用时，调用filter的factory方法输出的结果，可以看到，此读出了相关的变量信息。\n\n\nthis is call ShowVersion\nlocalhost - - [21/Nov/2012 13:23:40] \"GET / HTTP/1.1\" 200 2938\nthis is call ShowVersion\nlocalhost - - [21/Nov/2012 13:23:40] \"GET /favicon.ico HTTP/1.1\" 200 2889\n以上是接收/请求，因为没有使用filter，直接交予showversion应用处理，并返回。\n\nthis is Auth call filter1\nThis is call LogFilter filter2\nthis is call ShowStuDetail\nlocalhost - - [21/Nov/2012 13:24:23] \"GET /detail HTTP/1.1\" 200 3016\nthis is call ShowVersion\nlocalhost - - [21/Nov/2012 13:24:24] \"GET /favicon.ico HTTP/1.1\" 200 2889\nfilter的调用时重点啊，可以看到，调用的顺序和pipeline中一样。最后才调用应用。\n</code></pre>\n\n<p>需要继续折腾的话，就看看<a href=\"http://docs.webob.org/en/latest/do-it-yourself.html\">webob:do-it-yourselfrself</a></p>\n','Python.Paste指南之Deploy(2)-实践','','inherit','open','open','','275-revision','','','2013-04-01 13:53:14','2013-04-01 05:53:14','','275','http://blog.wachang.net/2013/04/275-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('278','1','2013-04-01 13:53:23','2013-04-01 05:53:23','<p>上一节中梳理了Python Paste中Deploy机制的概念，这一节就做一点小小的实践。首先，我们举一个使用了Deploy的例子，这个就是OpenStack的Quantum组件的WSGI部分。我们先来看关于WSGI部分的配置文件，以ini后缀，那么就是api-paste.ini文件，决定了API的处理流程。我加入了适当的注释。</p>\n\n<!--more-->\n\n<h2>1 OpenStack Quantum配置文件api-paste.ini</h2>\n\n<pre><code>[composite:quantum]\nuse = egg:Paste#urlmap\n/: quantumversions\n/v2.0: quantumapi_v2_0\n#使用composite分解机制，composite使用了usrlmap，xxxxx/xxx的API交给quantumversions处理。xxxx/v2.0/xxxx的API交给quantumapi_v2_0处理。\n\n[composite:quantumapi_v2_0]\nuse = call:quantum.auth:pipeline_factory\nnoauth = extensions quantumapiapp_v2_0\nkeystone = authtoken keystonecontext extensions quantumapiapp_v2_0\n#quantumapi_v2_0依然是一个分解组件，使用了quantum.auth模块下的pipeline_factory，对于这个factory，传递了两个参数，一个是noauth,一个是keystone。\n\n[filter:keystonecontext]\npaste.filter_factory = quantum.auth:QuantumKeystoneContext.factory\n#对于keystonecontext，实际上是一个过滤器，使用了quantum.auth模块下的类的QuantumKeystoneContext的factory函数\n\n[filter:authtoken]\npaste.filter_factory = keystone.middleware.auth_token:filter_factory\nauth_host = 127.0.0.1\nauth_port = 35357\nauth_protocol = http\nadmin_tenant_name = %SERVICE_TENANT_NAME%\nadmin_user = %SERVICE_USER%\nadmin_password = %SERVICE_PASSWORD%\n#定义了另外一个filter\n\n[filter:extensions]\npaste.filter_factory = quantum.extensions.extensions:plugin_aware_extension_middleware_factory\n#定义了另外一个filter,这个filter是为了支持扩展quantum api的\n\n[app:quantumversions]\npaste.app_factory = quantum.api.versions:Versions.factory\n#核心的app部分，使用工厂函数，将app指向python代码。app_factory表明这个函数接收一系列参数，[DEFAULET]以及[app:]下面的，本部分本section没有参数，并返回一个函数对象。\n\n[app:quantumapiapp_v2_0]\npaste.app_factory = quantum.api.v2.router:APIRouter.factory\n#同上\n</code></pre>\n\n<p>我们来总结一下，整个Quantum处理api的流程如下,其中，强调的部分为函数代码，其他为配置文件中的section部分。</p>\n\n<p>对于路径为<code>/</code>类的API----quantumversions处理----调用<code>quantum.api.versions:Version</code>类的<code>factory函数</code>处理。</p>\n\n<p>对于路径为<code>/2.0</code>类的API----quantumapi_v2_0处理----调用<code>quantum.auth</code>中的<code>pipeline_factory</code>处理,同时传递了两个参数noauth和keystone,类型为字典。</p>\n\n<p>这个pipeline_factory中会读取另外一个变量CONF.auth（来自另外一个配置文件，不考虑），选择采用的认证方式，然后选择noauth或者keystone，并读取参数的值.</p>\n\n<p>那么，就有两种情况：</p>\n\n<p>noauth: 应用将会先经过extensions这个filter处理----调用了<code>quantum.extensions.extensions:plugin_aware_extension_middleware_factory</code>，用来处理扩展api请求，这是第一次包装----quantumapiapp_v2_0，这才是实际的WSGI应用，调用了<code>quantum.api.v2.router:APIRouter.factory</code>，并处理返回结果。</p>\n\n<p>keystone：和上面类似，不同的是多了几个filter,authtoken keystonecontext extensions quantumapiapp_v2_0,并且在每个filter中可能还会有参数传递给这个fliter。</p>\n\n<p>总的来说，通过pipeline装载多个filter,将最基本的app--APIRouter，层层包装，使其变为一个具有处理认证，扩展API等的应用（逻辑上看），filter的好处就是可以自定义，比如可以不要认证功能，这比写一个囊括全部功能的应用明显要好的多。</p>\n\n<h2>2 代码实践</h2>\n\n<h3>2.1 配置文件</h3>\n\n<pre><code>[DEFAULT]\ncompany = UESTC\nschool = Commuication and Information\n\n[composite:common]\nuse = egg:Paste#urlmap\n/:showversion\n/detail:showdetail\n\n[pipeline:showdetail]\npipeline = filter1 filter2 showstudetail\n\n[filter:filter1]\n#filter1 deal with auth,read args below\npaste.filter_factory = python_paste:AuthFilter.factory\nuser = admin\npasswd = admin\n\n[filter:filter2]\n#filter2 deal with time,read args below\npaste.filter_factory = python_paste:LogFilter.factory\n#all value is string\ndate = 20121120\n\n[app:showstudetail]\nname = wangchang\nage = 23\npaste.app_factory = python_paste:ShowStuDetail.factory\n\n[app:showversion]\nversion = 1.0.0\n</code></pre>\n\n<p>从配置文件可以看出，这个程序会有如下操作：\n*对于http://localhost/的访问，会调用showversion这个应用，应用读取ini文件中的version值并返回。__注意，在ini中的所有值都是字符串。</p>\n\n<p>对于http://localhost/detail的访问，会先经过filter1以及filter2，这两个filter分别处理认证和LOG信息，他们会读取ini配置中的用户信息以及时间。最后才是交给showstudetail处理，showstudetail会读取ini中的用户信息并返回。__注意，使用多个filter的时候需要使用pipeline方式。</p>\n\n<h3>2.2 代码</h3>\n\n<pre><code>import sys\nimport os\nimport webob\nfrom webob import Request\nfrom webob import Response\n#from webob import environ\nfrom paste.deploy import loadapp\nfrom wsgiref.simple_server import make_server\nfrom pprint import pprint\n\nclass AuthFilter(object):\n      ''''''filter1,auth\n         1.factory read args and print,return self instance\n         2.call method return app\n         3.AuthFilter(app)\n      ''''''\n      def __init__(self,app):\n          self.app = app\n\n      def __call__(self,environ,start_response):\n          print ''this is Auth call filter1''\n          #pass environ and start_response to app\n          return self.app(environ,start_response)\n      @classmethod\n      def factory(cls,global_conf,**kwargs):\n          ''''''global_conf and kwargs are dict''''''\n          print ''######filter1##########''\n          print ''global_conf type:'',type(global_conf)\n          print ''[DEFAULT]'',global_conf\n          print ''kwargs type:'',type(kwargs)\n          print ''Auth Info'',kwargs\n          return AuthFilter\n\nclass LogFilter(object):\n      ''''''\n      filter2,Log\n      ''''''\n      def __init__(self,app):\n          self.app = app\n      def __call__(self,environ,start_response):\n          print ''This is call LogFilter filter2''\n          return self.app(environ,start_response)\n      @classmethod\n      def factory(cls,global_conf,**kwargs):\n          #print type(global_conf)\n          #print type(kwargs)\n          print ''######filter2###########''\n          print ''[DEFAULT]'',global_conf\n          print ''Log Info'',kwargs\n          return LogFilter\n\nclass ShowStuDetail(object):\n      ''''''\n      app\n      ''''''\n      def __init__(self,name,age):\n          self.name = name\n          self.age = age\n      def __call__(self,environ,start_response):\n          print ''this is call ShowStuDetail''\n          #pprint(environ)\n          #pprint environ\n          start_response(\"200 OK\",[(\"Content-type\",\"text/plain\")])\n          content = []\n          content.append(\"name: %s age:%s\\\\n\" % (self.name,self.age))\n          content.append(\"**********WSGI INFO***********\\\\n\")\n          for k,v in environ.iteritems():\n              content.append(''%s:%s \\\\n'' % (k,v))\n          return [''\\\\n''.join(content)] #return a list\n\n      @classmethod\n      def factory(cls,global_conf,**kwargs):\n          #self.name = kwargs[''name'']\n          #self.age = kwargs[''age'']\n          return ShowStuDetail(kwargs[''name''],kwargs[''age''])\n\nclass ShowVersion(object):\n      ''''''\n      app\n      ''''''\n      def __init__(self,version):\n          self.version = version\n      def __call__(self,environ,start_response):\n          print ''this is call ShowVersion''\n          req = Request(environ)\n          res = Response()\n          res.status = ''200 OK''\n          res.content_type = \"text/plain\"\n          content = []\n          #pprint(req.environ)\n          content.append(\"%s\\\\n\" % self.version)\n          content.append(\"*********WSGI INFO*********\")\n          for k,v in environ.iteritems():\n              content.append(''%s:%s\\\\n'' % (k,v))\n          res.body = ''\\\\n''.join(content)\n          return res(environ,start_response)\n      @classmethod\n      def factory(cls,global_conf,**kwargs):\n          #self.version = kwargs[''version'']\n          return ShowVersion(kwargs[''version''])\n\nif __name__ == ''__main__'':\n     config = \"python_paste.ini\"\n     appname = \"common\"\n     wsgi_app = loadapp(\"config:%s\" % os.path.abspath(config), appname)\n     server = make_server(''localhost'',7070,wsgi_app)\n     server.serve_forever()\n     pass\n</code></pre>\n\n<p>在程序中，对于web请求的处理，我分别采用了webob和普通WSGI定义的方式，后续我会补上webob的使用。</p>\n\n<h3>2.3 结果</h3>\n\n<p>先从服务端结果分析一下调用流程：</p>\n\n<pre><code>Ubuntu:~/python\$ python python_paste.py\n######filter1##########\nglobal_conf type: \n[DEFAULT] {''school'': ''Commuication and Information'', ''company'': ''UESTC'', ''here'':         ''/home/wachang/python'', ''__file__'': ''/home/wachang/python/python_paste.ini''}\nkwargs type: \nAuth Info {''passwd'': ''admin'', ''user'': ''admin''}\n######filter2###########\n[DEFAULT] {''school'': ''Commuication and Information'', ''company'': ''UESTC'', ''here'':     ''/home/wachang/python'', ''__file__'': ''/home/wachang/python/python_paste.ini''}\nLog Info {''date'': ''20121120''}\n以上是PD载入应用时，调用filter的factory方法输出的结果，可以看到，此读出了相关的变量信息。\n\n\nthis is call ShowVersion\nlocalhost - - [21/Nov/2012 13:23:40] \"GET / HTTP/1.1\" 200 2938\nthis is call ShowVersion\nlocalhost - - [21/Nov/2012 13:23:40] \"GET /favicon.ico HTTP/1.1\" 200 2889\n以上是接收/请求，因为没有使用filter，直接交予showversion应用处理，并返回。\n\nthis is Auth call filter1\nThis is call LogFilter filter2\nthis is call ShowStuDetail\nlocalhost - - [21/Nov/2012 13:24:23] \"GET /detail HTTP/1.1\" 200 3016\nthis is call ShowVersion\nlocalhost - - [21/Nov/2012 13:24:24] \"GET /favicon.ico HTTP/1.1\" 200 2889\nfilter的调用时重点啊，可以看到，调用的顺序和pipeline中一样。最后才调用应用。\n</code></pre>\n\n<p>需要继续折腾的话，就看看<a href=\"http://docs.webob.org/en/latest/do-it-yourself.html\">webob:do-it-yourselfrself</a></p>\n','Python.Paste指南之Deploy(2)-实践','','inherit','open','open','','275-revision-2','','','2013-04-01 13:53:23','2013-04-01 05:53:23','','275','http://blog.wachang.net/2013/04/275-revision-2/','0','revision','','0');");

require("../../inc/footer.php");
?>