<?php
require("../../inc/header.php");

/*
		SoftName : EmpireBak Version 2010
		Author   : wm_chief
		Copyright: Powered by www.phome.net
*/

DoSetDbChar('utf8');
E_D("replace into `wp_posts` values('91','1','2013-03-04 18:33:51','2013-03-04 10:33:51','<p>原来这个不是OpenVPN官方自带的内容，还要自己折腾一下啊，找了些资料，这里提供两种方案，总结如下：</p>\n\n<h2>openvpn-auth-ldap</h2>\n\n<p><a href=\"https://code.google.com/p/openvpn-auth-ldap/\">OpenVPN-AUTH-LDAP</a>这是最常见的方案，不过现在一般Ubuntu现在都已经有编译好的包了，所以不用进行复杂的源码编译了。</p>\n\n<pre><code>apt-get install openvpn-auth-ldap\n</code></pre>\n\n<p>然后，先是配置LDAP认证相关内容：</p>\n\n<pre><code>mkdir /etc/openvpn/auth\ncp /usr/share/doc/openvpn-auth-ldap/examples/auth-ldap.conf /etc/openvpn/auth\n</code></pre>\n\n<p>编辑文件<code>/etc/openvpn/auth/auth-ldap.conf</code>:</p>\n\n<pre><code>&lt;LDAP&gt;\n# LDAP server URL\nURL     ldap://X.X.X.X\n\n# Bind DN (If your LDAP server doesn''t support anonymous binds)\n# BindDN        uid=Manager,ou=People,dc=example,dc=com\n\n# Bind Password\n# Password  SecretPassword\n\n# Network timeout (in seconds)\nTimeout     15\n\n# Enable Start TLS\nTLSEnable   no ##这里要注意\n\n# Follow LDAP Referrals (anonymously)\nFollowReferrals yes\n\n# TLS CA Certificate File\nTLSCACertFile   /usr/local/etc/ssl/ca.pem\n\n# TLS CA Certificate Directory\nTLSCACertDir    /etc/ssl/certs\n\n# Client Certificate and key\n# If TLS client authentication is required\nTLSCertFile /usr/local/etc/ssl/client-cert.pem\nTLSKeyFile  /usr/local/etc/ssl/client-key.pem\n\n# Cipher Suite\n# The defaults are usually fine here\n# TLSCipherSuite    ALL:!ADH:@STRENGTH\n&lt;/LDAP&gt;\n\n&lt;Authorization&gt;\n# Base DN\nBaseDN      \"ou=People,dc=oinlab\"\n\n# User Search Filter\nSearchFilter    \"(uid=%u)\" ##这里要注意\n\n# Require Group Membership\nRequireGroup    false ##是否开启组验证\n\n# Add non-group members to a PF table (disabled)\n#PFTable    ips_vpn_users\n\n&lt;Group&gt;\n    BaseDN      \"ou=People,dc=oinlab\"\n    SearchFilter    \"(|(cn=developers)(cn=artists))\"\n    MemberAttribute uniqueMember\n    # Add group members to a PF table (disabled)\n    #PFTable    ips_vpn_eng\n&lt;/Group&gt;\n&lt;/Authorization&gt;\n</code></pre>\n\n<p>完了以后在配置OpenVPN中<code>server.conf</code>文件，加入如下：</p>\n\n<pre><code>plugin /usr/lib/openvpn/openvpn-auth-ldap.so /etc/openvpn/auth/auth-ldap.conf\nclient-cert-not-required ##有了LDAP就不需要证书认证了嘛\n</code></pre>\n\n<p>最后就是配置一下客户端了：</p>\n\n<p>客户端的配置简单，去掉<code>cert xxx.crt</code>以及<code>key xxx.key</code>部分，再加上<code>auth-user-pass</code>就OK。如下就是一个简单的例子：</p>\n\n<pre><code>client\ndev tun\nproto udp\nremote X.X.X.X 1194\nresolv-retry infinite\nnobind\nuser nobody\ngroup nobody\npersist-key\npersist-tun\nca ca.crt\n;cert wangchang.crt\n;key wangchang.key\ncomp-lzo\nverb 3\nauth-user-pass\n</code></pre>\n\n<p>参考资料：</p>\n\n<p><a href=\"http://cheaster.blogspot.com/2009/11/openvpn-auth-over-ldap.html\">http://cheaster.blogspot.com/2009/11/openvpn-auth-over-ldap.html</a></p>\n\n<p><a href=\"http://www.howtoforge.com/setting-up-an-openvpn-server-with-authentication-against-openldap-on-ubuntu-10.04-lts\">http://www.howtoforge.com/setting-up-an-openvpn-server-with-authentication-against-openldap-on-ubuntu-10.04-lts</a></p>\n\n<h2>脚本方式</h2>\n\n<p>有人就是把插件的功能用一个脚本来实现，相对来说，配置没那么复杂，我没测试过，应该可行。下附链接：</p>\n\n<p><a href=\"http://down.51cto.com/data/573688\">CSDN上的一个下载</a></p>\n\n<p><a href=\"http://redmine.debuntu.org/projects/openvpn-ldap-auth/wiki\">http://redmine.debuntu.org/projects/openvpn-ldap-auth/wiki</a></p>\n\n<p><a href=\"http://backreference.org/2012/09/14/openvpn-ldap-authentication/\">http://backreference.org/2012/09/14/openvpn-ldap-authentication/</a></p>\n','OpenVPN配置LDAP认证','','inherit','open','open','','90-revision','','','2013-03-04 18:33:51','2013-03-04 10:33:51','','90','http://blog.wachang.net/2013/03/90-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('92','1','2013-03-04 18:34:07','2013-03-04 10:34:07','<p>原来这个不是OpenVPN官方自带的内容，还要自己折腾一下啊，找了些资料，这里提供两种方案，总结如下：</p>\n\n<h2>openvpn-auth-ldap</h2>\n\n<p><a href=\"https://code.google.com/p/openvpn-auth-ldap/\">OpenVPN-AUTH-LDAP</a>这是最常见的方案，不过现在一般Ubuntu现在都已经有编译好的包了，所以不用进行复杂的源码编译了。</p>\n\n<pre><code>apt-get install openvpn-auth-ldap\n</code></pre>\n\n<p>然后，先是配置LDAP认证相关内容：</p>\n\n<pre><code>mkdir /etc/openvpn/auth\ncp /usr/share/doc/openvpn-auth-ldap/examples/auth-ldap.conf /etc/openvpn/auth\n</code></pre>\n\n<p>编辑文件<code>/etc/openvpn/auth/auth-ldap.conf</code>:</p>\n\n<pre><code>&lt;LDAP&gt;\n# LDAP server URL\nURL     ldap://X.X.X.X\n\n# Bind DN (If your LDAP server doesn''t support anonymous binds)\n# BindDN        uid=Manager,ou=People,dc=example,dc=com\n\n# Bind Password\n# Password  SecretPassword\n\n# Network timeout (in seconds)\nTimeout     15\n\n# Enable Start TLS\nTLSEnable   no ##这里要注意\n\n# Follow LDAP Referrals (anonymously)\nFollowReferrals yes\n\n# TLS CA Certificate File\nTLSCACertFile   /usr/local/etc/ssl/ca.pem\n\n# TLS CA Certificate Directory\nTLSCACertDir    /etc/ssl/certs\n\n# Client Certificate and key\n# If TLS client authentication is required\nTLSCertFile /usr/local/etc/ssl/client-cert.pem\nTLSKeyFile  /usr/local/etc/ssl/client-key.pem\n\n# Cipher Suite\n# The defaults are usually fine here\n# TLSCipherSuite    ALL:!ADH:@STRENGTH\n&lt;/LDAP&gt;\n\n&lt;Authorization&gt;\n# Base DN\nBaseDN      \"ou=People,dc=oinlab\"\n\n# User Search Filter\nSearchFilter    \"(uid=%u)\" ##这里要注意\n\n# Require Group Membership\nRequireGroup    false ##是否开启组验证\n\n# Add non-group members to a PF table (disabled)\n#PFTable    ips_vpn_users\n\n&lt;Group&gt;\n    BaseDN      \"ou=People,dc=oinlab\"\n    SearchFilter    \"(|(cn=developers)(cn=artists))\"\n    MemberAttribute uniqueMember\n    # Add group members to a PF table (disabled)\n    #PFTable    ips_vpn_eng\n&lt;/Group&gt;\n&lt;/Authorization&gt;\n</code></pre>\n\n<p>完了以后在配置OpenVPN中<code>server.conf</code>文件，加入如下：</p>\n\n<pre><code>plugin /usr/lib/openvpn/openvpn-auth-ldap.so /etc/openvpn/auth/auth-ldap.conf\nclient-cert-not-required ##有了LDAP就不需要证书认证了嘛\n</code></pre>\n\n<p>最后就是配置一下客户端了：</p>\n\n<p>客户端的配置简单，去掉<code>cert xxx.crt</code>以及<code>key xxx.key</code>部分，再加上<code>auth-user-pass</code>就OK。如下就是一个简单的例子：</p>\n\n<pre><code>client\ndev tun\nproto udp\nremote X.X.X.X 1194\nresolv-retry infinite\nnobind\nuser nobody\ngroup nobody\npersist-key\npersist-tun\nca ca.crt\n;cert wangchang.crt\n;key wangchang.key\ncomp-lzo\nverb 3\nauth-user-pass\n</code></pre>\n\n<p>参考资料：</p>\n\n<p><a href=\"http://cheaster.blogspot.com/2009/11/openvpn-auth-over-ldap.html\">http://cheaster.blogspot.com/2009/11/openvpn-auth-over-ldap.html</a></p>\n\n<p><a href=\"http://www.howtoforge.com/setting-up-an-openvpn-server-with-authentication-against-openldap-on-ubuntu-10.04-lts\">http://www.howtoforge.com/setting-up-an-openvpn-server-with-authentication-against-openldap-on-ubuntu-10.04-lts</a></p>\n\n<h2>脚本方式</h2>\n\n<p>有人就是把插件的功能用一个脚本来实现，相对来说，配置没那么复杂，我没测试过，应该可行。下附链接：</p>\n\n<p><a href=\"http://down.51cto.com/data/573688\">CSDN上的一个下载</a></p>\n\n<p><a href=\"http://redmine.debuntu.org/projects/openvpn-ldap-auth/wiki\">http://redmine.debuntu.org/projects/openvpn-ldap-auth/wiki</a></p>\n\n<p><a href=\"http://backreference.org/2012/09/14/openvpn-ldap-authentication/\">http://backreference.org/2012/09/14/openvpn-ldap-authentication/</a></p>\n','OpenVPN配置LDAP认证','','inherit','open','open','','90-revision-2','','','2013-03-04 18:34:07','2013-03-04 10:34:07','','90','http://blog.wachang.net/2013/03/90-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('93','1','2013-03-05 14:59:29','2013-03-05 06:59:29','<h2>1 背景</h2>\n\n<p>一种技术（协议）或者策略的两个或多个子网穿过另一种技术（协议）或者策略的网络实现互联，称之为overlay topology，这一技术是电信技术的永恒主题之一。</p>\n\n<p>电信技术在发展，多种网络技术并存，一种技术的网络孤岛可能需要穿过另一种技术的网络实现互联，这种情况如果发生在高层协议的PDU封装于低层协议PDU中时通常称之为复用，特别地三层PDU穿过二层网络地技术称为租用链路或虚电路；而如果穿越发生在一种协议PDU封装在同一层协议的PDU中，或者封装在高层协议的PDU中时，人们通常称之为隧道。</p>\n\n<p>隧道提供了一种某一特定网络技术的PDU穿过不具备该技术转发能力的网络的手段，如组播数据包穿过不支持组播的网络；另一种情况是有时因为管理策略的原因，一个管理者（策略）的子网不能通过和另一个管理者（策略）的网络互联而连接，而是要穿过另一个管理者（策略）的网络实现连接，这就是所谓的VPN（Virtual Private Networks），不管是L2 VPN还是L3 VPN都需要利用隧道技术实现。因此隧道某种意义上可以概括为穿越不同的网络的技术，不同既可以是技术方面的，也可以是管理策略方面的。 隧道可以作为一个虚拟接口来实现。隧道接口并不指定特定的“乘客”或“传输”协议连接，而是一种结构，可以实现任何标准点到点封装的服务。由于隧道是点到点连接，因此对每个连接必须配置一个单独的隧道。</p>\n\n<p>GRE是一种应用较为广泛的一种网络层协议PDU封装于任一种网络层协议PDU中的技术，经常被用来构造GRE隧道穿越各种三层网络，并得到了大多数电信设备厂商的支持。</p>\n\n<!--more-->\n\n<h2>2 GRE</h2>\n\n<h3>2.1 简介</h3>\n\n<p>GRE(通用路由协议封装）是由Cisco和Net-smiths等公司于1994年提交给IETF的，标号为RFC1701和RFC1702。目前有多数厂商的网络设备均支持GRE隧道协议。GRE 规定了如何用一种网络协议去封装另一种网络协议的方法。GRE的隧道由两端的源IP地址和目的IP地址来定义，允许用户使用IP包封装IP、IPX、 AppleTalk包，并支持全部的路由协议（如RIP2、OSPF等）。通过GRE，用户可以利用公共IP网络连接IPX网络、AppleTalk网 络，还可以使用保留地址进行网络互连，或者对公网隐藏企业网的IP地址。总结来说：</p>\n\n<ul>\n<li>GRE是三层协议，用一种协议来封装另一种协议，使用了隧道tunnel技术</li>\n<li>隧道是虚拟的点对点连接，所以GRE的使用过程中肯定会出现一个虚拟的隧道接口</li>\n</ul>\n\n<h3>2.2 例子</h3>\n\n<p>GRE进行IP封装：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-encap-1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-encap-1-300x176.png\" alt=\"gre-encap-1\" width=\"300\" height=\"176\" class=\"aligncenter size-medium wp-image-94\" /></a></p>\n\n<p>GRE解封装</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-decap-1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-decap-1-300x160.png\" alt=\"gre-decap-1\" width=\"300\" height=\"160\" class=\"aligncenter size-medium wp-image-95\" /></a></p>\n\n<p>上面注意封装后新的<code>协议号是47</code>，这样对端就能发觉这是一个GRE报文，接着递交给GRE相关模块进行解封。GRE报文格式如下：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/GRE-format.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/GRE-format-300x170.png\" alt=\"GRE-format\" width=\"300\" height=\"170\" class=\"aligncenter size-medium wp-image-96\" /></a></p>\n\n<p>GRE在包头中包含了协议类型-47，这用于标明乘客协议的类型；校验和包括了GRE的包头和完整的乘客协议与数据；密钥用于接收端验证接收的数据；序列号用于接收端数据包的排序和差错控制；路由用于本数据包的路由。</p>\n\n<h3>2.3 应用</h3>\n\n<p>下面这个例子就很好的说明了GRE的使用。</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example-300x79.png\" alt=\"gre-example\" width=\"300\" height=\"79\" class=\"aligncenter size-medium wp-image-97\" /></a></p>\n\n<p>如果，在路由器AB之间（中间隔着其他网络）我想使用GRE，第一步需要配置GER的隧道接口，指明源目地址,这一步<code>需要在隧道的两段都进行配置</code>：</p>\n\n<pre><code>##路由器A\ninterface T0\nip address 100.1.1.1 255.255.255.0\ntunnel source 1.1.1.1\ntunnel dst 1.1.1.2\n##路由器B\ninterface T0\nip address 100.1.1.2 255.255.255.0\ntunnel source 1.1.1.2\ntunnel dst 1.1.1.1 （注意是反向的，一个隧道是双向的）\n</code></pre>\n\n<p>下面我们来解释以上配置的作用:</p>\n\n<ul>\n<li>当A上的LO接口的数据（10.1.1.1）希望走GRE隧道到达B上L0接口(20.1.1.1)</li>\n<li>此时在路由A上指定这种数据包走网关是A上T0的地址100.1.1.1（走这里才会进行GRE封装，也就是为什么GRE需要设置两段隧道接口的地址！）</li>\n<li>随后，这个数据包进行GRE封装，封装完成以后，变成一个新包，源地址是1.1.1.1目的地址是1.1.1.2(这就是GRE中设置隧道源目地址的作用，因为数据包肯定是从实际接口发出的，所以这里需要指明隧道两端的实际接口)</li>\n<li>数据包到达路由器B的1.1.1.2口，显示<code>src=1.1.1.1</code>,<code>dst=1.1.1.2</code>，<code>协议号47</code>于是B知道了，这个是GRE报文，然后交给GRE模块处理，GRE模块解封GRE头，得到原来的信息，源地址10.1.1.1目的地址20.1.1.1，交给协议栈处理，作用到达应用处。</li>\n</ul>\n\n<p>最后是路由器A上数据包走向的一个截图，可以参考一下:</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example-2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example-2-300x178.png\" alt=\"gre-example-2\" width=\"300\" height=\"178\" class=\"aligncenter size-medium wp-image-98\" /></a></p>\n\n<h2>3 参考资料</h2>\n\n<p><a href=\"http://blog.sina.com.cn/s/blog_4fad46a801015wto.html\">http://blog.sina.com.cn/s/blog_4fad46a801015wto.html</a></p>\n\n<p><a href=\"http://wenku.baidu.com/view/b88e564ff7ec4afe04a1df4b.html\">http://wenku.baidu.com/view/b88e564ff7ec4afe04a1df4b.html</a></p>\n\n<p><a href=\"http://wenku.baidu.com/view/699d9749cf84b9d528ea7a82.html\">http://wenku.baidu.com/view/699d9749cf84b9d528ea7a82.html</a></p>\n','GRE通用路由封装协议学习笔记','','publish','open','open','','gre-study-note','','','2013-03-08 16:43:12','2013-03-08 08:43:12','','0','http://blog.wachang.net/?p=93','0','post','','0');");
E_D("replace into `wp_posts` values('94','1','2013-03-05 14:30:42','2013-03-05 06:30:42','','gre-encap-1','','inherit','open','open','','gre-encap-1','','','2013-03-05 14:30:42','2013-03-05 06:30:42','','93','http://blog.wachang.net/wp-content/uploads/2013/03/gre-encap-1.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('95','1','2013-03-05 14:31:21','2013-03-05 06:31:21','','gre-decap-1','','inherit','open','open','','gre-decap-1','','','2013-03-05 14:31:21','2013-03-05 06:31:21','','93','http://blog.wachang.net/wp-content/uploads/2013/03/gre-decap-1.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('96','1','2013-03-05 14:34:11','2013-03-05 06:34:11','','GRE-format','','inherit','open','open','','gre-format','','','2013-03-05 14:34:11','2013-03-05 06:34:11','','93','http://blog.wachang.net/wp-content/uploads/2013/03/GRE-format.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('97','1','2013-03-05 14:42:15','2013-03-05 06:42:15','','gre-example','','inherit','open','open','','gre-example','','','2013-03-05 14:42:15','2013-03-05 06:42:15','','93','http://blog.wachang.net/wp-content/uploads/2013/03/gre-example.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('98','1','2013-03-05 14:55:27','2013-03-05 06:55:27','','gre-example-2','','inherit','open','open','','gre-example-2','','','2013-03-05 14:55:27','2013-03-05 06:55:27','','93','http://blog.wachang.net/wp-content/uploads/2013/03/gre-example-2.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('99','1','2013-03-05 14:55:46','2013-03-05 06:55:46','<h2>背景</h2>\n\n<p>一种技术（协议）或者策略的两个或多个子网穿过另一种技术（协议）或者策略的网络实现互联，称之为overlay topology，这一技术是电信技术的永恒主题之一。</p>\n\n<p>电信技术在发展，多种网络技术并存，一种技术的网络孤岛可能需要穿过另一种技术的网络实现互联，这种情况如果发生在高层协议的PDU封装于低层协议PDU中时通常称之为复用，特别地三层PDU穿过二层网络地技术称为租用链路或虚电路；而如果穿越发生在一种协议PDU封装在同一层协议的PDU中，或者封装在高层协议的PDU中时，人们通常称之为隧道。</p>\n\n<p>隧道提供了一种某一特定网络技术的PDU穿过不具备该技术转发能力的网络的手段，如组播数据包穿过不支持组播的网络；另一种情况是有时因为管理策略的原因，一个管理者（策略）的子网不能通过和另一个管理者（策略）的网络互联而连接，而是要穿过另一个管理者（策略）的网络实现连接，这就是所谓的VPN（Virtual Private Networks），不管是L2 VPN还是L3 VPN都需要利用隧道技术实现。因此隧道某种意义上可以概括为穿越不同的网络的技术，不同既可以是技术方面的，也可以是管理策略方面的。\n隧道可以作为一个虚拟接口来实现。隧道接口并不指定特定的“乘客”或“传输”协议连接，而是一种结构，可以实现任何标准点到点封装的服务。由于隧道是点到点连接，因此对每个连接必须配置一个单独的隧道。</p>\n\n<p>GRE是一种应用较为广泛的一种网络层协议PDU封装于任一种网络层协议PDU中的技术，经常被用来构造GRE隧道穿越各种三层网络，并得到了大多数电信设备厂商的支持。</p>\n\n<h2>GRE</h2>\n\n<h3>简介</h3>\n\n<p>GRE(通用路由协议封装）是由Cisco和Net-smiths等公司于1994年提交给IETF的，标号为RFC1701和RFC1702。目前有多数厂商的网络设备均支持GRE隧道协议。GRE 规定了如何用一种网络协议去封装另一种网络协议的方法。GRE的隧道由两端的源IP地址和目的IP地址来定义，允许用户使用IP包封装IP、IPX、 AppleTalk包，并支持全部的路由协议（如RIP2、OSPF等）。通过GRE，用户可以利用公共IP网络连接IPX网络、AppleTalk网 络，还可以使用保留地址进行网络互连，或者对公网隐藏企业网的IP地址。总结来说：</p>\n\n<ul>\n<li>GRE是三层协议，用一种协议来封装另一种协议，使用了隧道tunnel技术</li>\n<li>隧道是虚拟的点对点连接，所以GRE的使用过程中肯定会出现一个虚拟的隧道接口</li>\n</ul>\n\n<h3>例子</h3>\n\n<p>GRE进行IP封装：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-encap-1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-encap-1-300x176.png\" alt=\"gre-encap-1\" width=\"300\" height=\"176\" class=\"alignnone size-medium wp-image-94\" /></a></p>\n\n<p>GRE解封装</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-decap-1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-decap-1-300x160.png\" alt=\"gre-decap-1\" width=\"300\" height=\"160\" class=\"alignnone size-medium wp-image-95\" /></a></p>\n\n<p>上面注意封装后新的<code>协议号是47</code>，这样对端就能发觉这是一个GRE报文，接着递交给GRE相关模块进行解封。GRE报文格式如下：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/GRE-format.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/GRE-format-300x170.png\" alt=\"GRE-format\" width=\"300\" height=\"170\" class=\"alignnone size-medium wp-image-96\" /></a></p>\n\n<p>GRE在包头中包含了协议类型-47，这用于标明乘客协议的类型；校验和包括了GRE的包头和完整的乘客协议与数据；密钥用于接收端验证接收的数据；序列号用于接收端数据包的排序和差错控制；路由用于本数据包的路由。</p>\n\n<h3>应用</h3>\n\n<p>下面这个例子就很好的说明了GRE的使用。</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example-300x79.png\" alt=\"gre-example\" width=\"300\" height=\"79\" class=\"aligncenter size-medium wp-image-97\" /></a></p>\n\n<p>如果，在路由器AB之间（中间隔着其他网络）我想使用GRE，第一步需要配置GER的隧道接口，指明源目地址,这一步<code>需要在隧道的两段都进行配置</code>：</p>\n\n<pre><code>##路由器A\ninterface T0\nip address 100.1.1.1 255.255.255.0\ntunnel source 1.1.1.1\ntunnel dst 1.1.1.2\n##路由器B\ninterface T0\nip address 100.1.1.2 255.255.255.0\ntunnel source 1.1.1.2\ntunnel dst 1.1.1.1 （注意是反向的，一个隧道是双向的）\n</code></pre>\n\n<p>下面我们来解释以上配置的作用:</p>\n\n<ul>\n<li>当A上的LO接口的数据（10.1.1.1）希望走GRE隧道到达B上L0接口(20.1.1.1)</li>\n<li>此时在路由A上指定这种数据包走网关是A上T0的地址100.1.1.1（走这里才会进行GRE封装，也就是为什么GRE需要设置两段隧道接口的地址！）</li>\n<li>随后，这个数据包进行GRE封装，封装完成以后，变成一个新包，源地址是1.1.1.1目的地址是1.1.1.2(这就是GRE中设置隧道源目地址的作用，因为数据包肯定是从实际接口发出的，所以这里需要指明隧道两端的实际接口)</li>\n<li>数据包到达路由器B的1.1.1.2口，显示<code>src=1.1.1.1</code>,<code>dst=1.1.1.2</code>，<code>协议号47</code>于是B知道了，这个是GRE报文，然后交给GRE模块处理，GRE模块解封GRE头，得到原来的信息，源地址10.1.1.1目的地址20.1.1.1，交给协议栈处理，作用到达应用处。</li>\n</ul>\n\n<p>最后是路由器A上数据包走向的一个截图，可以参考一下:</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example-2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example-2-300x178.png\" alt=\"gre-example-2\" width=\"300\" height=\"178\" class=\"aligncenter size-medium wp-image-98\" /></a></p>\n\n<h2>参考资料</h2>\n\n<p><a href=\"http://blog.sina.com.cn/s/blog_4fad46a801015wto.html\">http://blog.sina.com.cn/s/blog_4fad46a801015wto.html</a></p>\n\n<p><a href=\"http://wenku.baidu.com/view/b88e564ff7ec4afe04a1df4b.html\">http://wenku.baidu.com/view/b88e564ff7ec4afe04a1df4b.html</a></p>\n\n<p><a href=\"http://wenku.baidu.com/view/699d9749cf84b9d528ea7a82.html\">http://wenku.baidu.com/view/699d9749cf84b9d528ea7a82.html</a></p>\n','GRE通用路由封装学习笔记','','inherit','open','open','','93-revision','','','2013-03-05 14:55:46','2013-03-05 06:55:46','','93','http://blog.wachang.net/2013/03/93-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('100','1','2013-03-05 14:57:51','2013-03-05 06:57:51','<h2>背景</h2>\n\n<p>一种技术（协议）或者策略的两个或多个子网穿过另一种技术（协议）或者策略的网络实现互联，称之为overlay topology，这一技术是电信技术的永恒主题之一。</p>\n\n<p>电信技术在发展，多种网络技术并存，一种技术的网络孤岛可能需要穿过另一种技术的网络实现互联，这种情况如果发生在高层协议的PDU封装于低层协议PDU中时通常称之为复用，特别地三层PDU穿过二层网络地技术称为租用链路或虚电路；而如果穿越发生在一种协议PDU封装在同一层协议的PDU中，或者封装在高层协议的PDU中时，人们通常称之为隧道。</p>\n\n<p>隧道提供了一种某一特定网络技术的PDU穿过不具备该技术转发能力的网络的手段，如组播数据包穿过不支持组播的网络；另一种情况是有时因为管理策略的原因，一个管理者（策略）的子网不能通过和另一个管理者（策略）的网络互联而连接，而是要穿过另一个管理者（策略）的网络实现连接，这就是所谓的VPN（Virtual Private Networks），不管是L2 VPN还是L3 VPN都需要利用隧道技术实现。因此隧道某种意义上可以概括为穿越不同的网络的技术，不同既可以是技术方面的，也可以是管理策略方面的。 隧道可以作为一个虚拟接口来实现。隧道接口并不指定特定的“乘客”或“传输”协议连接，而是一种结构，可以实现任何标准点到点封装的服务。由于隧道是点到点连接，因此对每个连接必须配置一个单独的隧道。</p>\n\n<p>GRE是一种应用较为广泛的一种网络层协议PDU封装于任一种网络层协议PDU中的技术，经常被用来构造GRE隧道穿越各种三层网络，并得到了大多数电信设备厂商的支持。</p>\n\n<h2>GRE</h2>\n\n<h3>简介</h3>\n\n<p>GRE(通用路由协议封装）是由Cisco和Net-smiths等公司于1994年提交给IETF的，标号为RFC1701和RFC1702。目前有多数厂商的网络设备均支持GRE隧道协议。GRE 规定了如何用一种网络协议去封装另一种网络协议的方法。GRE的隧道由两端的源IP地址和目的IP地址来定义，允许用户使用IP包封装IP、IPX、 AppleTalk包，并支持全部的路由协议（如RIP2、OSPF等）。通过GRE，用户可以利用公共IP网络连接IPX网络、AppleTalk网 络，还可以使用保留地址进行网络互连，或者对公网隐藏企业网的IP地址。总结来说：</p>\n\n<ul>\n<li>GRE是三层协议，用一种协议来封装另一种协议，使用了隧道tunnel技术</li>\n<li>隧道是虚拟的点对点连接，所以GRE的使用过程中肯定会出现一个虚拟的隧道接口</li>\n</ul>\n\n<h3>例子</h3>\n\n<p>GRE进行IP封装：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-encap-1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-encap-1-300x176.png\" alt=\"gre-encap-1\" width=\"300\" height=\"176\" class=\"alignnone size-medium wp-image-94\" /></a></p>\n\n<p>GRE解封装</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-decap-1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-decap-1-300x160.png\" alt=\"gre-decap-1\" width=\"300\" height=\"160\" class=\"alignnone size-medium wp-image-95\" /></a></p>\n\n<p>上面注意封装后新的<code>协议号是47</code>，这样对端就能发觉这是一个GRE报文，接着递交给GRE相关模块进行解封。GRE报文格式如下：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/GRE-format.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/GRE-format-300x170.png\" alt=\"GRE-format\" width=\"300\" height=\"170\" class=\"alignnone size-medium wp-image-96\" /></a></p>\n\n<p>GRE在包头中包含了协议类型-47，这用于标明乘客协议的类型；校验和包括了GRE的包头和完整的乘客协议与数据；密钥用于接收端验证接收的数据；序列号用于接收端数据包的排序和差错控制；路由用于本数据包的路由。</p>\n\n<h3>应用</h3>\n\n<p>下面这个例子就很好的说明了GRE的使用。</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example-300x79.png\" alt=\"gre-example\" width=\"300\" height=\"79\" class=\"aligncenter size-medium wp-image-97\" /></a></p>\n\n<p>如果，在路由器AB之间（中间隔着其他网络）我想使用GRE，第一步需要配置GER的隧道接口，指明源目地址,这一步<code>需要在隧道的两段都进行配置</code>：</p>\n\n<pre><code>##路由器A\ninterface T0\nip address 100.1.1.1 255.255.255.0\ntunnel source 1.1.1.1\ntunnel dst 1.1.1.2\n##路由器B\ninterface T0\nip address 100.1.1.2 255.255.255.0\ntunnel source 1.1.1.2\ntunnel dst 1.1.1.1 （注意是反向的，一个隧道是双向的）\n</code></pre>\n\n<p>下面我们来解释以上配置的作用:</p>\n\n<ul>\n<li>当A上的LO接口的数据（10.1.1.1）希望走GRE隧道到达B上L0接口(20.1.1.1)</li>\n<li>此时在路由A上指定这种数据包走网关是A上T0的地址100.1.1.1（走这里才会进行GRE封装，也就是为什么GRE需要设置两段隧道接口的地址！）</li>\n<li>随后，这个数据包进行GRE封装，封装完成以后，变成一个新包，源地址是1.1.1.1目的地址是1.1.1.2(这就是GRE中设置隧道源目地址的作用，因为数据包肯定是从实际接口发出的，所以这里需要指明隧道两端的实际接口)</li>\n<li>数据包到达路由器B的1.1.1.2口，显示<code>src=1.1.1.1</code>,<code>dst=1.1.1.2</code>，<code>协议号47</code>于是B知道了，这个是GRE报文，然后交给GRE模块处理，GRE模块解封GRE头，得到原来的信息，源地址10.1.1.1目的地址20.1.1.1，交给协议栈处理，作用到达应用处。</li>\n</ul>\n\n<p>最后是路由器A上数据包走向的一个截图，可以参考一下:</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example-2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example-2-300x178.png\" alt=\"gre-example-2\" width=\"300\" height=\"178\" class=\"aligncenter size-medium wp-image-98\" /></a></p>\n\n<h2>参考资料</h2>\n\n<p><a href=\"http://blog.sina.com.cn/s/blog_4fad46a801015wto.html\">http://blog.sina.com.cn/s/blog_4fad46a801015wto.html</a></p>\n\n<p><a href=\"http://wenku.baidu.com/view/b88e564ff7ec4afe04a1df4b.html\">http://wenku.baidu.com/view/b88e564ff7ec4afe04a1df4b.html</a></p>\n\n<p><a href=\"http://wenku.baidu.com/view/699d9749cf84b9d528ea7a82.html\">http://wenku.baidu.com/view/699d9749cf84b9d528ea7a82.html</a></p>\n','GRE通用路由封装协议学习笔记','','inherit','open','open','','93-revision-2','','','2013-03-05 14:57:51','2013-03-05 06:57:51','','93','http://blog.wachang.net/2013/03/93-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('101','1','2013-03-05 14:59:29','2013-03-05 06:59:29','<h2>背景</h2>\n\n<p>一种技术（协议）或者策略的两个或多个子网穿过另一种技术（协议）或者策略的网络实现互联，称之为overlay topology，这一技术是电信技术的永恒主题之一。</p>\n\n<p>电信技术在发展，多种网络技术并存，一种技术的网络孤岛可能需要穿过另一种技术的网络实现互联，这种情况如果发生在高层协议的PDU封装于低层协议PDU中时通常称之为复用，特别地三层PDU穿过二层网络地技术称为租用链路或虚电路；而如果穿越发生在一种协议PDU封装在同一层协议的PDU中，或者封装在高层协议的PDU中时，人们通常称之为隧道。</p>\n\n<p>隧道提供了一种某一特定网络技术的PDU穿过不具备该技术转发能力的网络的手段，如组播数据包穿过不支持组播的网络；另一种情况是有时因为管理策略的原因，一个管理者（策略）的子网不能通过和另一个管理者（策略）的网络互联而连接，而是要穿过另一个管理者（策略）的网络实现连接，这就是所谓的VPN（Virtual Private Networks），不管是L2 VPN还是L3 VPN都需要利用隧道技术实现。因此隧道某种意义上可以概括为穿越不同的网络的技术，不同既可以是技术方面的，也可以是管理策略方面的。 隧道可以作为一个虚拟接口来实现。隧道接口并不指定特定的“乘客”或“传输”协议连接，而是一种结构，可以实现任何标准点到点封装的服务。由于隧道是点到点连接，因此对每个连接必须配置一个单独的隧道。</p>\n\n<p>GRE是一种应用较为广泛的一种网络层协议PDU封装于任一种网络层协议PDU中的技术，经常被用来构造GRE隧道穿越各种三层网络，并得到了大多数电信设备厂商的支持。</p>\n\n<h2>GRE</h2>\n\n<h3>简介</h3>\n\n<p>GRE(通用路由协议封装）是由Cisco和Net-smiths等公司于1994年提交给IETF的，标号为RFC1701和RFC1702。目前有多数厂商的网络设备均支持GRE隧道协议。GRE 规定了如何用一种网络协议去封装另一种网络协议的方法。GRE的隧道由两端的源IP地址和目的IP地址来定义，允许用户使用IP包封装IP、IPX、 AppleTalk包，并支持全部的路由协议（如RIP2、OSPF等）。通过GRE，用户可以利用公共IP网络连接IPX网络、AppleTalk网 络，还可以使用保留地址进行网络互连，或者对公网隐藏企业网的IP地址。总结来说：</p>\n\n<ul>\n<li>GRE是三层协议，用一种协议来封装另一种协议，使用了隧道tunnel技术</li>\n<li>隧道是虚拟的点对点连接，所以GRE的使用过程中肯定会出现一个虚拟的隧道接口</li>\n</ul>\n\n<h3>例子</h3>\n\n<p>GRE进行IP封装：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-encap-1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-encap-1-300x176.png\" alt=\"gre-encap-1\" width=\"300\" height=\"176\" class=\"alignnone size-medium wp-image-94\" /></a></p>\n\n<p>GRE解封装</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-decap-1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-decap-1-300x160.png\" alt=\"gre-decap-1\" width=\"300\" height=\"160\" class=\"alignnone size-medium wp-image-95\" /></a></p>\n\n<p>上面注意封装后新的<code>协议号是47</code>，这样对端就能发觉这是一个GRE报文，接着递交给GRE相关模块进行解封。GRE报文格式如下：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/GRE-format.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/GRE-format-300x170.png\" alt=\"GRE-format\" width=\"300\" height=\"170\" class=\"alignnone size-medium wp-image-96\" /></a></p>\n\n<p>GRE在包头中包含了协议类型-47，这用于标明乘客协议的类型；校验和包括了GRE的包头和完整的乘客协议与数据；密钥用于接收端验证接收的数据；序列号用于接收端数据包的排序和差错控制；路由用于本数据包的路由。</p>\n\n<h3>应用</h3>\n\n<p>下面这个例子就很好的说明了GRE的使用。</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example-300x79.png\" alt=\"gre-example\" width=\"300\" height=\"79\" class=\"aligncenter size-medium wp-image-97\" /></a></p>\n\n<p>如果，在路由器AB之间（中间隔着其他网络）我想使用GRE，第一步需要配置GER的隧道接口，指明源目地址,这一步<code>需要在隧道的两段都进行配置</code>：</p>\n\n<pre><code>##路由器A\ninterface T0\nip address 100.1.1.1 255.255.255.0\ntunnel source 1.1.1.1\ntunnel dst 1.1.1.2\n##路由器B\ninterface T0\nip address 100.1.1.2 255.255.255.0\ntunnel source 1.1.1.2\ntunnel dst 1.1.1.1 （注意是反向的，一个隧道是双向的）\n</code></pre>\n\n<p>下面我们来解释以上配置的作用:</p>\n\n<ul>\n<li>当A上的LO接口的数据（10.1.1.1）希望走GRE隧道到达B上L0接口(20.1.1.1)</li>\n<li>此时在路由A上指定这种数据包走网关是A上T0的地址100.1.1.1（走这里才会进行GRE封装，也就是为什么GRE需要设置两段隧道接口的地址！）</li>\n<li>随后，这个数据包进行GRE封装，封装完成以后，变成一个新包，源地址是1.1.1.1目的地址是1.1.1.2(这就是GRE中设置隧道源目地址的作用，因为数据包肯定是从实际接口发出的，所以这里需要指明隧道两端的实际接口)</li>\n<li>数据包到达路由器B的1.1.1.2口，显示<code>src=1.1.1.1</code>,<code>dst=1.1.1.2</code>，<code>协议号47</code>于是B知道了，这个是GRE报文，然后交给GRE模块处理，GRE模块解封GRE头，得到原来的信息，源地址10.1.1.1目的地址20.1.1.1，交给协议栈处理，作用到达应用处。</li>\n</ul>\n\n<p>最后是路由器A上数据包走向的一个截图，可以参考一下:</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example-2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example-2-300x178.png\" alt=\"gre-example-2\" width=\"300\" height=\"178\" class=\"aligncenter size-medium wp-image-98\" /></a></p>\n\n<h2>参考资料</h2>\n\n<p><a href=\"http://blog.sina.com.cn/s/blog_4fad46a801015wto.html\">http://blog.sina.com.cn/s/blog_4fad46a801015wto.html</a></p>\n\n<p><a href=\"http://wenku.baidu.com/view/b88e564ff7ec4afe04a1df4b.html\">http://wenku.baidu.com/view/b88e564ff7ec4afe04a1df4b.html</a></p>\n\n<p><a href=\"http://wenku.baidu.com/view/699d9749cf84b9d528ea7a82.html\">http://wenku.baidu.com/view/699d9749cf84b9d528ea7a82.html</a></p>\n','GRE通用路由封装协议学习笔记','','inherit','open','open','','93-revision-3','','','2013-03-05 14:59:29','2013-03-05 06:59:29','','93','http://blog.wachang.net/2013/03/93-revision-3/','0','revision','','0');");
E_D("replace into `wp_posts` values('102','1','2013-03-05 15:01:49','2013-03-05 07:01:49','<h2>背景</h2>\n\n<p>一种技术（协议）或者策略的两个或多个子网穿过另一种技术（协议）或者策略的网络实现互联，称之为overlay topology，这一技术是电信技术的永恒主题之一。</p>\n\n<p>电信技术在发展，多种网络技术并存，一种技术的网络孤岛可能需要穿过另一种技术的网络实现互联，这种情况如果发生在高层协议的PDU封装于低层协议PDU中时通常称之为复用，特别地三层PDU穿过二层网络地技术称为租用链路或虚电路；而如果穿越发生在一种协议PDU封装在同一层协议的PDU中，或者封装在高层协议的PDU中时，人们通常称之为隧道。</p>\n\n<p>隧道提供了一种某一特定网络技术的PDU穿过不具备该技术转发能力的网络的手段，如组播数据包穿过不支持组播的网络；另一种情况是有时因为管理策略的原因，一个管理者（策略）的子网不能通过和另一个管理者（策略）的网络互联而连接，而是要穿过另一个管理者（策略）的网络实现连接，这就是所谓的VPN（Virtual Private Networks），不管是L2 VPN还是L3 VPN都需要利用隧道技术实现。因此隧道某种意义上可以概括为穿越不同的网络的技术，不同既可以是技术方面的，也可以是管理策略方面的。 隧道可以作为一个虚拟接口来实现。隧道接口并不指定特定的“乘客”或“传输”协议连接，而是一种结构，可以实现任何标准点到点封装的服务。由于隧道是点到点连接，因此对每个连接必须配置一个单独的隧道。</p>\n\n<p>GRE是一种应用较为广泛的一种网络层协议PDU封装于任一种网络层协议PDU中的技术，经常被用来构造GRE隧道穿越各种三层网络，并得到了大多数电信设备厂商的支持。</p>\n\n<h2>GRE</h2>\n\n<h3>简介</h3>\n\n<p>GRE(通用路由协议封装）是由Cisco和Net-smiths等公司于1994年提交给IETF的，标号为RFC1701和RFC1702。目前有多数厂商的网络设备均支持GRE隧道协议。GRE 规定了如何用一种网络协议去封装另一种网络协议的方法。GRE的隧道由两端的源IP地址和目的IP地址来定义，允许用户使用IP包封装IP、IPX、 AppleTalk包，并支持全部的路由协议（如RIP2、OSPF等）。通过GRE，用户可以利用公共IP网络连接IPX网络、AppleTalk网 络，还可以使用保留地址进行网络互连，或者对公网隐藏企业网的IP地址。总结来说：</p>\n\n<ul>\n<li>GRE是三层协议，用一种协议来封装另一种协议，使用了隧道tunnel技术</li>\n<li>隧道是虚拟的点对点连接，所以GRE的使用过程中肯定会出现一个虚拟的隧道接口</li>\n</ul>\n\n<h3>例子</h3>\n\n<p>GRE进行IP封装：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-encap-1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-encap-1-300x176.png\" alt=\"gre-encap-1\" width=\"300\" height=\"176\" class=\"aligncenter size-medium wp-image-94\" /></a></p>\n\n<p>GRE解封装</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-decap-1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-decap-1-300x160.png\" alt=\"gre-decap-1\" width=\"300\" height=\"160\" class=\"aligncenter size-medium wp-image-95\" /></a></p>\n\n<p>上面注意封装后新的<code>协议号是47</code>，这样对端就能发觉这是一个GRE报文，接着递交给GRE相关模块进行解封。GRE报文格式如下：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/GRE-format.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/GRE-format-300x170.png\" alt=\"GRE-format\" width=\"300\" height=\"170\" class=\"aligncenter size-medium wp-image-96\" /></a></p>\n\n<p>GRE在包头中包含了协议类型-47，这用于标明乘客协议的类型；校验和包括了GRE的包头和完整的乘客协议与数据；密钥用于接收端验证接收的数据；序列号用于接收端数据包的排序和差错控制；路由用于本数据包的路由。</p>\n\n<h3>应用</h3>\n\n<p>下面这个例子就很好的说明了GRE的使用。</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example-300x79.png\" alt=\"gre-example\" width=\"300\" height=\"79\" class=\"aligncenter size-medium wp-image-97\" /></a></p>\n\n<p>如果，在路由器AB之间（中间隔着其他网络）我想使用GRE，第一步需要配置GER的隧道接口，指明源目地址,这一步<code>需要在隧道的两段都进行配置</code>：</p>\n\n<pre><code>##路由器A\ninterface T0\nip address 100.1.1.1 255.255.255.0\ntunnel source 1.1.1.1\ntunnel dst 1.1.1.2\n##路由器B\ninterface T0\nip address 100.1.1.2 255.255.255.0\ntunnel source 1.1.1.2\ntunnel dst 1.1.1.1 （注意是反向的，一个隧道是双向的）\n</code></pre>\n\n<p>下面我们来解释以上配置的作用:</p>\n\n<ul>\n<li>当A上的LO接口的数据（10.1.1.1）希望走GRE隧道到达B上L0接口(20.1.1.1)</li>\n<li>此时在路由A上指定这种数据包走网关是A上T0的地址100.1.1.1（走这里才会进行GRE封装，也就是为什么GRE需要设置两段隧道接口的地址！）</li>\n<li>随后，这个数据包进行GRE封装，封装完成以后，变成一个新包，源地址是1.1.1.1目的地址是1.1.1.2(这就是GRE中设置隧道源目地址的作用，因为数据包肯定是从实际接口发出的，所以这里需要指明隧道两端的实际接口)</li>\n<li>数据包到达路由器B的1.1.1.2口，显示<code>src=1.1.1.1</code>,<code>dst=1.1.1.2</code>，<code>协议号47</code>于是B知道了，这个是GRE报文，然后交给GRE模块处理，GRE模块解封GRE头，得到原来的信息，源地址10.1.1.1目的地址20.1.1.1，交给协议栈处理，作用到达应用处。</li>\n</ul>\n\n<p>最后是路由器A上数据包走向的一个截图，可以参考一下:</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example-2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example-2-300x178.png\" alt=\"gre-example-2\" width=\"300\" height=\"178\" class=\"aligncenter size-medium wp-image-98\" /></a></p>\n\n<h2>参考资料</h2>\n\n<p><a href=\"http://blog.sina.com.cn/s/blog_4fad46a801015wto.html\">http://blog.sina.com.cn/s/blog_4fad46a801015wto.html</a></p>\n\n<p><a href=\"http://wenku.baidu.com/view/b88e564ff7ec4afe04a1df4b.html\">http://wenku.baidu.com/view/b88e564ff7ec4afe04a1df4b.html</a></p>\n\n<p><a href=\"http://wenku.baidu.com/view/699d9749cf84b9d528ea7a82.html\">http://wenku.baidu.com/view/699d9749cf84b9d528ea7a82.html</a></p>\n','GRE通用路由封装协议学习笔记','','inherit','open','open','','93-revision-4','','','2013-03-05 15:01:49','2013-03-05 07:01:49','','93','http://blog.wachang.net/2013/03/93-revision-4/','0','revision','','0');");
E_D("replace into `wp_posts` values('103','1','2013-03-05 15:03:05','2013-03-05 07:03:05','<h2>1 背景</h2>\n\n<p>一种技术（协议）或者策略的两个或多个子网穿过另一种技术（协议）或者策略的网络实现互联，称之为overlay topology，这一技术是电信技术的永恒主题之一。</p>\n\n<p>电信技术在发展，多种网络技术并存，一种技术的网络孤岛可能需要穿过另一种技术的网络实现互联，这种情况如果发生在高层协议的PDU封装于低层协议PDU中时通常称之为复用，特别地三层PDU穿过二层网络地技术称为租用链路或虚电路；而如果穿越发生在一种协议PDU封装在同一层协议的PDU中，或者封装在高层协议的PDU中时，人们通常称之为隧道。</p>\n\n<p>隧道提供了一种某一特定网络技术的PDU穿过不具备该技术转发能力的网络的手段，如组播数据包穿过不支持组播的网络；另一种情况是有时因为管理策略的原因，一个管理者（策略）的子网不能通过和另一个管理者（策略）的网络互联而连接，而是要穿过另一个管理者（策略）的网络实现连接，这就是所谓的VPN（Virtual Private Networks），不管是L2 VPN还是L3 VPN都需要利用隧道技术实现。因此隧道某种意义上可以概括为穿越不同的网络的技术，不同既可以是技术方面的，也可以是管理策略方面的。 隧道可以作为一个虚拟接口来实现。隧道接口并不指定特定的“乘客”或“传输”协议连接，而是一种结构，可以实现任何标准点到点封装的服务。由于隧道是点到点连接，因此对每个连接必须配置一个单独的隧道。</p>\n\n<p>GRE是一种应用较为广泛的一种网络层协议PDU封装于任一种网络层协议PDU中的技术，经常被用来构造GRE隧道穿越各种三层网络，并得到了大多数电信设备厂商的支持。</p>\n\n<h2>2 GRE</h2>\n\n<h3>2.1 简介</h3>\n\n<p>GRE(通用路由协议封装）是由Cisco和Net-smiths等公司于1994年提交给IETF的，标号为RFC1701和RFC1702。目前有多数厂商的网络设备均支持GRE隧道协议。GRE 规定了如何用一种网络协议去封装另一种网络协议的方法。GRE的隧道由两端的源IP地址和目的IP地址来定义，允许用户使用IP包封装IP、IPX、 AppleTalk包，并支持全部的路由协议（如RIP2、OSPF等）。通过GRE，用户可以利用公共IP网络连接IPX网络、AppleTalk网 络，还可以使用保留地址进行网络互连，或者对公网隐藏企业网的IP地址。总结来说：</p>\n\n<ul>\n<li>GRE是三层协议，用一种协议来封装另一种协议，使用了隧道tunnel技术</li>\n<li>隧道是虚拟的点对点连接，所以GRE的使用过程中肯定会出现一个虚拟的隧道接口</li>\n</ul>\n\n<h3>2.2 例子</h3>\n\n<p>GRE进行IP封装：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-encap-1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-encap-1-300x176.png\" alt=\"gre-encap-1\" width=\"300\" height=\"176\" class=\"aligncenter size-medium wp-image-94\" /></a></p>\n\n<p>GRE解封装</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-decap-1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-decap-1-300x160.png\" alt=\"gre-decap-1\" width=\"300\" height=\"160\" class=\"aligncenter size-medium wp-image-95\" /></a></p>\n\n<p>上面注意封装后新的<code>协议号是47</code>，这样对端就能发觉这是一个GRE报文，接着递交给GRE相关模块进行解封。GRE报文格式如下：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/GRE-format.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/GRE-format-300x170.png\" alt=\"GRE-format\" width=\"300\" height=\"170\" class=\"aligncenter size-medium wp-image-96\" /></a></p>\n\n<p>GRE在包头中包含了协议类型-47，这用于标明乘客协议的类型；校验和包括了GRE的包头和完整的乘客协议与数据；密钥用于接收端验证接收的数据；序列号用于接收端数据包的排序和差错控制；路由用于本数据包的路由。</p>\n\n<h3>2.3 应用</h3>\n\n<p>下面这个例子就很好的说明了GRE的使用。</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example-300x79.png\" alt=\"gre-example\" width=\"300\" height=\"79\" class=\"aligncenter size-medium wp-image-97\" /></a></p>\n\n<p>如果，在路由器AB之间（中间隔着其他网络）我想使用GRE，第一步需要配置GER的隧道接口，指明源目地址,这一步<code>需要在隧道的两段都进行配置</code>：</p>\n\n<pre><code>##路由器A\ninterface T0\nip address 100.1.1.1 255.255.255.0\ntunnel source 1.1.1.1\ntunnel dst 1.1.1.2\n##路由器B\ninterface T0\nip address 100.1.1.2 255.255.255.0\ntunnel source 1.1.1.2\ntunnel dst 1.1.1.1 （注意是反向的，一个隧道是双向的）\n</code></pre>\n\n<p>下面我们来解释以上配置的作用:</p>\n\n<ul>\n<li>当A上的LO接口的数据（10.1.1.1）希望走GRE隧道到达B上L0接口(20.1.1.1)</li>\n<li>此时在路由A上指定这种数据包走网关是A上T0的地址100.1.1.1（走这里才会进行GRE封装，也就是为什么GRE需要设置两段隧道接口的地址！）</li>\n<li>随后，这个数据包进行GRE封装，封装完成以后，变成一个新包，源地址是1.1.1.1目的地址是1.1.1.2(这就是GRE中设置隧道源目地址的作用，因为数据包肯定是从实际接口发出的，所以这里需要指明隧道两端的实际接口)</li>\n<li>数据包到达路由器B的1.1.1.2口，显示<code>src=1.1.1.1</code>,<code>dst=1.1.1.2</code>，<code>协议号47</code>于是B知道了，这个是GRE报文，然后交给GRE模块处理，GRE模块解封GRE头，得到原来的信息，源地址10.1.1.1目的地址20.1.1.1，交给协议栈处理，作用到达应用处。</li>\n</ul>\n\n<p>最后是路由器A上数据包走向的一个截图，可以参考一下:</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example-2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example-2-300x178.png\" alt=\"gre-example-2\" width=\"300\" height=\"178\" class=\"aligncenter size-medium wp-image-98\" /></a></p>\n\n<h2>参考资料</h2>\n\n<p><a href=\"http://blog.sina.com.cn/s/blog_4fad46a801015wto.html\">http://blog.sina.com.cn/s/blog_4fad46a801015wto.html</a></p>\n\n<p><a href=\"http://wenku.baidu.com/view/b88e564ff7ec4afe04a1df4b.html\">http://wenku.baidu.com/view/b88e564ff7ec4afe04a1df4b.html</a></p>\n\n<p><a href=\"http://wenku.baidu.com/view/699d9749cf84b9d528ea7a82.html\">http://wenku.baidu.com/view/699d9749cf84b9d528ea7a82.html</a></p>\n','GRE通用路由封装协议学习笔记','','inherit','open','open','','93-revision-5','','','2013-03-05 15:03:05','2013-03-05 07:03:05','','93','http://blog.wachang.net/2013/03/93-revision-5/','0','revision','','0');");
E_D("replace into `wp_posts` values('104','1','2013-03-05 15:03:40','2013-03-05 07:03:40','<h2>1 背景</h2>\n\n<p>一种技术（协议）或者策略的两个或多个子网穿过另一种技术（协议）或者策略的网络实现互联，称之为overlay topology，这一技术是电信技术的永恒主题之一。</p>\n\n<p>电信技术在发展，多种网络技术并存，一种技术的网络孤岛可能需要穿过另一种技术的网络实现互联，这种情况如果发生在高层协议的PDU封装于低层协议PDU中时通常称之为复用，特别地三层PDU穿过二层网络地技术称为租用链路或虚电路；而如果穿越发生在一种协议PDU封装在同一层协议的PDU中，或者封装在高层协议的PDU中时，人们通常称之为隧道。</p>\n\n<p>隧道提供了一种某一特定网络技术的PDU穿过不具备该技术转发能力的网络的手段，如组播数据包穿过不支持组播的网络；另一种情况是有时因为管理策略的原因，一个管理者（策略）的子网不能通过和另一个管理者（策略）的网络互联而连接，而是要穿过另一个管理者（策略）的网络实现连接，这就是所谓的VPN（Virtual Private Networks），不管是L2 VPN还是L3 VPN都需要利用隧道技术实现。因此隧道某种意义上可以概括为穿越不同的网络的技术，不同既可以是技术方面的，也可以是管理策略方面的。 隧道可以作为一个虚拟接口来实现。隧道接口并不指定特定的“乘客”或“传输”协议连接，而是一种结构，可以实现任何标准点到点封装的服务。由于隧道是点到点连接，因此对每个连接必须配置一个单独的隧道。</p>\n\n<p>GRE是一种应用较为广泛的一种网络层协议PDU封装于任一种网络层协议PDU中的技术，经常被用来构造GRE隧道穿越各种三层网络，并得到了大多数电信设备厂商的支持。</p>\n\n<h2>2 GRE</h2>\n\n<h3>2.1 简介</h3>\n\n<p>GRE(通用路由协议封装）是由Cisco和Net-smiths等公司于1994年提交给IETF的，标号为RFC1701和RFC1702。目前有多数厂商的网络设备均支持GRE隧道协议。GRE 规定了如何用一种网络协议去封装另一种网络协议的方法。GRE的隧道由两端的源IP地址和目的IP地址来定义，允许用户使用IP包封装IP、IPX、 AppleTalk包，并支持全部的路由协议（如RIP2、OSPF等）。通过GRE，用户可以利用公共IP网络连接IPX网络、AppleTalk网 络，还可以使用保留地址进行网络互连，或者对公网隐藏企业网的IP地址。总结来说：</p>\n\n<ul>\n<li>GRE是三层协议，用一种协议来封装另一种协议，使用了隧道tunnel技术</li>\n<li>隧道是虚拟的点对点连接，所以GRE的使用过程中肯定会出现一个虚拟的隧道接口</li>\n</ul>\n\n<h3>2.2 例子</h3>\n\n<p>GRE进行IP封装：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-encap-1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-encap-1-300x176.png\" alt=\"gre-encap-1\" width=\"300\" height=\"176\" class=\"aligncenter size-medium wp-image-94\" /></a></p>\n\n<p>GRE解封装</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-decap-1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-decap-1-300x160.png\" alt=\"gre-decap-1\" width=\"300\" height=\"160\" class=\"aligncenter size-medium wp-image-95\" /></a></p>\n\n<p>上面注意封装后新的<code>协议号是47</code>，这样对端就能发觉这是一个GRE报文，接着递交给GRE相关模块进行解封。GRE报文格式如下：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/GRE-format.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/GRE-format-300x170.png\" alt=\"GRE-format\" width=\"300\" height=\"170\" class=\"aligncenter size-medium wp-image-96\" /></a></p>\n\n<p>GRE在包头中包含了协议类型-47，这用于标明乘客协议的类型；校验和包括了GRE的包头和完整的乘客协议与数据；密钥用于接收端验证接收的数据；序列号用于接收端数据包的排序和差错控制；路由用于本数据包的路由。</p>\n\n<h3>2.3 应用</h3>\n\n<p>下面这个例子就很好的说明了GRE的使用。</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example-300x79.png\" alt=\"gre-example\" width=\"300\" height=\"79\" class=\"aligncenter size-medium wp-image-97\" /></a></p>\n\n<p>如果，在路由器AB之间（中间隔着其他网络）我想使用GRE，第一步需要配置GER的隧道接口，指明源目地址,这一步<code>需要在隧道的两段都进行配置</code>：</p>\n\n<pre><code>##路由器A\ninterface T0\nip address 100.1.1.1 255.255.255.0\ntunnel source 1.1.1.1\ntunnel dst 1.1.1.2\n##路由器B\ninterface T0\nip address 100.1.1.2 255.255.255.0\ntunnel source 1.1.1.2\ntunnel dst 1.1.1.1 （注意是反向的，一个隧道是双向的）\n</code></pre>\n\n<p>下面我们来解释以上配置的作用:</p>\n\n<ul>\n<li>当A上的LO接口的数据（10.1.1.1）希望走GRE隧道到达B上L0接口(20.1.1.1)</li>\n<li>此时在路由A上指定这种数据包走网关是A上T0的地址100.1.1.1（走这里才会进行GRE封装，也就是为什么GRE需要设置两段隧道接口的地址！）</li>\n<li>随后，这个数据包进行GRE封装，封装完成以后，变成一个新包，源地址是1.1.1.1目的地址是1.1.1.2(这就是GRE中设置隧道源目地址的作用，因为数据包肯定是从实际接口发出的，所以这里需要指明隧道两端的实际接口)</li>\n<li>数据包到达路由器B的1.1.1.2口，显示<code>src=1.1.1.1</code>,<code>dst=1.1.1.2</code>，<code>协议号47</code>于是B知道了，这个是GRE报文，然后交给GRE模块处理，GRE模块解封GRE头，得到原来的信息，源地址10.1.1.1目的地址20.1.1.1，交给协议栈处理，作用到达应用处。</li>\n</ul>\n\n<p>最后是路由器A上数据包走向的一个截图，可以参考一下:</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example-2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example-2-300x178.png\" alt=\"gre-example-2\" width=\"300\" height=\"178\" class=\"aligncenter size-medium wp-image-98\" /></a></p>\n\n<h2>4 参考资料</h2>\n\n<p><a href=\"http://blog.sina.com.cn/s/blog_4fad46a801015wto.html\">http://blog.sina.com.cn/s/blog_4fad46a801015wto.html</a></p>\n\n<p><a href=\"http://wenku.baidu.com/view/b88e564ff7ec4afe04a1df4b.html\">http://wenku.baidu.com/view/b88e564ff7ec4afe04a1df4b.html</a></p>\n\n<p><a href=\"http://wenku.baidu.com/view/699d9749cf84b9d528ea7a82.html\">http://wenku.baidu.com/view/699d9749cf84b9d528ea7a82.html</a></p>\n','GRE通用路由封装协议学习笔记','','inherit','open','open','','93-revision-6','','','2013-03-05 15:03:40','2013-03-05 07:03:40','','93','http://blog.wachang.net/2013/03/93-revision-6/','0','revision','','0');");
E_D("replace into `wp_posts` values('105','1','2013-03-05 18:11:46','0000-00-00 00:00:00','<p>http://digest.definite.name/a-hands-to-write-an-openvpn-wrapper-to-optimize-the-openvpn-performance.html</p>\n\n<p>关于openvpn文章目录\nhttp://blog.csdn.net/dog250/article/details/6990814</p>\n','也说OpenVPN性能优化加速','','draft','open','open','','','','','2013-03-05 18:11:46','2013-03-05 10:11:46','','0','http://blog.wachang.net/?p=105','0','post','','0');");
E_D("replace into `wp_posts` values('106','1','2013-03-05 15:15:45','2013-03-05 07:15:45','\n','也说OpenVPN性能加速','','inherit','open','open','','105-revision','','','2013-03-05 15:15:45','2013-03-05 07:15:45','','105','http://blog.wachang.net/2013/03/105-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('107','1','2013-03-05 16:26:00','2013-03-05 08:26:00','<p>http://digest.definite.name/a-hands-to-write-an-openvpn-wrapper-to-optimize-the-openvpn-performance.html</p>\n\n<p>关于openvpn文章目录\nhttp://blog.csdn.net/dog250/article/details/6990814</p>\n','也说OpenVPN性能优化加速','','inherit','open','open','','105-revision-2','','','2013-03-05 16:26:00','2013-03-05 08:26:00','','105','http://blog.wachang.net/2013/03/105-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('109','1','2013-03-07 00:17:11','0000-00-00 00:00:00','<h2>Linux/Ubuntu 如何查看和杀死僵尸进程</h2>\n\n<p>http://blog.51osos.com/linux/linux-how-to-kill-zombie-process/</p>\n','','','draft','open','open','','','','','2013-03-07 00:17:11','2013-03-06 16:17:11','','0','http://blog.wachang.net/?p=109','0','post','','0');");
E_D("replace into `wp_posts` values('110','1','2013-03-07 22:02:21','0000-00-00 00:00:00','<p>local 222.197.180.135\nport 1194\nproto udp</p>\n\n<p>ca /etc/openvpn/ca.crt\ncert /etc/openvpn/myservername.crt\nkey /etc/openvpn/myservername.key</p>\n\n<p>dh /etc/openvpn/dh1024.pem 哈弗曼参数</p>\n\n<p>server 10.8.0.0 255.255.255.0 。1作为自己使用\nifconfig-pool-persist /var/log/openvpn/ipp.txt 记录用户IP的\npush \"route 192.168.1.0 255.255.255.0\"\npush \"redirect-gateway def1 bypass-dhcp bypass-dns\" 客户端所有流量走VPN</p>\n\n<p>push \"redirect-gateway def1 bypass-dhcp\"\npush \"dhcp-option DNS 8.8.8.8\"推送DNS\nclient-to-client\nduplicate-cn\nkeepalive 10 120盘算死没死\ncomp-lzo压缩</p>\n\n<p>http://blog.sina.com.cn/s/blog_54bf138001000800.html\nhttp://blog.sina.com.cn/s/blog_54bf138001000801.html</p>\n\n<p>Nginx&amp;&amp;PHP-FPM配置及优化指南（上）\nhttp://blog.csdn.net/uuleaf/article/details/7739538</p>\n','OpenVPN配置解释','','draft','open','open','','','','','2013-03-07 22:02:21','2013-03-07 14:02:21','','0','http://blog.wachang.net/?p=110','0','post','','0');");
E_D("replace into `wp_posts` values('111','1','2013-03-07 22:02:16','2013-03-07 14:02:16','<p>local 222.197.180.135\nport 1194\nproto udp</p>\n\n<p>ca /etc/openvpn/ca.crt\ncert /etc/openvpn/myservername.crt\nkey /etc/openvpn/myservername.key</p>\n\n<p>dh /etc/openvpn/dh1024.pem 哈弗曼参数</p>\n\n<p>server 10.8.0.0 255.255.255.0 。1作为自己使用\nifconfig-pool-persist /var/log/openvpn/ipp.txt 记录用户IP的\npush \"route 192.168.1.0 255.255.255.0\"\npush \"redirect-gateway def1 bypass-dhcp bypass-dns\" 客户端所有流量走VPN</p>\n\n<p>push \"redirect-gateway def1 bypass-dhcp\"\npush \"dhcp-option DNS 8.8.8.8\"推送DNS\nclient-to-client\nduplicate-cn\nkeepalive 10 120盘算死没死\ncomp-lzo压缩</p>\n\n<p>http://blog.sina.com.cn/s/blog_54bf138001000800.html\nhttp://blog.sina.com.cn/s/blog_54bf138001000801.html</p>\n\n<p>Nginx&amp;&amp;PHP-FPM配置及优化指南（上）</p>\n','OpenVPN配置解释','','inherit','open','open','','110-revision','','','2013-03-07 22:02:16','2013-03-07 14:02:16','','110','http://blog.wachang.net/2013/03/110-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('112','1','2013-03-08 01:13:18','2013-03-07 17:13:18','<p>主要是自己的学习笔记以及网上资料的参考，按照自己的口味总结，以后稍微参考一下就能熟练上手，本系列暂定写4章：</p>\n\n<p>第一章：<a href=\"http://blog.wachang.net/2013/03/iptables-usage-ref-1/\">流程介绍</a></p>\n\n<p>第二章：如何使用</p>\n\n<p>第三章：深入理解</p>\n\n<p>第四章：高级用法</p>\n\n<h2>1 几句话介绍iptables</h2>\n\n<p>Linux内核中有一个联网子系统netfilter，提供了有状态和无状态的分组过滤，同时提供了NAT和IP伪装服务。<strong>这个系统可以通过工具iptables来进行控制</strong>。</p>\n\n<!--more-->\n\n<h2>2 规则，链，表</h2>\n\n<p>既然是用来处理过滤数据包神马的，那么最基本的肯定就是规则了，一个规则就定义了对一个满足某些条件的数据包应该肿么做，这是最基本的了。我们又看，对于数据包，最终处理它的是规则，那么处理的时机又可以是进入系统的时候或者出系统的时候，所以我们又提出链，一个链包含了一些规则。最后，那么多的规则，又不好管理，于是又来了一个表，iptables以表的形式来管理规则，而且表这个东西又和应用挂钩，比如与NAT有关的链，规则我就放到一个NAT表中。于是乎，概念就解释完了，下面列出iptables里面的链和表：</p>\n\n<p>iptables里面：</p>\n\n<p><strong>规则：</strong>有很多个，你自己定义。</p>\n\n<p><strong>链：</strong>包含了一些规则，主要有以下的链（主要是根据处理时机划分的）</p>\n\n<ul>\n<li>INPUT链：包含处理入站数据包的一些规则</li>\n<li>OUTPUT：包含处理出站数据包的一些规则</li>\n<li>FORWARD：包含处理转发数据包的一些规则，转发数据包：就是不进入本机应用程序，而是从本机转发出去的包。</li>\n<li>POSTROUTING链：在进行路由选择后处理数据包</li>\n<li>PREROUTING链：在进行路由选择前处理数据包，无论数据包是否进入代理服务器内部，还是直接转发，都要先进行这条链的匹配。</li>\n</ul>\n\n<p><strong>默认的表：</strong></p>\n\n<ul>\n<li>raw表：debug测试，确认是否对该数据包进行状态跟踪</li>\n<li>mangle表：为数据包设置标记,主要是改变包的TOS,TTL,MARK属性，一般不操作。包含了PREROUTING,POSTROUTING,FORWARD,INPUT,OUTPUT链。</li>\n<li>nat表：主要做SNAT,DNAT，MASQUERADE的，包含INPUT OUTPUT PREROUTING POSTROUTING四条链</li>\n<li>filer表：对数据包进行过滤，准许什么数据包通过accept，不许什么数据包通过drop，并且这个规则表也是默认的</li>\n</ul>\n\n<p>最后补充一点，iptables中，表是唯一的，也就是不存在两个NAT表，而链则不是唯一的，比如NAT表和MANGLE表都有一个INPUT链，他们的INPUT链中的规则是不一样的。而链中的具体规则，也不是唯一的，INPUT链和OUTPUT链中都可以存在一个一样的规则。</p>\n\n<h2>3 数据包流程</h2>\n\n<p>总结一句话概括就是 当数据包到达防火墙时，如果MAC地址符合，就会由内核里相应的驱动程序接收，当数据包经过某个表的某个链时，iptables对比数据包和设定的规则，进行处理，决定是发送给本地的程序，还是转发给其他机子，还是其他的什么。</p>\n\n<p>我们来细细说：</p>\n\n<p>首先看下面这张图：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-workflow.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-workflow-1024x528.jpg\" alt=\"iptables-workflow\" width=\"1024\" height=\"528\" class=\"aligncenter size-large wp-image-113\" /></a></p>\n\n<p>然后我们来加深理解：</p>\n\n<p><strong>对于收到的数据包，表是有优先级的哦</strong></p>\n\n<p>raw->mangle->nat(转换)->filter(过滤),每一步的处理根据上图中的优先级顺序来的哦。</p>\n\n<p>规则链间的匹配顺序</p>\n\n<p>　　入站数据：PREROUTING、INPUT</p>\n\n<p>　　出站数据：OUTPUT、POSTROUTING</p>\n\n<p>　　转发数据：PREROUTING、FORWARD、POSTROUTING</p>\n\n<p>按顺序依次进行检查，找到相匹配的规则即停止(LOG策略会有例外)</p>\n\n<p>检测下看懂木有，以下是三个图，请对比上面的流程图理解，会恍然大悟的。</p>\n\n<p><strong>1 以本地为目标（就是我们自己的机子了）的包</strong></p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-1.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-1-1024x192.jpg\" alt=\"iptables-example-1\" width=\"1024\" height=\"192\" class=\"aligncenter size-large wp-image-114\" /></a></p>\n\n<p><strong>2 以本地为源的包</strong></p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-2.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-2-1024x179.jpg\" alt=\"iptables-example-2\" width=\"1024\" height=\"179\" class=\"aligncenter size-large wp-image-115\" /></a></p>\n\n<p><strong>3 被转发的包</strong></p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-3.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-3-1024x226.jpg\" alt=\"iptables-example-3\" width=\"1024\" height=\"226\" class=\"aligncenter size-large wp-image-116\" /></a></p>\n\n<p>最后再来一张差不多的图。</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/tables_traverse.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/tables_traverse.jpg\" alt=\"tables_traverse\" width=\"525\" height=\"585\" class=\"aligncenter size-full wp-image-117\" /></a></p>\n\n<p>在第一个路由判断处，不是发往本地的包，我们会发送它穿过 FORWARD链。若包的目的地是本地监听的IP地址，我们就会发送这个包穿过INPUT链，最后到达本地。</p>\n\n<p>值得注意的是，在做NAT的过程中，发往本机的包的目的地址可能会在PREROUTING链里被改变。这个操作发生在第一次路由之前，所以在地址被改变之后，才能对包进行路由。注意，所有的包都会经过上图中的某 一条路径。如果你把一个包DNAT回它原来的网络，这个包会继续走完相应路径上剩下的链，直到它被发送回原来的网络。 这一节就到这里，了解了数据包的流程，下一节我们就讲讲怎么使用iptables了。</p>\n\n<h2>4 参考文章</h2>\n\n<p><a href=\"http://linux.ccidnet.com/art/737/20060705/596545_1.html\">http://linux.ccidnet.com/art/737/20060705/596545_1.html</a></p>\n\n<p><a href=\"http://man.chinaunix.net/network/iptables-tutorial-cn-1.1.19.html\">http://man.chinaunix.net/network/iptables-tutorial-cn-1.1.19.html</a></p>\n\n<p><a href=\"http://linux.ccidnet.com/pub/html/tech/iptables/index.htm\">http://linux.ccidnet.com/pub/html/tech/iptables/index.htm</a></p>\n','Iptables使用参考手册(一)','','publish','open','open','','iptables-useage-ref-1','','','2013-03-08 16:41:23','2013-03-08 08:41:23','','0','http://blog.wachang.net/?p=112','0','post','','0');");
E_D("replace into `wp_posts` values('113','1','2013-03-08 01:02:13','2013-03-07 17:02:13','','iptables-workflow','','inherit','open','open','','iptables-workflow','','','2013-03-08 01:02:13','2013-03-07 17:02:13','','112','http://blog.wachang.net/wp-content/uploads/2013/03/iptables-workflow.jpg','0','attachment','image/jpeg','0');");
E_D("replace into `wp_posts` values('114','1','2013-03-08 01:05:09','2013-03-07 17:05:09','','iptables-example-1','','inherit','open','open','','iptables-example-1','','','2013-03-08 01:05:09','2013-03-07 17:05:09','','112','http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-1.jpg','0','attachment','image/jpeg','0');");
E_D("replace into `wp_posts` values('115','1','2013-03-08 01:06:07','2013-03-07 17:06:07','','iptables-example-2','','inherit','open','open','','iptables-example-2','','','2013-03-08 01:06:07','2013-03-07 17:06:07','','112','http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-2.jpg','0','attachment','image/jpeg','0');");
E_D("replace into `wp_posts` values('116','1','2013-03-08 01:06:54','2013-03-07 17:06:54','','iptables-example-3','','inherit','open','open','','iptables-example-3','','','2013-03-08 01:06:54','2013-03-07 17:06:54','','112','http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-3.jpg','0','attachment','image/jpeg','0');");
E_D("replace into `wp_posts` values('117','1','2013-03-08 01:07:14','2013-03-07 17:07:14','','tables_traverse','','inherit','open','open','','tables_traverse','','','2013-03-08 01:07:14','2013-03-07 17:07:14','','112','http://blog.wachang.net/wp-content/uploads/2013/03/tables_traverse.jpg','0','attachment','image/jpeg','0');");
E_D("replace into `wp_posts` values('118','1','2013-03-08 01:06:22','2013-03-07 17:06:22','<p>主要是自己的学习笔记以及网上资料的参考，按照自己的口味总结，以后稍微参考一下就能熟练上手，本系列暂定写4章：\n第一章：介绍\n第二章：如何使用\n第三章：深入理解\n第四章：高级用法</p>\n\n<h2>1 几句话介绍iptables</h2>\n\n<p>Linux内核中有一个联网子系统netfilter，提供了有状态和无状态的分组过滤，同时提供了NAT和IP伪装服务。{% highlight 这个系统可以通过工具iptables来进行控制 %}。</p>\n\n<h2>2 规则，链，表</h2>\n\n<p>既然是用来处理过滤数据包神马的，那么最基本的肯定就是规则了，一个规则就定义了对一个满足某些条件的数据包应该肿么做，这是最基本的了。我们又看，对于数据包，最终处理它的是规则，那么处理的时机又可以是进入系统的时候或者出系统的时候，所以我们又提出链，一个链包含了一些规则。最后，那么多的规则，又不好管理，于是又来了一个表，iptables以表的形式来管理规则，而且表这个东西又和应用挂钩，比如与NAT有关的链，规则我就放到一个NAT表中。于是乎，概念就解释完了，下面列出iptables里面的链和表：</p>\n\n<p>iptables里面：</p>\n\n<p><strong>规则：</strong>有很多个，你自己定义。</p>\n\n<p><strong>链：</strong>包含了一些规则，主要有以下的链（主要是根据处理时机划分的）</p>\n\n<ul>\n<li>INPUT链：包含处理入站数据包的一些规则</li>\n<li>OUTPUT：包含处理出站数据包的一些规则</li>\n<li>FORWARD：包含处理转发数据包的一些规则，转发数据包：就是不进入本机应用程序，而是从本机转发出去的包。</li>\n<li>POSTROUTING链：在进行路由选择后处理数据包</li>\n<li>PREROUTING链：在进行路由选择前处理数据包，无论数据包是否进入代理服务器内部，还是直接转发，都要先进行这条链的匹配。</li>\n</ul>\n\n<p><strong>默认的表：</strong></p>\n\n<ul>\n<li>raw表：debug测试，确认是否对该数据包进行状态跟踪</li>\n<li>mangle表：为数据包设置标记,主要是改变包的TOS,TTL,MARK属性，一般不操作。包含了PREROUTING,POSTROUTING,FORWARD,INPUT,OUTPUT链。</li>\n<li>nat表：主要做SNAT,DNAT，MASQUERADE的，包含INPUT OUTPUT PREROUTING POSTROUTING四条链</li>\n<li>filer表：对数据包进行过滤，准许什么数据包通过accept，不许什么数据包通过drop，并且这个规则表也是默认的</li>\n</ul>\n\n<p>最后补充一点，iptables中，表是唯一的，也就是不存在两个NAT表，而链则不是唯一的，比如NAT表和MANGLE表都有一个INPUT链，他们的INPUT链中的规则是不一样的。而链中的具体规则，也不是唯一的，INPUT链和OUTPUT链中都可以存在一个一样的规则。</p>\n\n<h2>3 数据包流程</h2>\n\n<p>总结一句话概括就是\n当数据包到达防火墙时，如果MAC地址符合，就会由内核里相应的驱动程序接收，当数据包经过某个表的某个链时，iptables对比数据包和设定的规则，进行处理，决定是发送给本地的程序，还是转发给其他机子，还是其他的什么。</p>\n\n<p>我们来细细说：</p>\n\n<p>首先看下面这张图：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-workflow.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-workflow-1024x528.jpg\" alt=\"iptables-workflow\" width=\"1024\" height=\"528\" class=\"aligncenter size-large wp-image-113\" /></a></p>\n\n<p>然后我们来加深理解：</p>\n\n<p><strong>对于收到的数据包，表是有优先级的哦</strong></p>\n\n<p>raw->mangle->nat(转换)->filter(过滤),每一步的处理根据上图中的优先级顺序来的哦。</p>\n\n<p>规则链间的匹配顺序</p>\n\n<p>　　入站数据：PREROUTING、INPUT</p>\n\n<p>　　出站数据：OUTPUT、POSTROUTING</p>\n\n<p>　　转发数据：PREROUTING、FORWARD、POSTROUTING</p>\n\n<p>按顺序依次进行检查，找到相匹配的规则即停止(LOG策略会有例外)</p>\n\n<p>检测下看懂木有，以下是三个图，请对比上面的流程图理解，会恍然大悟的。</p>\n\n<p><strong>1 以本地为目标（就是我们自己的机子了）的包</strong></p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-1.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-1-1024x192.jpg\" alt=\"iptables-example-1\" width=\"1024\" height=\"192\" class=\"aligncenter size-large wp-image-114\" /></a></p>\n\n<p><strong>2 以本地为源的包</strong></p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-2.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-2-1024x179.jpg\" alt=\"iptables-example-2\" width=\"1024\" height=\"179\" class=\"aligncenter size-large wp-image-115\" /></a></p>\n\n<p><strong>3 被转发的包</strong></p>\n\n<p>最后再来一张差不多的图。\n在第一个路由判断处，不是发往本地的包，我们会发送它穿过 FORWARD链。若包的目的地是本地监听的IP地址，我们就会发送这个包穿过INPUT链，最后到达本地。</p>\n\n<p>值得注意的是，在做NAT的过程中，发往本机的包的目的地址可能会在PREROUTING链里被改变。这个操作发生在第一次路由之前，所以在地址被改变之后，才能对包进行路由。注意，所有的包都会经过上图中的某 一条路径。如果你把一个包DNAT回它原来的网络，这个包会继续走完相应路径上剩下的链，直到它被发送回原来的网络。\n这一节就到这里，了解了数据包的流程，下一节我们就讲讲怎么使用iptables了。</p>\n\n<h2>4 参考文章</h2>\n\n<p>http://linux.ccidnet.com/art/737/20060705/596545_1.html\nhttp://man.chinaunix.net/network/iptables-tutorial-cn-1.1.19.html\nhttp://linux.ccidnet.com/pub/html/tech/iptables/index.htm</p>\n','Iptables使用参考手册(一)','','inherit','open','open','','112-revision','','','2013-03-08 01:06:22','2013-03-07 17:06:22','','112','http://blog.wachang.net/2013/03/112-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('119','1','2013-03-08 01:08:23','2013-03-07 17:08:23','<p>主要是自己的学习笔记以及网上资料的参考，按照自己的口味总结，以后稍微参考一下就能熟练上手，本系列暂定写4章：\n第一章：介绍\n第二章：如何使用\n第三章：深入理解\n第四章：高级用法</p>\n\n<h2>1 几句话介绍iptables</h2>\n\n<p>Linux内核中有一个联网子系统netfilter，提供了有状态和无状态的分组过滤，同时提供了NAT和IP伪装服务。{% highlight 这个系统可以通过工具iptables来进行控制 %}。</p>\n\n<h2>2 规则，链，表</h2>\n\n<p>既然是用来处理过滤数据包神马的，那么最基本的肯定就是规则了，一个规则就定义了对一个满足某些条件的数据包应该肿么做，这是最基本的了。我们又看，对于数据包，最终处理它的是规则，那么处理的时机又可以是进入系统的时候或者出系统的时候，所以我们又提出链，一个链包含了一些规则。最后，那么多的规则，又不好管理，于是又来了一个表，iptables以表的形式来管理规则，而且表这个东西又和应用挂钩，比如与NAT有关的链，规则我就放到一个NAT表中。于是乎，概念就解释完了，下面列出iptables里面的链和表：</p>\n\n<p>iptables里面：</p>\n\n<p><strong>规则：</strong>有很多个，你自己定义。</p>\n\n<p><strong>链：</strong>包含了一些规则，主要有以下的链（主要是根据处理时机划分的）</p>\n\n<ul>\n<li>INPUT链：包含处理入站数据包的一些规则</li>\n<li>OUTPUT：包含处理出站数据包的一些规则</li>\n<li>FORWARD：包含处理转发数据包的一些规则，转发数据包：就是不进入本机应用程序，而是从本机转发出去的包。</li>\n<li>POSTROUTING链：在进行路由选择后处理数据包</li>\n<li>PREROUTING链：在进行路由选择前处理数据包，无论数据包是否进入代理服务器内部，还是直接转发，都要先进行这条链的匹配。</li>\n</ul>\n\n<p><strong>默认的表：</strong></p>\n\n<ul>\n<li>raw表：debug测试，确认是否对该数据包进行状态跟踪</li>\n<li>mangle表：为数据包设置标记,主要是改变包的TOS,TTL,MARK属性，一般不操作。包含了PREROUTING,POSTROUTING,FORWARD,INPUT,OUTPUT链。</li>\n<li>nat表：主要做SNAT,DNAT，MASQUERADE的，包含INPUT OUTPUT PREROUTING POSTROUTING四条链</li>\n<li>filer表：对数据包进行过滤，准许什么数据包通过accept，不许什么数据包通过drop，并且这个规则表也是默认的</li>\n</ul>\n\n<p>最后补充一点，iptables中，表是唯一的，也就是不存在两个NAT表，而链则不是唯一的，比如NAT表和MANGLE表都有一个INPUT链，他们的INPUT链中的规则是不一样的。而链中的具体规则，也不是唯一的，INPUT链和OUTPUT链中都可以存在一个一样的规则。</p>\n\n<h2>3 数据包流程</h2>\n\n<p>总结一句话概括就是\n当数据包到达防火墙时，如果MAC地址符合，就会由内核里相应的驱动程序接收，当数据包经过某个表的某个链时，iptables对比数据包和设定的规则，进行处理，决定是发送给本地的程序，还是转发给其他机子，还是其他的什么。</p>\n\n<p>我们来细细说：</p>\n\n<p>首先看下面这张图：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-workflow.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-workflow-1024x528.jpg\" alt=\"iptables-workflow\" width=\"1024\" height=\"528\" class=\"aligncenter size-large wp-image-113\" /></a></p>\n\n<p>然后我们来加深理解：</p>\n\n<p><strong>对于收到的数据包，表是有优先级的哦</strong></p>\n\n<p>raw->mangle->nat(转换)->filter(过滤),每一步的处理根据上图中的优先级顺序来的哦。</p>\n\n<p>规则链间的匹配顺序</p>\n\n<p>　　入站数据：PREROUTING、INPUT</p>\n\n<p>　　出站数据：OUTPUT、POSTROUTING</p>\n\n<p>　　转发数据：PREROUTING、FORWARD、POSTROUTING</p>\n\n<p>按顺序依次进行检查，找到相匹配的规则即停止(LOG策略会有例外)</p>\n\n<p>检测下看懂木有，以下是三个图，请对比上面的流程图理解，会恍然大悟的。</p>\n\n<p><strong>1 以本地为目标（就是我们自己的机子了）的包</strong></p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-1.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-1-1024x192.jpg\" alt=\"iptables-example-1\" width=\"1024\" height=\"192\" class=\"aligncenter size-large wp-image-114\" /></a></p>\n\n<p><strong>2 以本地为源的包</strong></p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-2.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-2-1024x179.jpg\" alt=\"iptables-example-2\" width=\"1024\" height=\"179\" class=\"aligncenter size-large wp-image-115\" /></a></p>\n\n<p><strong>3 被转发的包</strong></p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-3.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-3-1024x226.jpg\" alt=\"iptables-example-3\" width=\"1024\" height=\"226\" class=\"aligncenter size-large wp-image-116\" /></a></p>\n\n<p>最后再来一张差不多的图。</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/tables_traverse.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/tables_traverse.jpg\" alt=\"tables_traverse\" width=\"525\" height=\"585\" class=\"aligncenter size-full wp-image-117\" /></a></p>\n\n<p>在第一个路由判断处，不是发往本地的包，我们会发送它穿过 FORWARD链。若包的目的地是本地监听的IP地址，我们就会发送这个包穿过INPUT链，最后到达本地。</p>\n\n<p>值得注意的是，在做NAT的过程中，发往本机的包的目的地址可能会在PREROUTING链里被改变。这个操作发生在第一次路由之前，所以在地址被改变之后，才能对包进行路由。注意，所有的包都会经过上图中的某 一条路径。如果你把一个包DNAT回它原来的网络，这个包会继续走完相应路径上剩下的链，直到它被发送回原来的网络。\n这一节就到这里，了解了数据包的流程，下一节我们就讲讲怎么使用iptables了。</p>\n\n<h2>4 参考文章</h2>\n\n<p><a href=\"http://linux.ccidnet.com/art/737/20060705/596545_1.html\">http://linux.ccidnet.com/art/737/20060705/596545_1.html</a>\n<a href=\"http://man.chinaunix.net/network/iptables-tutorial-cn-1.1.19.html\">http://man.chinaunix.net/network/iptables-tutorial-cn-1.1.19.html</a>\n<a href=\"http://linux.ccidnet.com/pub/html/tech/iptables/index.htm\">http://linux.ccidnet.com/pub/html/tech/iptables/index.htm</a></p>\n','Iptables使用参考手册(一)','','inherit','open','open','','112-revision-2','','','2013-03-08 01:08:23','2013-03-07 17:08:23','','112','http://blog.wachang.net/2013/03/112-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('121','1','2013-03-08 16:38:47','2013-03-08 08:38:47',' ','','','publish','open','open','','121','','','2013-03-10 00:00:16','2013-03-09 16:00:16','','0','http://blog.wachang.net/?p=121','3','nav_menu_item','','0');");
E_D("replace into `wp_posts` values('122','1','2013-03-08 16:38:47','2013-03-08 08:38:47','','极速版','','publish','open','open','','%e6%9e%81%e9%80%9f%e7%89%88','','','2013-03-10 00:00:16','2013-03-09 16:00:16','','0','http://blog.wachang.net/?p=122','2','nav_menu_item','','0');");
E_D("replace into `wp_posts` values('123','1','2013-03-08 01:13:18','2013-03-07 17:13:18','<p>主要是自己的学习笔记以及网上资料的参考，按照自己的口味总结，以后稍微参考一下就能熟练上手，本系列暂定写4章：</p>\n\n<p>第一章：<a href=\"http://blog.wachang.net/2013/03/iptables-usage-ref-1/\">流程介绍</a></p>\n\n<p>第二章：如何使用</p>\n\n<p>第三章：深入理解</p>\n\n<p>第四章：高级用法</p>\n\n<h2>1 几句话介绍iptables</h2>\n\n<p>Linux内核中有一个联网子系统netfilter，提供了有状态和无状态的分组过滤，同时提供了NAT和IP伪装服务。<strong>这个系统可以通过工具iptables来进行控制</strong>。</p>\n\n<h2>2 规则，链，表</h2>\n\n<p>既然是用来处理过滤数据包神马的，那么最基本的肯定就是规则了，一个规则就定义了对一个满足某些条件的数据包应该肿么做，这是最基本的了。我们又看，对于数据包，最终处理它的是规则，那么处理的时机又可以是进入系统的时候或者出系统的时候，所以我们又提出链，一个链包含了一些规则。最后，那么多的规则，又不好管理，于是又来了一个表，iptables以表的形式来管理规则，而且表这个东西又和应用挂钩，比如与NAT有关的链，规则我就放到一个NAT表中。于是乎，概念就解释完了，下面列出iptables里面的链和表：</p>\n\n<p>iptables里面：</p>\n\n<p><strong>规则：</strong>有很多个，你自己定义。</p>\n\n<p><strong>链：</strong>包含了一些规则，主要有以下的链（主要是根据处理时机划分的）</p>\n\n<ul>\n<li>INPUT链：包含处理入站数据包的一些规则</li>\n<li>OUTPUT：包含处理出站数据包的一些规则</li>\n<li>FORWARD：包含处理转发数据包的一些规则，转发数据包：就是不进入本机应用程序，而是从本机转发出去的包。</li>\n<li>POSTROUTING链：在进行路由选择后处理数据包</li>\n<li>PREROUTING链：在进行路由选择前处理数据包，无论数据包是否进入代理服务器内部，还是直接转发，都要先进行这条链的匹配。</li>\n</ul>\n\n<p><strong>默认的表：</strong></p>\n\n<ul>\n<li>raw表：debug测试，确认是否对该数据包进行状态跟踪</li>\n<li>mangle表：为数据包设置标记,主要是改变包的TOS,TTL,MARK属性，一般不操作。包含了PREROUTING,POSTROUTING,FORWARD,INPUT,OUTPUT链。</li>\n<li>nat表：主要做SNAT,DNAT，MASQUERADE的，包含INPUT OUTPUT PREROUTING POSTROUTING四条链</li>\n<li>filer表：对数据包进行过滤，准许什么数据包通过accept，不许什么数据包通过drop，并且这个规则表也是默认的</li>\n</ul>\n\n<p>最后补充一点，iptables中，表是唯一的，也就是不存在两个NAT表，而链则不是唯一的，比如NAT表和MANGLE表都有一个INPUT链，他们的INPUT链中的规则是不一样的。而链中的具体规则，也不是唯一的，INPUT链和OUTPUT链中都可以存在一个一样的规则。</p>\n\n<h2>3 数据包流程</h2>\n\n<p>总结一句话概括就是\n当数据包到达防火墙时，如果MAC地址符合，就会由内核里相应的驱动程序接收，当数据包经过某个表的某个链时，iptables对比数据包和设定的规则，进行处理，决定是发送给本地的程序，还是转发给其他机子，还是其他的什么。</p>\n\n<p>我们来细细说：</p>\n\n<p>首先看下面这张图：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-workflow.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-workflow-1024x528.jpg\" alt=\"iptables-workflow\" width=\"1024\" height=\"528\" class=\"aligncenter size-large wp-image-113\" /></a></p>\n\n<p>然后我们来加深理解：</p>\n\n<p><strong>对于收到的数据包，表是有优先级的哦</strong></p>\n\n<p>raw->mangle->nat(转换)->filter(过滤),每一步的处理根据上图中的优先级顺序来的哦。</p>\n\n<p>规则链间的匹配顺序</p>\n\n<p>　　入站数据：PREROUTING、INPUT</p>\n\n<p>　　出站数据：OUTPUT、POSTROUTING</p>\n\n<p>　　转发数据：PREROUTING、FORWARD、POSTROUTING</p>\n\n<p>按顺序依次进行检查，找到相匹配的规则即停止(LOG策略会有例外)</p>\n\n<p>检测下看懂木有，以下是三个图，请对比上面的流程图理解，会恍然大悟的。</p>\n\n<p><strong>1 以本地为目标（就是我们自己的机子了）的包</strong></p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-1.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-1-1024x192.jpg\" alt=\"iptables-example-1\" width=\"1024\" height=\"192\" class=\"aligncenter size-large wp-image-114\" /></a></p>\n\n<p><strong>2 以本地为源的包</strong></p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-2.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-2-1024x179.jpg\" alt=\"iptables-example-2\" width=\"1024\" height=\"179\" class=\"aligncenter size-large wp-image-115\" /></a></p>\n\n<p><strong>3 被转发的包</strong></p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-3.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-3-1024x226.jpg\" alt=\"iptables-example-3\" width=\"1024\" height=\"226\" class=\"aligncenter size-large wp-image-116\" /></a></p>\n\n<p>最后再来一张差不多的图。</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/tables_traverse.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/tables_traverse.jpg\" alt=\"tables_traverse\" width=\"525\" height=\"585\" class=\"aligncenter size-full wp-image-117\" /></a></p>\n\n<p>在第一个路由判断处，不是发往本地的包，我们会发送它穿过 FORWARD链。若包的目的地是本地监听的IP地址，我们就会发送这个包穿过INPUT链，最后到达本地。</p>\n\n<p>值得注意的是，在做NAT的过程中，发往本机的包的目的地址可能会在PREROUTING链里被改变。这个操作发生在第一次路由之前，所以在地址被改变之后，才能对包进行路由。注意，所有的包都会经过上图中的某 一条路径。如果你把一个包DNAT回它原来的网络，这个包会继续走完相应路径上剩下的链，直到它被发送回原来的网络。\n这一节就到这里，了解了数据包的流程，下一节我们就讲讲怎么使用iptables了。</p>\n\n<h2>4 参考文章</h2>\n\n<p><a href=\"http://linux.ccidnet.com/art/737/20060705/596545_1.html\">http://linux.ccidnet.com/art/737/20060705/596545_1.html</a></p>\n\n<p><a href=\"http://man.chinaunix.net/network/iptables-tutorial-cn-1.1.19.html\">http://man.chinaunix.net/network/iptables-tutorial-cn-1.1.19.html</a></p>\n\n<p><a href=\"http://linux.ccidnet.com/pub/html/tech/iptables/index.htm\">http://linux.ccidnet.com/pub/html/tech/iptables/index.htm</a></p>\n','Iptables使用参考手册(一)','','inherit','open','open','','112-revision-3','','','2013-03-08 01:13:18','2013-03-07 17:13:18','','112','http://blog.wachang.net/2013/03/112-revision-3/','0','revision','','0');");
E_D("replace into `wp_posts` values('124','1','2013-03-08 16:41:11','2013-03-08 08:41:11','<p>主要是自己的学习笔记以及网上资料的参考，按照自己的口味总结，以后稍微参考一下就能熟练上手，本系列暂定写4章：</p>\n\n<p>第一章：<a href=\"http://blog.wachang.net/2013/03/iptables-usage-ref-1/\">流程介绍</a></p>\n\n<p>第二章：如何使用</p>\n\n<p>第三章：深入理解</p>\n\n<p>第四章：高级用法</p>\n\n<h2>1 几句话介绍iptables</h2>\n\n<p>Linux内核中有一个联网子系统netfilter，提供了有状态和无状态的分组过滤，同时提供了NAT和IP伪装服务。<strong>这个系统可以通过工具iptables来进行控制</strong>。</p>\n\n<p>&lt;!!--more--></p>\n\n<h2>2 规则，链，表</h2>\n\n<p>既然是用来处理过滤数据包神马的，那么最基本的肯定就是规则了，一个规则就定义了对一个满足某些条件的数据包应该肿么做，这是最基本的了。我们又看，对于数据包，最终处理它的是规则，那么处理的时机又可以是进入系统的时候或者出系统的时候，所以我们又提出链，一个链包含了一些规则。最后，那么多的规则，又不好管理，于是又来了一个表，iptables以表的形式来管理规则，而且表这个东西又和应用挂钩，比如与NAT有关的链，规则我就放到一个NAT表中。于是乎，概念就解释完了，下面列出iptables里面的链和表：</p>\n\n<p>iptables里面：</p>\n\n<p><strong>规则：</strong>有很多个，你自己定义。</p>\n\n<p><strong>链：</strong>包含了一些规则，主要有以下的链（主要是根据处理时机划分的）</p>\n\n<ul>\n<li>INPUT链：包含处理入站数据包的一些规则</li>\n<li>OUTPUT：包含处理出站数据包的一些规则</li>\n<li>FORWARD：包含处理转发数据包的一些规则，转发数据包：就是不进入本机应用程序，而是从本机转发出去的包。</li>\n<li>POSTROUTING链：在进行路由选择后处理数据包</li>\n<li>PREROUTING链：在进行路由选择前处理数据包，无论数据包是否进入代理服务器内部，还是直接转发，都要先进行这条链的匹配。</li>\n</ul>\n\n<p><strong>默认的表：</strong></p>\n\n<ul>\n<li>raw表：debug测试，确认是否对该数据包进行状态跟踪</li>\n<li>mangle表：为数据包设置标记,主要是改变包的TOS,TTL,MARK属性，一般不操作。包含了PREROUTING,POSTROUTING,FORWARD,INPUT,OUTPUT链。</li>\n<li>nat表：主要做SNAT,DNAT，MASQUERADE的，包含INPUT OUTPUT PREROUTING POSTROUTING四条链</li>\n<li>filer表：对数据包进行过滤，准许什么数据包通过accept，不许什么数据包通过drop，并且这个规则表也是默认的</li>\n</ul>\n\n<p>最后补充一点，iptables中，表是唯一的，也就是不存在两个NAT表，而链则不是唯一的，比如NAT表和MANGLE表都有一个INPUT链，他们的INPUT链中的规则是不一样的。而链中的具体规则，也不是唯一的，INPUT链和OUTPUT链中都可以存在一个一样的规则。</p>\n\n<h2>3 数据包流程</h2>\n\n<p>总结一句话概括就是 当数据包到达防火墙时，如果MAC地址符合，就会由内核里相应的驱动程序接收，当数据包经过某个表的某个链时，iptables对比数据包和设定的规则，进行处理，决定是发送给本地的程序，还是转发给其他机子，还是其他的什么。</p>\n\n<p>我们来细细说：</p>\n\n<p>首先看下面这张图：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-workflow.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-workflow-1024x528.jpg\" alt=\"iptables-workflow\" width=\"1024\" height=\"528\" class=\"aligncenter size-large wp-image-113\" /></a></p>\n\n<p>然后我们来加深理解：</p>\n\n<p><strong>对于收到的数据包，表是有优先级的哦</strong></p>\n\n<p>raw->mangle->nat(转换)->filter(过滤),每一步的处理根据上图中的优先级顺序来的哦。</p>\n\n<p>规则链间的匹配顺序</p>\n\n<p>　　入站数据：PREROUTING、INPUT</p>\n\n<p>　　出站数据：OUTPUT、POSTROUTING</p>\n\n<p>　　转发数据：PREROUTING、FORWARD、POSTROUTING</p>\n\n<p>按顺序依次进行检查，找到相匹配的规则即停止(LOG策略会有例外)</p>\n\n<p>检测下看懂木有，以下是三个图，请对比上面的流程图理解，会恍然大悟的。</p>\n\n<p><strong>1 以本地为目标（就是我们自己的机子了）的包</strong></p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-1.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-1-1024x192.jpg\" alt=\"iptables-example-1\" width=\"1024\" height=\"192\" class=\"aligncenter size-large wp-image-114\" /></a></p>\n\n<p><strong>2 以本地为源的包</strong></p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-2.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-2-1024x179.jpg\" alt=\"iptables-example-2\" width=\"1024\" height=\"179\" class=\"aligncenter size-large wp-image-115\" /></a></p>\n\n<p><strong>3 被转发的包</strong></p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-3.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/iptables-example-3-1024x226.jpg\" alt=\"iptables-example-3\" width=\"1024\" height=\"226\" class=\"aligncenter size-large wp-image-116\" /></a></p>\n\n<p>最后再来一张差不多的图。</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/tables_traverse.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/tables_traverse.jpg\" alt=\"tables_traverse\" width=\"525\" height=\"585\" class=\"aligncenter size-full wp-image-117\" /></a></p>\n\n<p>在第一个路由判断处，不是发往本地的包，我们会发送它穿过 FORWARD链。若包的目的地是本地监听的IP地址，我们就会发送这个包穿过INPUT链，最后到达本地。</p>\n\n<p>值得注意的是，在做NAT的过程中，发往本机的包的目的地址可能会在PREROUTING链里被改变。这个操作发生在第一次路由之前，所以在地址被改变之后，才能对包进行路由。注意，所有的包都会经过上图中的某 一条路径。如果你把一个包DNAT回它原来的网络，这个包会继续走完相应路径上剩下的链，直到它被发送回原来的网络。 这一节就到这里，了解了数据包的流程，下一节我们就讲讲怎么使用iptables了。</p>\n\n<h2>4 参考文章</h2>\n\n<p><a href=\"http://linux.ccidnet.com/art/737/20060705/596545_1.html\">http://linux.ccidnet.com/art/737/20060705/596545_1.html</a></p>\n\n<p><a href=\"http://man.chinaunix.net/network/iptables-tutorial-cn-1.1.19.html\">http://man.chinaunix.net/network/iptables-tutorial-cn-1.1.19.html</a></p>\n\n<p><a href=\"http://linux.ccidnet.com/pub/html/tech/iptables/index.htm\">http://linux.ccidnet.com/pub/html/tech/iptables/index.htm</a></p>\n','Iptables使用参考手册(一)','','inherit','open','open','','112-revision-4','','','2013-03-08 16:41:11','2013-03-08 08:41:11','','112','http://blog.wachang.net/2013/03/112-revision-4/','0','revision','','0');");
E_D("replace into `wp_posts` values('125','1','2013-03-05 15:04:03','2013-03-05 07:04:03','<h2>1 背景</h2>\n\n<p>一种技术（协议）或者策略的两个或多个子网穿过另一种技术（协议）或者策略的网络实现互联，称之为overlay topology，这一技术是电信技术的永恒主题之一。</p>\n\n<p>电信技术在发展，多种网络技术并存，一种技术的网络孤岛可能需要穿过另一种技术的网络实现互联，这种情况如果发生在高层协议的PDU封装于低层协议PDU中时通常称之为复用，特别地三层PDU穿过二层网络地技术称为租用链路或虚电路；而如果穿越发生在一种协议PDU封装在同一层协议的PDU中，或者封装在高层协议的PDU中时，人们通常称之为隧道。</p>\n\n<p>隧道提供了一种某一特定网络技术的PDU穿过不具备该技术转发能力的网络的手段，如组播数据包穿过不支持组播的网络；另一种情况是有时因为管理策略的原因，一个管理者（策略）的子网不能通过和另一个管理者（策略）的网络互联而连接，而是要穿过另一个管理者（策略）的网络实现连接，这就是所谓的VPN（Virtual Private Networks），不管是L2 VPN还是L3 VPN都需要利用隧道技术实现。因此隧道某种意义上可以概括为穿越不同的网络的技术，不同既可以是技术方面的，也可以是管理策略方面的。 隧道可以作为一个虚拟接口来实现。隧道接口并不指定特定的“乘客”或“传输”协议连接，而是一种结构，可以实现任何标准点到点封装的服务。由于隧道是点到点连接，因此对每个连接必须配置一个单独的隧道。</p>\n\n<p>GRE是一种应用较为广泛的一种网络层协议PDU封装于任一种网络层协议PDU中的技术，经常被用来构造GRE隧道穿越各种三层网络，并得到了大多数电信设备厂商的支持。</p>\n\n<h2>2 GRE</h2>\n\n<h3>2.1 简介</h3>\n\n<p>GRE(通用路由协议封装）是由Cisco和Net-smiths等公司于1994年提交给IETF的，标号为RFC1701和RFC1702。目前有多数厂商的网络设备均支持GRE隧道协议。GRE 规定了如何用一种网络协议去封装另一种网络协议的方法。GRE的隧道由两端的源IP地址和目的IP地址来定义，允许用户使用IP包封装IP、IPX、 AppleTalk包，并支持全部的路由协议（如RIP2、OSPF等）。通过GRE，用户可以利用公共IP网络连接IPX网络、AppleTalk网 络，还可以使用保留地址进行网络互连，或者对公网隐藏企业网的IP地址。总结来说：</p>\n\n<ul>\n<li>GRE是三层协议，用一种协议来封装另一种协议，使用了隧道tunnel技术</li>\n<li>隧道是虚拟的点对点连接，所以GRE的使用过程中肯定会出现一个虚拟的隧道接口</li>\n</ul>\n\n<h3>2.2 例子</h3>\n\n<p>GRE进行IP封装：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-encap-1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-encap-1-300x176.png\" alt=\"gre-encap-1\" width=\"300\" height=\"176\" class=\"aligncenter size-medium wp-image-94\" /></a></p>\n\n<p>GRE解封装</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-decap-1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-decap-1-300x160.png\" alt=\"gre-decap-1\" width=\"300\" height=\"160\" class=\"aligncenter size-medium wp-image-95\" /></a></p>\n\n<p>上面注意封装后新的<code>协议号是47</code>，这样对端就能发觉这是一个GRE报文，接着递交给GRE相关模块进行解封。GRE报文格式如下：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/GRE-format.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/GRE-format-300x170.png\" alt=\"GRE-format\" width=\"300\" height=\"170\" class=\"aligncenter size-medium wp-image-96\" /></a></p>\n\n<p>GRE在包头中包含了协议类型-47，这用于标明乘客协议的类型；校验和包括了GRE的包头和完整的乘客协议与数据；密钥用于接收端验证接收的数据；序列号用于接收端数据包的排序和差错控制；路由用于本数据包的路由。</p>\n\n<h3>2.3 应用</h3>\n\n<p>下面这个例子就很好的说明了GRE的使用。</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example-300x79.png\" alt=\"gre-example\" width=\"300\" height=\"79\" class=\"aligncenter size-medium wp-image-97\" /></a></p>\n\n<p>如果，在路由器AB之间（中间隔着其他网络）我想使用GRE，第一步需要配置GER的隧道接口，指明源目地址,这一步<code>需要在隧道的两段都进行配置</code>：</p>\n\n<pre><code>##路由器A\ninterface T0\nip address 100.1.1.1 255.255.255.0\ntunnel source 1.1.1.1\ntunnel dst 1.1.1.2\n##路由器B\ninterface T0\nip address 100.1.1.2 255.255.255.0\ntunnel source 1.1.1.2\ntunnel dst 1.1.1.1 （注意是反向的，一个隧道是双向的）\n</code></pre>\n\n<p>下面我们来解释以上配置的作用:</p>\n\n<ul>\n<li>当A上的LO接口的数据（10.1.1.1）希望走GRE隧道到达B上L0接口(20.1.1.1)</li>\n<li>此时在路由A上指定这种数据包走网关是A上T0的地址100.1.1.1（走这里才会进行GRE封装，也就是为什么GRE需要设置两段隧道接口的地址！）</li>\n<li>随后，这个数据包进行GRE封装，封装完成以后，变成一个新包，源地址是1.1.1.1目的地址是1.1.1.2(这就是GRE中设置隧道源目地址的作用，因为数据包肯定是从实际接口发出的，所以这里需要指明隧道两端的实际接口)</li>\n<li>数据包到达路由器B的1.1.1.2口，显示<code>src=1.1.1.1</code>,<code>dst=1.1.1.2</code>，<code>协议号47</code>于是B知道了，这个是GRE报文，然后交给GRE模块处理，GRE模块解封GRE头，得到原来的信息，源地址10.1.1.1目的地址20.1.1.1，交给协议栈处理，作用到达应用处。</li>\n</ul>\n\n<p>最后是路由器A上数据包走向的一个截图，可以参考一下:</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example-2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre-example-2-300x178.png\" alt=\"gre-example-2\" width=\"300\" height=\"178\" class=\"aligncenter size-medium wp-image-98\" /></a></p>\n\n<h2>3 参考资料</h2>\n\n<p><a href=\"http://blog.sina.com.cn/s/blog_4fad46a801015wto.html\">http://blog.sina.com.cn/s/blog_4fad46a801015wto.html</a></p>\n\n<p><a href=\"http://wenku.baidu.com/view/b88e564ff7ec4afe04a1df4b.html\">http://wenku.baidu.com/view/b88e564ff7ec4afe04a1df4b.html</a></p>\n\n<p><a href=\"http://wenku.baidu.com/view/699d9749cf84b9d528ea7a82.html\">http://wenku.baidu.com/view/699d9749cf84b9d528ea7a82.html</a></p>\n','GRE通用路由封装协议学习笔记','','inherit','open','open','','93-revision-7','','','2013-03-05 15:04:03','2013-03-05 07:04:03','','93','http://blog.wachang.net/2013/03/93-revision-7/','0','revision','','0');");
E_D("replace into `wp_posts` values('126','1','2013-03-04 18:35:29','2013-03-04 10:35:29','<p>原来这个不是OpenVPN官方自带的内容，还要自己折腾一下啊，找了些资料，这里提供两种方案，总结如下：</p>\n\n<h2>openvpn-auth-ldap</h2>\n\n<p><a href=\"https://code.google.com/p/openvpn-auth-ldap/\">OpenVPN-AUTH-LDAP</a>这是最常见的方案，不过现在一般Ubuntu现在都已经有编译好的包了，所以不用进行复杂的源码编译了。</p>\n\n<pre><code>apt-get install openvpn-auth-ldap\n</code></pre>\n\n<p>然后，先是配置LDAP认证相关内容：</p>\n\n<pre><code>mkdir /etc/openvpn/auth\ncp /usr/share/doc/openvpn-auth-ldap/examples/auth-ldap.conf /etc/openvpn/auth\n</code></pre>\n\n<p>编辑文件<code>/etc/openvpn/auth/auth-ldap.conf</code>:</p>\n\n<pre><code>&lt;LDAP&gt;\n# LDAP server URL\nURL     ldap://X.X.X.X\n\n# Bind DN (If your LDAP server doesn''t support anonymous binds)\n# BindDN        uid=Manager,ou=People,dc=example,dc=com\n\n# Bind Password\n# Password  SecretPassword\n\n# Network timeout (in seconds)\nTimeout     15\n\n# Enable Start TLS\nTLSEnable   no ##这里要注意\n\n# Follow LDAP Referrals (anonymously)\nFollowReferrals yes\n\n# TLS CA Certificate File\nTLSCACertFile   /usr/local/etc/ssl/ca.pem\n\n# TLS CA Certificate Directory\nTLSCACertDir    /etc/ssl/certs\n\n# Client Certificate and key\n# If TLS client authentication is required\nTLSCertFile /usr/local/etc/ssl/client-cert.pem\nTLSKeyFile  /usr/local/etc/ssl/client-key.pem\n\n# Cipher Suite\n# The defaults are usually fine here\n# TLSCipherSuite    ALL:!ADH:@STRENGTH\n&lt;/LDAP&gt;\n\n&lt;Authorization&gt;\n# Base DN\nBaseDN      \"ou=People,dc=oinlab\"\n\n# User Search Filter\nSearchFilter    \"(uid=%u)\" ##这里要注意\n\n# Require Group Membership\nRequireGroup    false ##是否开启组验证\n\n# Add non-group members to a PF table (disabled)\n#PFTable    ips_vpn_users\n\n&lt;Group&gt;\n    BaseDN      \"ou=People,dc=oinlab\"\n    SearchFilter    \"(|(cn=developers)(cn=artists))\"\n    MemberAttribute uniqueMember\n    # Add group members to a PF table (disabled)\n    #PFTable    ips_vpn_eng\n&lt;/Group&gt;\n&lt;/Authorization&gt;\n</code></pre>\n\n<p>完了以后在配置OpenVPN中<code>server.conf</code>文件，加入如下：</p>\n\n<pre><code>plugin /usr/lib/openvpn/openvpn-auth-ldap.so /etc/openvpn/auth/auth-ldap.conf\nclient-cert-not-required ##有了LDAP就不需要证书认证了嘛\n</code></pre>\n\n<p>最后就是配置一下客户端了：</p>\n\n<p>客户端的配置简单，去掉<code>cert xxx.crt</code>以及<code>key xxx.key</code>部分，再加上<code>auth-user-pass</code>就OK。如下就是一个简单的例子：</p>\n\n<pre><code>client\ndev tun\nproto udp\nremote X.X.X.X 1194\nresolv-retry infinite\nnobind\nuser nobody\ngroup nobody\npersist-key\npersist-tun\nca ca.crt\n;cert wangchang.crt\n;key wangchang.key\ncomp-lzo\nverb 3\nauth-user-pass\n</code></pre>\n\n<p>参考资料(需要飞过Wall)：</p>\n\n<p><a href=\"http://cheaster.blogspot.com/2009/11/openvpn-auth-over-ldap.html\">http://cheaster.blogspot.com/2009/11/openvpn-auth-over-ldap.html</a></p>\n\n<p><a href=\"http://www.howtoforge.com/setting-up-an-openvpn-server-with-authentication-against-openldap-on-ubuntu-10.04-lts\">http://www.howtoforge.com/setting-up-an-openvpn-server-with-authentication-against-openldap-on-ubuntu-10.04-lts</a></p>\n\n<h2>脚本方式</h2>\n\n<p>有人就是把插件的功能用一个脚本来实现，相对来说，配置没那么复杂，我没测试过，应该可行。下附链接：</p>\n\n<p><a href=\"http://down.51cto.com/data/573688\">CSDN上的一个下载</a></p>\n\n<p><a href=\"http://redmine.debuntu.org/projects/openvpn-ldap-auth/wiki\">http://redmine.debuntu.org/projects/openvpn-ldap-auth/wiki</a></p>\n\n<p><a href=\"http://backreference.org/2012/09/14/openvpn-ldap-authentication/\">http://backreference.org/2012/09/14/openvpn-ldap-authentication/</a></p>\n','OpenVPN配置LDAP认证','','inherit','open','open','','90-revision-3','','','2013-03-04 18:35:29','2013-03-04 10:35:29','','90','http://blog.wachang.net/2013/03/90-revision-3/','0','revision','','0');");
E_D("replace into `wp_posts` values('128','1','2013-03-03 14:57:51','2013-03-03 06:57:51','<p>在上一节中，将到了Fastcgi中的一些概念，这一节就实例展示下。以php环境为例：</p>\n\n<p>从上节中，我们明白了，php-cgi就是一个php的解释器，当服务器接收到一个php文件的时候，就会连接Fastcgi管理程序，连接的方式可以通过TCP连接（fastcgi管理程序监听一个端口）或者unix sock（通过文件读写的方式交互）两种方式，这个管理程序会执行php-cgi这个php解释器，从而得到结果。而这个fastcgi管理程序，就有php-fpm以及spawn-fcgi两个。</p>\n\n<h2>Php-cgi</h2>\n\n<p>实际上，php-cgi也可以作为一个fast-cgi管理程序，有如下参数：</p>\n\n<pre><code> sudo -u www-data PHP_FCGI_CHILDREN=5 PHP_FCGI_MAX_REQUESTS=125 /usr/bin/php-cgi -q -b 127.0.0.1:9000 &amp;\n</code></pre>\n\n<p>以上就表示启动了5个php-cgi进程，监听地址127.0.0.1:9000，服务器需要把php请求发到这个地址上。此时可以查看进程：</p>\n\n<pre><code>root@kb310-node10:~# ps -e|grep php-cgi\n3527 ?        00:00:00 php-cgi\n3529 ?        00:00:00 php-cgi\n3530 ?        00:00:00 php-cgi\n3531 ?        00:00:00 php-cgi\n3532 ?        00:00:00 php-cgi\n3533 ?        00:00:00 php-cgi\n</code></pre>\n\n<p>而相应的nginx关于php的配置就为：</p>\n\n<pre><code>location ~ .php\$ \n    { \n      fastcgi_pass 127.0.0.1:9000; \n      fastcgi_index index.php; \n      fastcgi_param SCRIPT_FILENAME \$document_root\$fastcgi_script_name; \n      include fastcgi_params; \n    }\n</code></pre>\n\n<p>php-cgi的缺点：</p>\n\n<ul>\n<li>php-cgi变更php.ini配置后需重启php-cgi才能让新的php-ini生效，不可以平滑重启</li>\n<li>直接杀死php-cgi进程,php就不能运行了。(PHP-FPM和Spawn-FCGI就没有这个问题,守护进程会平滑从新生成新的子进程。）</li>\n</ul>\n\n<h2>Php-FPM http://php-fpm.org/</h2>\n\n<p>php-fpm作为一个fasc-cgi管理程序，在CPU和内存方面的控制都比较好,用他来管理php-cgi，有很高的稳定性，如下安装：</p>\n\n<pre><code>apt-get install php5-fpm\n</code></pre>\n\n<p>然后在<code>/etc/php5/fpm</code>中进行配置，php-fpm.conf配置php-fpm的基本信息，这里可以更改<code>采用TCP或者UNIX SOCK</code>以及监视进程数的多少，<code>php.ini</code>是更改php配置，<code>pool.d</code>里面的东西是更改FPM的线程管理机制，一般用epoll，性能好。我自己采用的是UNIX SOCK监听：</p>\n\n<pre><code>##in php-fpm.ini\n[global]\n; Pid file\n; Note: the default prefix is /var\n; Default Value: none\n;pid = run/php-fpm.pid\npid = /var/run/php5-fpm.pid\n</code></pre>\n\n<p>启动并查看服务：</p>\n\n<pre><code>service php5-fpm restart\nroot@kb310-node10:/etc/php5/fpm# ps -e|grep php\n1738 ?        00:00:01 php5-fpm\n1739 ?        00:00:28 php5-fpm\n1740 ?        00:00:31 php5-fpm\n1741 ?        00:00:32 php5-fpm\n</code></pre>\n\n<p>相应nginx中就需要把<code>fastcgi_pass</code>参数更改为：</p>\n\n<pre><code>fastcgi_pass    unix:/var/run/php5-fpm.sock;\n</code></pre>\n\n<p>更多使用说明：</p>\n\n<pre><code>service php5-fpm {start|stop|quit|restart|reload|logrotate}\n--start 启动php的fastcgi进程\n--stop 强制终止php的fastcgi进程\n--quit 平滑终止php的fastcgi进程\n--restart 重启php的fastcgi进程\n--reload 重新平滑加载php的php.ini\n--logrotate 重新启用log文件\n</code></pre>\n\n<h2>Spawn-fcgi http://redmine.lighttpd.net/projects/spawn-fcgi</h2>\n\n<p>和PHP-FPM功能一样，要问他和php-fpm有什么区别，请看<a href=\"http://php-fpm.org/about/\">http://php-fpm.org/about/</a>，使用上：</p>\n\n<pre><code>spawn-fcgi -a 127.0.0.1 -p 9000 -C 10 -u www-data -f /usr/bin/php-cgi\n-f 指定调用FastCGI的进程的执行程序位置，根据系统上所装的PHP的情况具体设置\n-a 绑定到地址addr\n-p 绑定到端口port\n-s 绑定到unix socket的路径path\n-C 指定产生的FastCGI的进程数，默认为5(仅用于PHP)\n-P 指定产生的进程的PID文件路径\n-u和-g FastCGI使用什么身份(-u 用户 -g 用户组)运行，Ubuntu下可以使用www-data，其他的根据情况配置，如nobody、apache等\n</code></pre>\n\n<h2>参考文章：</h2>\n\n<p><a href=\"http://www.fastcgi.com/drupal/node/2\">FAST-CGI主页</a></p>\n\n<p><a href=\"http://www.mike.org.cn/articles/what-is-cgi-fastcgi-php-fpm-spawn-fcgi/\">http://www.mike.org.cn/articles/what-is-cgi-fastcgi-php-fpm-spawn-fcgi/</a></p>\n\n<p><a href=\"http://www.myhack58.com/Article/sort099/sort0102/2012/33364.htm\">http://www.myhack58.com/Article/sort099/sort0102/2012/33364.htm</a></p>\n\n<p><a href=\"http://wenku.baidu.com/view/1215375e3b3567ec102d8a67.html\">http://wenku.baidu.com/view/1215375e3b3567ec102d8a67.html</a></p>\n\n<p><a href=\"http://www.ayuelee.cn/fastcgi-spawn-fcgi-init-script.html\">http://www.ayuelee.cn/fastcgi-spawn-fcgi-init-script.html</a></p>\n\n<p><a href=\"http://hi.baidu.com/winsyk/item/7958e1313dbccdbd633aff8e\">http://hi.baidu.com/winsyk/item/7958e1313dbccdbd633aff8e</a></p>\n','CGI/FastCGI学习及实践-2-实践','','inherit','open','open','','81-revision-6','','','2013-03-03 14:57:51','2013-03-03 06:57:51','','81','http://blog.wachang.net/2013/03/81-revision-6/','0','revision','','0');");
E_D("replace into `wp_posts` values('129','1','2013-03-08 18:39:08','0000-00-00 00:00:00','\n','','','draft','open','open','','','','','2013-03-08 18:39:08','2013-03-08 10:39:08','','0','http://blog.wachang.net/?p=129','0','post','','0');");
E_D("replace into `wp_posts` values('130','1','2013-02-28 12:56:29','2013-02-28 04:56:29','<p>LetoDMS(http://www.letodms.com/)是一个免费开源的文档管理系统，适合小型企业或者组织用来做整个的文档管理。因为是我们实验室需要相应的文档管理服务，所以在Opendocman和LetoDMS中都适用了一下，总的来看，有一下特点：</p>\n\n<ul>\n<li>Opendocman:界面清爽，中文支持较好，不支持LDAP，使用上不太友好。</li>\n<li>LetoDMS:界面不是很好看，但是使用很上手，最重要的，支持LDAP。</li>\n</ul>\n\n<p>LetoDMS虽说支持LDAP，但是官网上木有配置文档，网上也没多少资料，自己折腾了好久，然后对着代码一步步Debug,才终于搞定，下面做一个记录。</p>\n\n<!--more-->\n\n<h2>LetoDMS中LDAP验证过程</h2>\n\n<p>在LetoDMS中，配置了LDAP以后，会用登陆的uid和密码去匹配LDAP服务器中DN下的uid和密码，成功后再与LetoDMS本地用户数据库进行匹配：1）如果本地LetoDMS中木有相应的用户信息，则根据CN名字信息和UID等创建用户，但不设置密码；2）如果已经有相应的用户信息，则允许登陆，相应的LDAP认证代码在<strong>/op/op.Login.php</strong>中。</p>\n\n<h2>LetoDMS中LDAP验证配置</h2>\n\n<p>在conf/settings.xml中配置LDAP信息，有两个地方:</p>\n\n<pre><code>&lt;authentication enableGuestLogin=\"false\" enablePasswordForgotten=\"false\" restricted=\"false\" enableUserImage=\"false\" disableSelfEdit=\"false\" passwordStrength=\"0\" passwordExpiration=\"0\" passwordHistory=\"0\" passwordStrengthAlgorithm=\"simple\" loginFailure=\"0\" encryptionKey=\"88401c30b26bdf44f0facbf62849cf1e\"&gt;\n</code></pre>\n\n<p>这里的restricted一定要设置为false。当然，这一个也可以通过admin登陆以后，在全局settings里设置。随后，设置LDAP信息：</p>\n\n<pre><code>&lt;connector enable=\"enable\" type=\"ldap\" host=\"ldap.oinlab.com\" port=\"389\" baseDN=\"ou=People,dc=oinlab\"&gt;\n</code></pre>\n\n<p>如果此时没效果，别急，编辑<code>inc/inc.ClassSettings.php</code>，再找到如下变量并设置好：</p>\n\n<pre><code>// LDAP\nvar \$_ldapHost = \"ldap.oinlab.com\"; // URIs are supported, e.g.: ldaps://ldap.host.com\nvar \$_ldapPort = 389; // Optional.\nvar \$_ldapBaseDN = \"ou=People,dc=oinlab\";\nvar \$_ldapAccountDomainName = \"oinlab\";\nvar \$_ldapType = 0; // 0 = ldap; 1 = AD\nvar \$_converters = array(); // list of commands used to convert files to text for Indexer\n</code></pre>\n\n<p>注意，实际上这个inc中的才是最基本的，这里面的变量值是通过读取<code>conf/setting.xml</code>中的值来的，当然，改了这里面的值得话settings.xml文件也无效了。最后，LetoDMS中相应的LDAP登陆代码位于<code>op/op.Login.php</code>中，有问题的话可以根据这里的代码做一些DEBUG.</p>\n','LetoDMS文档管理系统配置LDAP认证','','inherit','open','open','','33-revision-8','','','2013-02-28 12:56:29','2013-02-28 04:56:29','','33','http://blog.wachang.net/2013/02/33-revision-8/','0','revision','','0');");
E_D("replace into `wp_posts` values('131','1','2013-03-08 18:39:38','2013-03-08 10:39:38','<p>LetoDMS(http://www.letodms.com/)是一个免费开源的文档管理系统，适合小型企业或者组织用来做整个的文档管理。因为是我们实验室需要相应的文档管理服务，所以在Opendocman和LetoDMS中都适用了一下，总的来看，有一下特点：</p>\n\n<ul>\n<li>Opendocman:界面清爽，中文支持较好，不支持LDAP，使用上不太友好。</li>\n<li>LetoDMS:界面不是很好看，但是使用很上手，最重要的，支持LDAP。</li>\n</ul>\n\n<p>LetoDMS虽说支持LDAP，但是官网上木有配置文档，网上也没多少资料，自己折腾了好久，然后对着代码一步步Debug,才终于搞定，下面做一个记录。</p>\n\n<!--more-->\n\n<h2>LetoDMS中LDAP验证过程</h2>\n\n<p>在LetoDMS中，配置了LDAP以后，会用登陆的uid和密码去匹配LDAP服务器中DN下的uid和密码，成功后再与LetoDMS本地用户数据库进行匹配：1）如果本地LetoDMS中木有相应的用户信息，则根据CN名字信息和UID等创建用户，但不设置密码；2）如果已经有相应的用户信息，则允许登陆，相应的LDAP认证代码在<strong>/op/op.Login.php</strong>中。</p>\n\n<h2>LetoDMS中LDAP验证配置</h2>\n\n<p>在conf/settings.xml中配置LDAP信息，有两个地方:</p>\n\n<pre><code>#!xml\n&lt;authentication enableGuestLogin=\"false\" enablePasswordForgotten=\"false\" restricted=\"false\" enableUserImage=\"false\" disableSelfEdit=\"false\" passwordStrength=\"0\" passwordExpiration=\"0\" passwordHistory=\"0\" passwordStrengthAlgorithm=\"simple\" loginFailure=\"0\" encryptionKey=\"88401c30b26bdf44f0facbf62849cf1e\"&gt;\n</code></pre>\n\n<p>这里的restricted一定要设置为false。当然，这一个也可以通过admin登陆以后，在全局settings里设置。随后，设置LDAP信息：</p>\n\n<pre><code>&lt;connector enable=\"enable\" type=\"ldap\" host=\"ldap.oinlab.com\" port=\"389\" baseDN=\"ou=People,dc=oinlab\"&gt;\n</code></pre>\n\n<p>如果此时没效果，别急，编辑<code>inc/inc.ClassSettings.php</code>，再找到如下变量并设置好：</p>\n\n<pre><code>// LDAP\nvar \$_ldapHost = \"ldap.oinlab.com\"; // URIs are supported, e.g.: ldaps://ldap.host.com\nvar \$_ldapPort = 389; // Optional.\nvar \$_ldapBaseDN = \"ou=People,dc=oinlab\";\nvar \$_ldapAccountDomainName = \"oinlab\";\nvar \$_ldapType = 0; // 0 = ldap; 1 = AD\nvar \$_converters = array(); // list of commands used to convert files to text for Indexer\n</code></pre>\n\n<p>注意，实际上这个inc中的才是最基本的，这里面的变量值是通过读取<code>conf/setting.xml</code>中的值来的，当然，改了这里面的值得话settings.xml文件也无效了。最后，LetoDMS中相应的LDAP登陆代码位于<code>op/op.Login.php</code>中，有问题的话可以根据这里的代码做一些DEBUG.</p>\n','LetoDMS文档管理系统配置LDAP认证','','inherit','open','open','','33-revision-9','','','2013-03-08 18:39:38','2013-03-08 10:39:38','','33','http://blog.wachang.net/2013/03/33-revision-9/','0','revision','','0');");
E_D("replace into `wp_posts` values('132','1','2013-03-08 18:40:35','2013-03-08 10:40:35','<p>LetoDMS(http://www.letodms.com/)是一个免费开源的文档管理系统，适合小型企业或者组织用来做整个的文档管理。因为是我们实验室需要相应的文档管理服务，所以在Opendocman和LetoDMS中都适用了一下，总的来看，有一下特点：</p>\n\n<ul>\n<li>Opendocman:界面清爽，中文支持较好，不支持LDAP，使用上不太友好。</li>\n<li>LetoDMS:界面不是很好看，但是使用很上手，最重要的，支持LDAP。</li>\n</ul>\n\n<p>LetoDMS虽说支持LDAP，但是官网上木有配置文档，网上也没多少资料，自己折腾了好久，然后对着代码一步步Debug,才终于搞定，下面做一个记录。</p>\n\n<!--more-->\n\n<h2>LetoDMS中LDAP验证过程</h2>\n\n<p>在LetoDMS中，配置了LDAP以后，会用登陆的uid和密码去匹配LDAP服务器中DN下的uid和密码，成功后再与LetoDMS本地用户数据库进行匹配：1）如果本地LetoDMS中木有相应的用户信息，则根据CN名字信息和UID等创建用户，但不设置密码；2）如果已经有相应的用户信息，则允许登陆，相应的LDAP认证代码在<strong>/op/op.Login.php</strong>中。</p>\n\n<h2>LetoDMS中LDAP验证配置</h2>\n\n<p>在conf/settings.xml中配置LDAP信息，有两个地方:</p>\n\n<pre><code>&lt;authentication enableGuestLogin=\"false\" enablePasswordForgotten=\"false\" restricted=\"false\" enableUserImage=\"false\" disableSelfEdit=\"false\" passwordStrength=\"0\" passwordExpiration=\"0\" passwordHistory=\"0\" passwordStrengthAlgorithm=\"simple\" loginFailure=\"0\" encryptionKey=\"88401c30b26bdf44f0facbf62849cf1e\"&gt;\n</code></pre>\n\n<p>这里的restricted一定要设置为false。当然，这一个也可以通过admin登陆以后，在全局settings里设置。随后，设置LDAP信息：</p>\n\n<pre><code>&lt;connector enable=\"enable\" type=\"ldap\" host=\"ldap.oinlab.com\" port=\"389\" baseDN=\"ou=People,dc=oinlab\"&gt;\n</code></pre>\n\n<p>如果此时没效果，别急，编辑<code>inc/inc.ClassSettings.php</code>，再找到如下变量并设置好：</p>\n\n<pre><code>// LDAP\nvar \$_ldapHost = \"ldap.oinlab.com\"; // URIs are supported, e.g.: ldaps://ldap.host.com\nvar \$_ldapPort = 389; // Optional.\nvar \$_ldapBaseDN = \"ou=People,dc=oinlab\";\nvar \$_ldapAccountDomainName = \"oinlab\";\nvar \$_ldapType = 0; // 0 = ldap; 1 = AD\nvar \$_converters = array(); // list of commands used to convert files to text for Indexer\n</code></pre>\n\n<p>注意，实际上这个inc中的才是最基本的，这里面的变量值是通过读取<code>conf/setting.xml</code>中的值来的，当然，改了这里面的值得话settings.xml文件也无效了。最后，LetoDMS中相应的LDAP登陆代码位于<code>op/op.Login.php</code>中，有问题的话可以根据这里的代码做一些DEBUG.</p>\n','LetoDMS文档管理系统配置LDAP认证','','inherit','open','open','','33-revision-10','','','2013-03-08 18:40:35','2013-03-08 10:40:35','','33','http://blog.wachang.net/2013/03/33-revision-10/','0','revision','','0');");
E_D("replace into `wp_posts` values('133','1','2013-03-09 23:53:40','2013-03-09 15:53:40','<p>上一节说到了，iptables的一些基本概念以及工作流程，下面我们来看看iptables具体该如何使用。</p>\n\n<p>本系列文章索引：</p>\n\n<p>第一章：<a href=\"http://blog.wachang.net/2013/03/iptables-usage-ref-1/\">流程介绍</a></p>\n\n<p>第二章：<a href=\"http://blog.wachang.net/2013/03/iptables-useage-ref-2/\">如何使用</a></p>\n\n<p>第三章：深入理解</p>\n\n<p>第四章：高级用法</p>\n\n<h2>1 规则语法：</h2>\n\n<h3>1.1 查看规则</h3>\n\n<pre><code>iptables [-t 表名] &lt;-L&gt; [链名]\n</code></pre>\n\n<p>注：不指定表名的话默认查看filter表</p>\n\n<h3>1.2 增加(追加，append)、插入、替换规则</h3>\n\n<pre><code>iptables [-t 表名] &lt;-A(追加) | -I(插入)&gt; | -D(删除) | -R(替换)&gt; &lt;链名&gt; [规则编号] [-i|o 进入或流出网卡名称] [-p 协议类型] [-s 源IP地址|源子网] [--sport 源端口号] [-d 目标ip地址|目标子网] [--dport 目标端口号] &lt;-j 动作(accept|drop|nat等)&gt; \n</code></pre>\n\n<p><!--more-->\n注：不指定表名的话默认使用filter表</p>\n\n<p><strong><code>-I</code>插入规则如果不指明规则标号，则在第一条规则前插入（置顶）</strong></p>\n\n<p><strong><code>-R</code>替换规则一定要指明规则编号，替换后不会改变规则顺序。</strong></p>\n\n<p><strong><code>-p</code>可是是ssh、tcp、icmp等,如下几个针对协议的匹配都是OK的</strong></p>\n\n<pre><code>-p icmp --icmp-type 类型\n-p --tcp-flags SYN,ACK,FIN,PSH,RST,URG\n</code></pre>\n\n<p><strong>关于<code>port</code>，以下都是可以的：</strong></p>\n\n<pre><code>--sport 1000:3000 匹配源端口是 1000-3000 的数据包(含1000、3000)\n--dport :3000 匹配目标端口是 3000 以下的数据包(含 3000)\n--dport 1000: 匹配目标端口是 1000 以上的数据包(含 1000\n--sport 和 --dport 必须配合 -p 参数使用，指定是神马协议\n</code></pre>\n\n<p><strong>关于动作，有以下一些动作：</strong></p>\n\n<ul>\n<li><p>ACCEPT 将封包放行，进行完此处理动作后，将不再比对其它规则，直接跳往下一个规则链（natostrouting）。</p></li>\n<li><p>DROP 丢弃封包不予处理，进行完此处理动作后，将不再比对其它规则，直接中断过滤程序。</p></li>\n<li><p>REJECT 拦阻该封包，并传送封包通知对方，可以传送的封包有几个选择：ICMP port-unreachable、ICMP echo-reply 或是 tcp-reset（这个封包会要求对方关闭联机），进行完此处理动作后，将不再比对其它规则，直接中断过滤程序。</p>\n\n<p>iptables -A FORWARD -p TCP --dport 22 -j REJECT --reject-with tcp-reset</p></li>\n<li><p>SNAT 改写封包来源 IP 为某特定 IP 或 IP 范围，可以指定 port 对应的范围，进行完此处理动作后，将直接跳往下一个规则（mangleostrouting）。</p>\n\n<p>iptables -t nat -A POSTROUTING -p tcp-o eth0 -j SNAT --to-source 194.236.50.155-194.236.50.160:1024-32000</p></li>\n<li><p>DNAT 改写封包目的地 IP 为某特定 IP 或 IP 范围，可以指定 port 对应的范围，进行完此处理动作后，将会直接跳往下一个规炼（filter:input 或 filter:forward）。</p>\n\n<p>iptables -t nat -A PREROUTING -p tcp -d 15.45.23.67 --dport 80 -j DNAT --to-destination 192.168.1.1-192.168.1.10:80-100</p></li>\n<li><p>MASQUERADE 改写封包来源 IP 为防火墙 NIC IP，可以指定 port 对应的范围，进行完此处理动作后，直接跳往下一个规则（mangleostrouting）。这个功能与 SNAT 略有不同，当进行 IP 伪装时，不需指定要伪装成哪个 IP，IP 会从网卡直接读，当使用拨接连线时，IP 通常是由 ISP 公司的 DHCP 服务器指派的，这个时候 MASQUERADE 特别有用。</p>\n\n<p>iptables -t nat -A POSTROUTING -p TCP -j MASQUERADE --to-ports 1024-31000</p></li>\n<li><p>REDIRECT 将封包重新导向到另一个端口（PNAT），进行完此处理动作后，将会继续比对其它规则。</p>\n\n<p>iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080</p></li>\n<li><p>MIRROR 镜射封包，也就是将来源 IP 与目的地 IP 对调后，将封包送回，进行完此处理动作后，将会中断过滤程序。</p></li>\n<li><p>QUEUE 中断过滤程序，将封包放入队列，交给其它程序处理。透过自行开发的处理程序，可以进行其它应用，</p></li>\n<li><p>MARK 将封包标上某个代号，以便提供作为后续过滤的条件判断依据，进行完此处理动作后，将会继续比对其它规则。</p>\n\n<p>iptables -t mangle -A PREROUTING -p tcp --dport 22 -j MARK --set-mark 2</p></li>\n<li><p>RETURN结束在目前规则炼中的过滤程序，返回主规则炼继续过滤，如果把自订规则炼看成是一个子程序，那么这个动作，就相当提早结束子程序并返回到主程序中。</p></li>\n<li><p>LOG 将封包相关讯息纪录在 /var/log 中，详细位置请查阅 /etc/syslog.conf 组态档，进行完此处理动作后，将会继续比对其规则。</p>\n\n<p>iptables -A INPUT -p tcp -j LOG --log-prefix \"INPUT packets\"</p></li>\n</ul>\n\n<p>关于动作的使用，继续往下来:)！</p>\n\n<p>然后还有一点，一般我们都会考虑到，当数据包没有规则匹配是应该肿么办，是的，这个时候还有一个默认规则，通常叫做默认策略，<code>当数据包不被任何规则匹配时，会采用默认规则</code></p>\n\n<pre><code>iptables [-t 表名] &lt;-P&gt; &lt;链名&gt; &lt;动作&gt;\n</code></pre>\n\n<p>这里动作就不加-j了，因为-j表示匹配到以后执行的动作。</p>\n\n<p>然后，我们再继续一点，当规则很多的时候，我们不可能一条一条的删除呗，所以还有以下：</p>\n\n<pre><code>iptables [-t 表名] [链名] &lt;-F|Z&gt;\n</code></pre>\n\n<p>还是一样，不指定表名默认操作filter表，这里Z表示计数器和流量归0，现在我们暂时不管他。关于删除，还得多说一点：</p>\n\n<ul>\n<li><p>1 <code>-F 仅仅是清空链中规则，并不影响 -P 设置的默认规则</code></p></li>\n<li><p>2 -P(默认策略)设置了 DROP 后，使用 -F 一定要小心，不然你网络就断了。</p></li>\n<li><p>3 如果不写链名，默认清空某表里所有链里的所有规则</p></li>\n</ul>\n\n<p>iptables的规则在重启后就会失效，所以还需要保存和载入：</p>\n\n<pre><code>iptables-save &gt; /xx/iptables.save\niptables-restore &lt; /xx/iptables.save\n</code></pre>\n\n<h2>2 iptables的应用</h2>\n\n<p>iptables的动作设置，其实就属于iptables的应用了。我们来看看：</p>\n\n<h3>2.1 增加安全性</h3>\n\n<pre><code>iptables -P INPUT DROP\niptables -p OUTPUT DROP\n</code></pre>\n\n<p>体会一下默认策略的作用，你就懂了。</p>\n\n<h3>2.2 NAT</h3>\n\n<p>做SNAT，允许内部的机器访问外部网络，这需要在出去的时候操作POSTROUTING链，SNAT 支持转换为单 IP，也支持转换到 IP 地址池。</p>\n\n<pre><code>-j SNAT --to IP[-IP][:端口-端口]\niptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eht0 -j SNAT --to 1.1.1.1\niptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j SNAT --to 1.1.1.1-1.1.1.1\n</code></pre>\n\n<p>做DNAT，主要是使外部的流量能够访问到内部的网络，类似DMZ功能，这需要在数据包进入的时候操作PREROUTING链目的地址转换，DNAT 支持转换为单 IP，也支持转换到 IP 地址池</p>\n\n<pre><code>-j DNAT --to IP[-IP][:端口-端口]\niptables -t nat -A PREROUTING -i ppp0 -p tcp --dport 80 -j DNAT --to 192.168.0.1:80\niptables -t nat -A PREROUTING -i ppp0 -p tcp --dport 80 -j DNAT --to 192.168.0.1-192.168.0.10\n</code></pre>\n\n<h3>2.3 MASQUERADE</h3>\n\n<p>地址转换，动态源地址转换(动态 IP 的情况下使用)，主要还是NAT上使用</p>\n\n<pre><code>iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE\n</code></pre>\n\n<p>将源地址是 192.168.0.0/24 的数据包进行地址伪装,这是一个SNAT。</p>\n\n<h3>2.4 防火墙</h3>\n\n<p>防火墙嘛，主要就是过滤，当然是用到filter表了。</p>\n\n<pre><code>iptables -A INPUT -p tcp --dport 22 -j ACCEPT\niptables -A OUTPUT -p udp --sport 22 -j ACCEPT\n</code></pre>\n\n<h3>2.5 转发</h3>\n\n<p>如果机器具有网关的作用，那么就一定要能转发数据包，可以通过FPRWARD控制分组转发到LAN上的哪些地方，比如一个机器，两个网卡，eth0接外部网络，eth1接内部网络，并且网关作用，就要允许eth1上转发</p>\n\n<pre><code>iptables -A FORWARD -i eth1 -j ACCEPT\niptables -A FORWARD -o eth1 -j ACCEPT\n</code></pre>\n\n<p>经过以上学习，常用的iptables的功能都差不多了，其实看到这里，也就可以勒，如果你还想玩的炫一点，那就接着看下一篇。</p>\n\n<h2>3 参考资料</h2>\n\n<p><a href=\"http://man.chinaunix.net/network/iptables-tutorial-cn-1.1.19.html\">http://man.chinaunix.net/network/iptables-tutorial-cn-1.1.19.html</a></p>\n\n<p><a href=\"http://www.lampbo.org/linux-xuexi/linux-advance/iptables-options.html\">http://www.lampbo.org/linux-xuexi/linux-advance/iptables-options.html</a></p>\n\n<p><a href=\"http://tech.anquan365.com/application/other/201201/167224.html\">http://tech.anquan365.com/application/other/201201/167224.html</a></p>\n\n<p>推荐<a href=\"http://www.cnblogs.com/diyunpeng/archive/2012/05/10/2493749.html\">http://www.cnblogs.com/diyunpeng/archive/2012/05/10/2493749.html</a></p>\n\n<p>推荐<a href=\"http://blog.163.com/xychenbaihu@yeah/blog/static/132229655201212705752493/\">http://blog.163.com/xychenbaihu@yeah/blog/static/132229655201212705752493/</a></p>\n\n<p>一个实战经验，我没看：<a href=\"http://blog.sina.com.cn/s/blog_67a6c6f10100k3yx.html\">http://blog.sina.com.cn/s/blog_67a6c6f10100k3yx.html</a></p>\n','Iptables使用参考手册(二)','','publish','open','open','','iptables-useage-ref-2','','','2013-03-09 23:55:16','2013-03-09 15:55:16','','0','http://blog.wachang.net/?p=133','0','post','','0');");
E_D("replace into `wp_posts` values('134','1','2013-03-09 23:52:24','2013-03-09 15:52:24','<p>上一节说到了，iptables的一些基本概念以及工作流程，下面我们来看看iptables具体该如何使用。</p>\n\n<p>本系列文章索引：</p>\n\n<p>第一章：<a href=\"http://blog.wachang.net/2013/03/iptables-usage-ref-1/\">流程介绍</a></p>\n\n<p>第二章：<a href=\"http://blog.wachang.net/2013/03/iptables-useage-ref-2/\">如何使用</a></p>\n\n<p>第三章：深入理解</p>\n\n<p>第四章：高级用法</p>\n\n<h2>1 规则语法：</h2>\n\n<h3>1.1 查看规则</h3>\n\n<pre><code>iptables [-t 表名] &lt;-L&gt; [链名]\n</code></pre>\n\n<p>注：不指定表名的话默认查看filter表</p>\n\n<h3>1.2 增加(追加，append)、插入、替换规则</h3>\n\n<pre><code>iptables [-t 表名] &lt;-A(追加) | -I(插入)&gt; | -D(删除) | -R(替换)&gt; &lt;链名&gt; [规则编号] [-i|o 进入或流出网卡名称] [-p 协议类型] [-s 源IP地址|源子网] [--sport 源端口号] [-d 目标ip地址|目标子网] [--dport 目标端口号] &lt;-j 动作(accept|drop|nat等)&gt; \n</code></pre>\n\n<p>注：不指定表名的话默认使用filter表</p>\n\n<p><strong><code>-I</code>插入规则如果不指明规则标号，则在第一条规则前插入（置顶）</strong></p>\n\n<p><strong><code>-R</code>替换规则一定要指明规则编号，替换后不会改变规则顺序。</strong></p>\n\n<p><strong><code>-p</code>可是是ssh、tcp、icmp等,如下几个针对协议的匹配都是OK的</strong></p>\n\n<pre><code>-p icmp --icmp-type 类型\n-p --tcp-flags SYN,ACK,FIN,PSH,RST,URG\n</code></pre>\n\n<p><strong>关于<code>port</code>，以下都是可以的：</strong></p>\n\n<pre><code>--sport 1000:3000 匹配源端口是 1000-3000 的数据包(含1000、3000)\n--dport :3000 匹配目标端口是 3000 以下的数据包(含 3000)\n--dport 1000: 匹配目标端口是 1000 以上的数据包(含 1000\n--sport 和 --dport 必须配合 -p 参数使用，指定是神马协议\n</code></pre>\n\n<p><strong>关于动作，有以下一些动作：</strong></p>\n\n<ul>\n<li><p>ACCEPT 将封包放行，进行完此处理动作后，将不再比对其它规则，直接跳往下一个规则链（natostrouting）。</p></li>\n<li><p>DROP 丢弃封包不予处理，进行完此处理动作后，将不再比对其它规则，直接中断过滤程序。</p></li>\n<li><p>REJECT 拦阻该封包，并传送封包通知对方，可以传送的封包有几个选择：ICMP port-unreachable、ICMP echo-reply 或是 tcp-reset（这个封包会要求对方关闭联机），进行完此处理动作后，将不再比对其它规则，直接中断过滤程序。</p>\n\n<p>iptables -A FORWARD -p TCP --dport 22 -j REJECT --reject-with tcp-reset</p></li>\n<li><p>SNAT 改写封包来源 IP 为某特定 IP 或 IP 范围，可以指定 port 对应的范围，进行完此处理动作后，将直接跳往下一个规则（mangleostrouting）。</p>\n\n<p>iptables -t nat -A POSTROUTING -p tcp-o eth0 -j SNAT --to-source 194.236.50.155-194.236.50.160:1024-32000</p></li>\n<li><p>DNAT  改写封包目的地 IP 为某特定 IP 或 IP 范围，可以指定 port 对应的范围，进行完此处理动作后，将会直接跳往下一个规炼（filter:input 或 filter:forward）。</p>\n\n<p>iptables -t nat -A PREROUTING -p tcp -d 15.45.23.67 --dport 80 -j DNAT --to-destination 192.168.1.1-192.168.1.10:80-100</p></li>\n<li><p>MASQUERADE 改写封包来源 IP 为防火墙 NIC IP，可以指定 port 对应的范围，进行完此处理动作后，直接跳往下一个规则（mangleostrouting）。这个功能与 SNAT 略有不同，当进行 IP 伪装时，不需指定要伪装成哪个 IP，IP 会从网卡直接读，当使用拨接连线时，IP 通常是由 ISP 公司的 DHCP 服务器指派的，这个时候 MASQUERADE 特别有用。</p>\n\n<p>iptables -t nat -A POSTROUTING -p TCP -j MASQUERADE --to-ports 1024-31000</p></li>\n<li><p>REDIRECT 将封包重新导向到另一个端口（PNAT），进行完此处理动作后，将会继续比对其它规则。</p>\n\n<p>iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080</p></li>\n<li><p>MIRROR 镜射封包，也就是将来源 IP 与目的地 IP 对调后，将封包送回，进行完此处理动作后，将会中断过滤程序。</p></li>\n<li><p>QUEUE 中断过滤程序，将封包放入队列，交给其它程序处理。透过自行开发的处理程序，可以进行其它应用，</p></li>\n<li><p>MARK 将封包标上某个代号，以便提供作为后续过滤的条件判断依据，进行完此处理动作后，将会继续比对其它规则。</p>\n\n<p>iptables -t mangle -A PREROUTING -p tcp --dport 22 -j MARK --set-mark 2</p></li>\n<li><p>RETURN结束在目前规则炼中的过滤程序，返回主规则炼继续过滤，如果把自订规则炼看成是一个子程序，那么这个动作，就相当提早结束子程序并返回到主程序中。</p></li>\n<li><p>LOG 将封包相关讯息纪录在 /var/log 中，详细位置请查阅 /etc/syslog.conf 组态档，进行完此处理动作后，将会继续比对其规则。</p>\n\n<p>iptables -A INPUT -p tcp -j LOG --log-prefix \"INPUT packets\"</p></li>\n</ul>\n\n<p>关于动作的使用，继续往下来:)！</p>\n\n<p>然后还有一点，一般我们都会考虑到，当数据包没有规则匹配是应该肿么办，是的，这个时候还有一个默认规则，通常叫做默认策略，<code>当数据包不被任何规则匹配时，会采用默认规则</code></p>\n\n<pre><code>iptables [-t 表名] &lt;-P&gt; &lt;链名&gt; &lt;动作&gt;\n</code></pre>\n\n<p>这里动作就不加-j了，因为-j表示匹配到以后执行的动作。</p>\n\n<p>然后，我们再继续一点，当规则很多的时候，我们不可能一条一条的删除呗，所以还有以下：</p>\n\n<pre><code>iptables [-t 表名] [链名] &lt;-F|Z&gt;\n</code></pre>\n\n<p>还是一样，不指定表名默认操作filter表，这里Z表示计数器和流量归0，现在我们暂时不管他。关于删除，还得多说一点：</p>\n\n<ul>\n<li><p>1 <code>-F 仅仅是清空链中规则，并不影响 -P 设置的默认规则</code></p></li>\n<li><p>2 -P(默认策略)设置了 DROP 后，使用 -F 一定要小心，不然你网络就断了。</p></li>\n<li><p>3 如果不写链名，默认清空某表里所有链里的所有规则</p></li>\n</ul>\n\n<p>iptables的规则在重启后就会失效，所以还需要保存和载入：</p>\n\n<pre><code>iptables-save &gt; /xx/iptables.save\niptables-restore &lt; /xx/iptables.save\n</code></pre>\n\n<h2>2 iptables的应用</h2>\n\n<p>iptables的动作设置，其实就属于iptables的应用了。我们来看看：</p>\n\n<h3>2.1 增加安全性</h3>\n\n<pre><code>iptables -P INPUT DROP\niptables -p OUTPUT DROP\n</code></pre>\n\n<p>体会一下默认策略的作用，你就懂了。</p>\n\n<h3>2.2 NAT</h3>\n\n<p>做SNAT，允许内部的机器访问外部网络，这需要在出去的时候操作POSTROUTING链，SNAT 支持转换为单 IP，也支持转换到 IP 地址池。</p>\n\n<pre><code>-j SNAT --to IP[-IP][:端口-端口]\niptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eht0 -j SNAT --to 1.1.1.1\niptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j SNAT --to 1.1.1.1-1.1.1.1\n</code></pre>\n\n<p>做DNAT，主要是使外部的流量能够访问到内部的网络，类似DMZ功能，这需要在数据包进入的时候操作PREROUTING链目的地址转换，DNAT 支持转换为单 IP，也支持转换到 IP 地址池</p>\n\n<pre><code>-j DNAT --to IP[-IP][:端口-端口]\niptables -t nat -A PREROUTING -i ppp0 -p tcp --dport 80 -j DNAT --to 192.168.0.1:80\niptables -t nat -A PREROUTING -i ppp0 -p tcp --dport 80 -j DNAT --to 192.168.0.1-192.168.0.10\n</code></pre>\n\n<h3>2.3 MASQUERADE</h3>\n\n<p>地址转换，动态源地址转换(动态 IP 的情况下使用)，主要还是NAT上使用</p>\n\n<pre><code>iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE\n</code></pre>\n\n<p>将源地址是 192.168.0.0/24 的数据包进行地址伪装,这是一个SNAT。</p>\n\n<h3>2.4 防火墙</h3>\n\n<p>防火墙嘛，主要就是过滤，当然是用到filter表了。</p>\n\n<pre><code>iptables -A INPUT -p tcp --dport 22 -j ACCEPT\niptables -A OUTPUT -p udp --sport 22 -j ACCEPT\n</code></pre>\n\n<h3>2.5 转发</h3>\n\n<p>如果机器具有网关的作用，那么就一定要能转发数据包，可以通过FPRWARD控制分组转发到LAN上的哪些地方，比如一个机器，两个网卡，eth0接外部网络，eth1接内部网络，并且网关作用，就要允许eth1上转发</p>\n\n<pre><code>iptables -A FORWARD -i eth1 -j ACCEPT\niptables -A FORWARD -o eth1 -j ACCEPT\n</code></pre>\n\n<p>经过以上学习，常用的iptables的功能都差不多了，其实看到这里，也就可以勒，如果你还想玩的炫一点，那就接着看下一篇。</p>\n\n<h2>3 参考资料</h2>\n\n<p><a href=\"http://man.chinaunix.net/network/iptables-tutorial-cn-1.1.19.html\">http://man.chinaunix.net/network/iptables-tutorial-cn-1.1.19.html</a></p>\n\n<p><a href=\"http://www.lampbo.org/linux-xuexi/linux-advance/iptables-options.html\">http://www.lampbo.org/linux-xuexi/linux-advance/iptables-options.html</a></p>\n\n<p><a href=\"http://tech.anquan365.com/application/other/201201/167224.html\">http://tech.anquan365.com/application/other/201201/167224.html</a></p>\n\n<p>推荐<a href=\"http://www.cnblogs.com/diyunpeng/archive/2012/05/10/2493749.html\">http://www.cnblogs.com/diyunpeng/archive/2012/05/10/2493749.html</a></p>\n\n<p>推荐<a href=\"http://blog.163.com/xychenbaihu@yeah/blog/static/132229655201212705752493/\">http://blog.163.com/xychenbaihu@yeah/blog/static/132229655201212705752493/</a></p>\n\n<p>一个实战经验，我没看：<a href=\"http://blog.sina.com.cn/s/blog_67a6c6f10100k3yx.html\">http://blog.sina.com.cn/s/blog_67a6c6f10100k3yx.html</a></p>\n','Iptables使用参考手册(二)','','inherit','open','open','','133-revision','','','2013-03-09 23:52:24','2013-03-09 15:52:24','','133','http://blog.wachang.net/2013/03/133-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('135','1','2013-03-09 23:53:40','2013-03-09 15:53:40','<p>上一节说到了，iptables的一些基本概念以及工作流程，下面我们来看看iptables具体该如何使用。</p>\n\n<p>本系列文章索引：</p>\n\n<p>第一章：<a href=\"http://blog.wachang.net/2013/03/iptables-usage-ref-1/\">流程介绍</a></p>\n\n<p>第二章：<a href=\"http://blog.wachang.net/2013/03/iptables-useage-ref-2/\">如何使用</a></p>\n\n<p>第三章：深入理解</p>\n\n<p>第四章：高级用法</p>\n\n<h2>1 规则语法：</h2>\n\n<h3>1.1 查看规则</h3>\n\n<pre><code>iptables [-t 表名] &lt;-L&gt; [链名]\n</code></pre>\n\n<p>注：不指定表名的话默认查看filter表</p>\n\n<h3>1.2 增加(追加，append)、插入、替换规则</h3>\n\n<pre><code>iptables [-t 表名] &lt;-A(追加) | -I(插入)&gt; | -D(删除) | -R(替换)&gt; &lt;链名&gt; [规则编号] [-i|o 进入或流出网卡名称] [-p 协议类型] [-s 源IP地址|源子网] [--sport 源端口号] [-d 目标ip地址|目标子网] [--dport 目标端口号] &lt;-j 动作(accept|drop|nat等)&gt; \n</code></pre>\n\n<p>注：不指定表名的话默认使用filter表</p>\n\n<p><strong><code>-I</code>插入规则如果不指明规则标号，则在第一条规则前插入（置顶）</strong></p>\n\n<p><strong><code>-R</code>替换规则一定要指明规则编号，替换后不会改变规则顺序。</strong></p>\n\n<p><strong><code>-p</code>可是是ssh、tcp、icmp等,如下几个针对协议的匹配都是OK的</strong></p>\n\n<pre><code>-p icmp --icmp-type 类型\n-p --tcp-flags SYN,ACK,FIN,PSH,RST,URG\n</code></pre>\n\n<p><strong>关于<code>port</code>，以下都是可以的：</strong></p>\n\n<pre><code>--sport 1000:3000 匹配源端口是 1000-3000 的数据包(含1000、3000)\n--dport :3000 匹配目标端口是 3000 以下的数据包(含 3000)\n--dport 1000: 匹配目标端口是 1000 以上的数据包(含 1000\n--sport 和 --dport 必须配合 -p 参数使用，指定是神马协议\n</code></pre>\n\n<p><strong>关于动作，有以下一些动作：</strong></p>\n\n<ul>\n<li><p>ACCEPT 将封包放行，进行完此处理动作后，将不再比对其它规则，直接跳往下一个规则链（natostrouting）。</p></li>\n<li><p>DROP 丢弃封包不予处理，进行完此处理动作后，将不再比对其它规则，直接中断过滤程序。</p></li>\n<li><p>REJECT 拦阻该封包，并传送封包通知对方，可以传送的封包有几个选择：ICMP port-unreachable、ICMP echo-reply 或是 tcp-reset（这个封包会要求对方关闭联机），进行完此处理动作后，将不再比对其它规则，直接中断过滤程序。</p>\n\n<p>iptables -A FORWARD -p TCP --dport 22 -j REJECT --reject-with tcp-reset</p></li>\n<li><p>SNAT 改写封包来源 IP 为某特定 IP 或 IP 范围，可以指定 port 对应的范围，进行完此处理动作后，将直接跳往下一个规则（mangleostrouting）。</p>\n\n<p>iptables -t nat -A POSTROUTING -p tcp-o eth0 -j SNAT --to-source 194.236.50.155-194.236.50.160:1024-32000</p></li>\n<li><p>DNAT  改写封包目的地 IP 为某特定 IP 或 IP 范围，可以指定 port 对应的范围，进行完此处理动作后，将会直接跳往下一个规炼（filter:input 或 filter:forward）。</p>\n\n<p>iptables -t nat -A PREROUTING -p tcp -d 15.45.23.67 --dport 80 -j DNAT --to-destination 192.168.1.1-192.168.1.10:80-100</p></li>\n<li><p>MASQUERADE 改写封包来源 IP 为防火墙 NIC IP，可以指定 port 对应的范围，进行完此处理动作后，直接跳往下一个规则（mangleostrouting）。这个功能与 SNAT 略有不同，当进行 IP 伪装时，不需指定要伪装成哪个 IP，IP 会从网卡直接读，当使用拨接连线时，IP 通常是由 ISP 公司的 DHCP 服务器指派的，这个时候 MASQUERADE 特别有用。</p>\n\n<p>iptables -t nat -A POSTROUTING -p TCP -j MASQUERADE --to-ports 1024-31000</p></li>\n<li><p>REDIRECT 将封包重新导向到另一个端口（PNAT），进行完此处理动作后，将会继续比对其它规则。</p>\n\n<p>iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080</p></li>\n<li><p>MIRROR 镜射封包，也就是将来源 IP 与目的地 IP 对调后，将封包送回，进行完此处理动作后，将会中断过滤程序。</p></li>\n<li><p>QUEUE 中断过滤程序，将封包放入队列，交给其它程序处理。透过自行开发的处理程序，可以进行其它应用，</p></li>\n<li><p>MARK 将封包标上某个代号，以便提供作为后续过滤的条件判断依据，进行完此处理动作后，将会继续比对其它规则。</p>\n\n<p>iptables -t mangle -A PREROUTING -p tcp --dport 22 -j MARK --set-mark 2</p></li>\n<li><p>RETURN结束在目前规则炼中的过滤程序，返回主规则炼继续过滤，如果把自订规则炼看成是一个子程序，那么这个动作，就相当提早结束子程序并返回到主程序中。</p></li>\n<li><p>LOG 将封包相关讯息纪录在 /var/log 中，详细位置请查阅 /etc/syslog.conf 组态档，进行完此处理动作后，将会继续比对其规则。</p>\n\n<p>iptables -A INPUT -p tcp -j LOG --log-prefix \"INPUT packets\"</p></li>\n</ul>\n\n<p>关于动作的使用，继续往下来:)！</p>\n\n<p>然后还有一点，一般我们都会考虑到，当数据包没有规则匹配是应该肿么办，是的，这个时候还有一个默认规则，通常叫做默认策略，<code>当数据包不被任何规则匹配时，会采用默认规则</code></p>\n\n<pre><code>iptables [-t 表名] &lt;-P&gt; &lt;链名&gt; &lt;动作&gt;\n</code></pre>\n\n<p>这里动作就不加-j了，因为-j表示匹配到以后执行的动作。</p>\n\n<p>然后，我们再继续一点，当规则很多的时候，我们不可能一条一条的删除呗，所以还有以下：</p>\n\n<pre><code>iptables [-t 表名] [链名] &lt;-F|Z&gt;\n</code></pre>\n\n<p>还是一样，不指定表名默认操作filter表，这里Z表示计数器和流量归0，现在我们暂时不管他。关于删除，还得多说一点：</p>\n\n<ul>\n<li><p>1 <code>-F 仅仅是清空链中规则，并不影响 -P 设置的默认规则</code></p></li>\n<li><p>2 -P(默认策略)设置了 DROP 后，使用 -F 一定要小心，不然你网络就断了。</p></li>\n<li><p>3 如果不写链名，默认清空某表里所有链里的所有规则</p></li>\n</ul>\n\n<p>iptables的规则在重启后就会失效，所以还需要保存和载入：</p>\n\n<pre><code>iptables-save &gt; /xx/iptables.save\niptables-restore &lt; /xx/iptables.save\n</code></pre>\n\n<h2>2 iptables的应用</h2>\n\n<p>iptables的动作设置，其实就属于iptables的应用了。我们来看看：</p>\n\n<h3>2.1 增加安全性</h3>\n\n<pre><code>iptables -P INPUT DROP\niptables -p OUTPUT DROP\n</code></pre>\n\n<p>体会一下默认策略的作用，你就懂了。</p>\n\n<h3>2.2 NAT</h3>\n\n<p>做SNAT，允许内部的机器访问外部网络，这需要在出去的时候操作POSTROUTING链，SNAT 支持转换为单 IP，也支持转换到 IP 地址池。</p>\n\n<pre><code>-j SNAT --to IP[-IP][:端口-端口]\niptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eht0 -j SNAT --to 1.1.1.1\niptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j SNAT --to 1.1.1.1-1.1.1.1\n</code></pre>\n\n<p>做DNAT，主要是使外部的流量能够访问到内部的网络，类似DMZ功能，这需要在数据包进入的时候操作PREROUTING链目的地址转换，DNAT 支持转换为单 IP，也支持转换到 IP 地址池</p>\n\n<pre><code>-j DNAT --to IP[-IP][:端口-端口]\niptables -t nat -A PREROUTING -i ppp0 -p tcp --dport 80 -j DNAT --to 192.168.0.1:80\niptables -t nat -A PREROUTING -i ppp0 -p tcp --dport 80 -j DNAT --to 192.168.0.1-192.168.0.10\n</code></pre>\n\n<h3>2.3 MASQUERADE</h3>\n\n<p>地址转换，动态源地址转换(动态 IP 的情况下使用)，主要还是NAT上使用</p>\n\n<pre><code>iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE\n</code></pre>\n\n<p>将源地址是 192.168.0.0/24 的数据包进行地址伪装,这是一个SNAT。</p>\n\n<h3>2.4 防火墙</h3>\n\n<p>防火墙嘛，主要就是过滤，当然是用到filter表了。</p>\n\n<pre><code>iptables -A INPUT -p tcp --dport 22 -j ACCEPT\niptables -A OUTPUT -p udp --sport 22 -j ACCEPT\n</code></pre>\n\n<h3>2.5 转发</h3>\n\n<p>如果机器具有网关的作用，那么就一定要能转发数据包，可以通过FPRWARD控制分组转发到LAN上的哪些地方，比如一个机器，两个网卡，eth0接外部网络，eth1接内部网络，并且网关作用，就要允许eth1上转发</p>\n\n<pre><code>iptables -A FORWARD -i eth1 -j ACCEPT\niptables -A FORWARD -o eth1 -j ACCEPT\n</code></pre>\n\n<p>经过以上学习，常用的iptables的功能都差不多了，其实看到这里，也就可以勒，如果你还想玩的炫一点，那就接着看下一篇。</p>\n\n<h2>3 参考资料</h2>\n\n<p><a href=\"http://man.chinaunix.net/network/iptables-tutorial-cn-1.1.19.html\">http://man.chinaunix.net/network/iptables-tutorial-cn-1.1.19.html</a></p>\n\n<p><a href=\"http://www.lampbo.org/linux-xuexi/linux-advance/iptables-options.html\">http://www.lampbo.org/linux-xuexi/linux-advance/iptables-options.html</a></p>\n\n<p><a href=\"http://tech.anquan365.com/application/other/201201/167224.html\">http://tech.anquan365.com/application/other/201201/167224.html</a></p>\n\n<p>推荐<a href=\"http://www.cnblogs.com/diyunpeng/archive/2012/05/10/2493749.html\">http://www.cnblogs.com/diyunpeng/archive/2012/05/10/2493749.html</a></p>\n\n<p>推荐<a href=\"http://blog.163.com/xychenbaihu@yeah/blog/static/132229655201212705752493/\">http://blog.163.com/xychenbaihu@yeah/blog/static/132229655201212705752493/</a></p>\n\n<p>一个实战经验，我没看：<a href=\"http://blog.sina.com.cn/s/blog_67a6c6f10100k3yx.html\">http://blog.sina.com.cn/s/blog_67a6c6f10100k3yx.html</a></p>\n','Iptables使用参考手册(二)','','inherit','open','open','','133-revision-2','','','2013-03-09 23:53:40','2013-03-09 15:53:40','','133','http://blog.wachang.net/2013/03/133-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('136','1','2013-03-09 23:59:08','2013-03-09 15:59:08','','微博','','publish','open','open','','%e5%be%ae%e5%8d%9a%e6%88%91','','','2013-03-10 00:00:16','2013-03-09 16:00:16','','0','http://blog.wachang.net/?p=136','1','nav_menu_item','','0');");
E_D("replace into `wp_posts` values('137','1','2013-02-27 18:00:15','2013-02-27 10:00:15','','极速版','','inherit','open','open','','27-revision-3','','','2013-02-27 18:00:15','2013-02-27 10:00:15','','27','http://blog.wachang.net/2013/02/27-revision-3/','0','revision','','0');");
E_D("replace into `wp_posts` values('138','1','2013-03-11 21:48:05','2013-03-11 13:48:05','<h2>1 OpenvSwitch in Kernel</h2>\n\n<p>从3.3的内核开始，OpenvSwitch（简称OVS）集成到Linux内核中去了，也就是说以后源码安装OVS的时候就不需要编译内核模块了，但是目前内核中的OVS还不支持配置GRE隧道。于是王聪的文章说了在这种情况下如何给OVS配置GRE。</p>\n\n<p>王聪：<a href=\"http://wangcong.org/blog/archives/2163\">在 openvswitch 上配置 GRE tunnel</a></p>\n\n<p>以下是相关的一些笔记：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/openvswitch-gre.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/openvswitch-gre.jpg\" alt=\"openvswitch-gre\" width=\"666\" height=\"409\" class=\"aligncenter size-full wp-image-149\" /></a></p>\n\n<blockquote>\n  <p>创建一个普通的 GRE tunnel，然后把它添加到 openvswitch bridge 中去就可以了。如下图：</p>\n  \n  <p>目标是让 HOST1 上面的两个 VM 和 HOST2 上面的两个 VM 通过 GRE tunnel 实现通信，在这个环境中，一个很可能的错误是把 HOST2 上的 uplink，即 eth0 也加入到 openvswitch 的 bridge 中，这是不对的，需要加入仅仅的是 GRE tunnel 设备，即 gre1 （你当然也可以把它命名为其它名字）。</p>\n</blockquote>\n\n<!--more-->\n\n<p><code>注意，此时的gre设备不是在OVS中创建的，是在系统中创建的。</code></p>\n\n<p>至于为什么会这样，可以参考我之前的学习笔记，大概的原理就是让VM的数据包的路由通过GRE设备，这样就可以进行GRE封装，封装后的数据源目地址就成了10.16.43.xx，这样再走eth0实际网卡出去，就能到达对端。</p>\n\n<blockquote>\n  <p>剩下的一个最重要的问题是，GRE tunnel 是无法回应 ARP 的，因为它是一个 point to point 的设备（ip addr add 192.168.2.1/24 peer 192.168.1.1/24 dev gre1），所以很明显设置了 NOARP。这个问题是这里的关键。因为这个的缘故，即使你在 VM1 上也无法 ping HOST2 上的 gre1。所以这里需要一个技巧，就是要给 bridge 本身配置一个 IP 地址，然后让 bridge 做一个 ARP proxy！</p>\n</blockquote>\n\n<p>首先要明白这个环境中为什么需要ARP。首先，<code>OVS与VM连接，VM的VNIC是有一个MAC地址的</code>。其次，这个GRE隧道是OVS和OVS之间的，所以，VM间的通信是二层MAC针的形式，在到达交互的时候MAC帧应该是<code>[dmac][smac][dip][sip][data]</code>这种形式，所以H1的VM ping H2的VM的时候，一定需要先由ARP请求得到VM的MAC地址（实际上是OVS的port的MAC地址）。那么按此推断，此时GRE封装的应该是二层数据。看看最后H2主机（不是VM）的设置：</p>\n\n<pre><code>[root@host2 ~]# ip tunnel show\ngre0: gre/ip  remote any  local any  ttl inherit  nopmtudisc\ngre1: gre/ip  remote 10.16.43.214  local 10.16.43.215  ttl inherit #首先H2是有一个gre设备\n\n[root@host2 ~]# ip r s\n192.168.2.0/24 dev ovsbr0  proto kernel  scope link  src 192.168.2.4\n192.168.1.0/24 dev gre1  scope link\n##上面一条路由相当重要，后面有解释\n192.168.122.0/24 dev virbr0  proto kernel  scope link  src 192.168.122.1\n10.16.40.0/21 dev eth0  proto kernel  scope link  src 10.16.43.215\n169.254.0.0/16 dev eth0  scope link  metric 1005\ndefault via 10.16.47.254 dev eth0\n</code></pre>\n\n<p>首先，VM通信的时候经过OVS，那么到达内核的数据就是二层的了。这个时候路由表示目的地址为192.168.1.0需要做GRE封装，于是这个二层帧被GRE封装，又根据设备gre1的性质，这个数据再三成上被封装为：</p>\n\n<pre><code>[remote_ip:10.16.43.214][local_ip:10.16.43.215][原始L2 DATA]\n</code></pre>\n\n<p>这个数据包从路由来看，又是该走eth0出去，于是再包裹一个二层：</p>\n\n<pre><code>[dmac(H1 eth0 MAC)][smac(H2 eth0 MAC)][remote_ip:10.16.43.214][local_ip:10.16.43.215][原始L2 DATA]\n</code></pre>\n\n<p>于是数据到达H1了。H1经过解封到达OVS，再到达VM。</p>\n\n<blockquote>\n  <p>HOST2 上面的 VM1 只需添加一个路由即可，配置如下：</p>\n</blockquote>\n\n<pre><code>[root@localhost ~]# ip r s\n192.168.2.0/24 dev eth1  proto kernel  scope link  src 192.168.2.2\n192.168.1.0/24 dev eth1  scope link  src 192.168.2.2\n[root@localhost ~]# ping 192.168.1.2\nPING 192.168.1.2 (192.168.1.2) 56(84) bytes of data.\n64 bytes from 192.168.1.2: icmp_seq=1 ttl=62 time=561 ms\n64 bytes from 192.168.1.2: icmp_seq=2 ttl=62 time=0.731 ms\n</code></pre>\n\n<p>VM上还需要配置路由，这个我不是很懂，再琢磨一下先。</p>\n','也谈OpenvSwitch配置GRE隧道（一）','','publish','open','open','','openvswitch-configure-gre-note-1','','\nhttp://wangcong.org/blog/archives/2163','2013-03-13 22:53:02','2013-03-13 14:53:02','','0','http://blog.wachang.net/?p=138','0','post','','0');");
E_D("replace into `wp_posts` values('139','1','2013-03-11 21:45:45','2013-03-11 13:45:45','<h2>OpenvSwitch in Kernel</h2>\n\n<p>从3.3的内核开始，OpenvSwitch（简称OVS）集成到Linux内核中去了，也就是说以后源码安装OVS的时候就不需要编译内核模块了，但是目前内核中的OVS还不支持配置GRE隧道。于是王聪的文章说了在这种情况下如何给OVS配置GRE。</p>\n\n<p>王聪：<a href=\"http://wangcong.org/blog/archives/2163\">在 openvswitch 上配置 GRE tunnel</a></p>\n\n<p>以下是相关的一些笔记：</p>\n\n<blockquote>\n  <p>创建一个普通的 GRE tunnel，然后把它添加到 openvswitch bridge 中去就可以了。如下图：</p>\n  \n  <p>目标是让 HOST1 上面的两个 VM 和 HOST2 上面的两个 VM 通过 GRE tunnel 实现通信，在这个环境中，一个很可能的错误是把 HOST2 上的 uplink，即 eth0 也加入到 openvswitch 的 bridge 中，这是不对的，需要加入仅仅的是 GRE tunnel 设备，即 gre1 （你当然也可以把它命名为其它名字）。</p>\n</blockquote>\n\n<p><code>注意，此时的gre设备不是在OVS中创建的，是在系统中创建的。</code></p>\n\n<p>至于为什么会这样，可以参考我之前的学习笔记，大概的原理就是让VM的数据包的路由通过GRE设备，这样就可以进行GRE封装，封装后的数据源目地址就成了10.16.43.xx，这样再走eth0实际网卡出去，就能到达对端。</p>\n\n<blockquote>\n  <p>剩下的一个最重要的问题是，GRE tunnel 是无法回应 ARP 的，因为它是一个 point to point 的设备（ip addr add 192.168.2.1/24 peer 192.168.1.1/24 dev gre1），所以很明显设置了 NOARP。这个问题是这里的关键。因为这个的缘故，即使你在 VM1 上也无法 ping HOST2 上的 gre1。所以这里需要一个技巧，就是要给 bridge 本身配置一个 IP 地址，然后让 bridge 做一个 ARP proxy！</p>\n</blockquote>\n\n<p>首先要明白这个环境中为什么需要ARP。首先，<code>OVS与VM连接，VM的VNIC是有一个MAC地址的</code>。其次，这个GRE隧道是OVS和OVS之间的，所以，VM间的通信是二层MAC针的形式，在到达交互的时候MAC帧应该是<code>[dmac][smac][dip][sip][data]</code>这种形式，所以H1的VM ping H2的VM的时候，一定需要先由ARP请求得到VM的MAC地址（实际上是OVS的port的MAC地址）。那么按此推断，此时GRE封装的应该是二层数据。看看最后H2主机（不是VM）的设置：</p>\n\n<pre><code>[root@host2 ~]# ip tunnel show\ngre0: gre/ip  remote any  local any  ttl inherit  nopmtudisc\ngre1: gre/ip  remote 10.16.43.214  local 10.16.43.215  ttl inherit #首先H2是有一个gre设备\n\n[root@host2 ~]# ip r s\n192.168.2.0/24 dev ovsbr0  proto kernel  scope link  src 192.168.2.4\n192.168.1.0/24 dev gre1  scope link\n##上面一条路由相当重要，后面有解释\n192.168.122.0/24 dev virbr0  proto kernel  scope link  src 192.168.122.1\n10.16.40.0/21 dev eth0  proto kernel  scope link  src 10.16.43.215\n169.254.0.0/16 dev eth0  scope link  metric 1005\ndefault via 10.16.47.254 dev eth0\n</code></pre>\n\n<p>首先，VM通信的时候经过OVS，那么到达内核的数据就是二层的了。这个时候路由表示目的地址为192.168.1.0需要做GRE封装，于是这个二层帧被GRE封装，又根据设备gre1的性质，这个数据再三成上被封装为：</p>\n\n<pre><code>[remote_ip:10.16.43.214][local_ip:10.16.43.215][原始L2 DATA]\n</code></pre>\n\n<p>这个数据包从路由来看，又是该走eth0出去，于是再包裹一个二层：</p>\n\n<pre><code>[dmac(H1 eth0 MAC)][smac(H2 eth0 MAC)][remote_ip:10.16.43.214][local_ip:10.16.43.215][原始L2 DATA]\n</code></pre>\n\n<p>于是数据到达H1了。H1经过解封到达OVS，再到达VM。</p>\n\n<blockquote>\n  <p>HOST2 上面的 VM1 只需添加一个路由即可，配置如下：</p>\n</blockquote>\n\n<pre><code>[root@localhost ~]# ip r s\n192.168.2.0/24 dev eth1  proto kernel  scope link  src 192.168.2.2\n192.168.1.0/24 dev eth1  scope link  src 192.168.2.2\n[root@localhost ~]# ping 192.168.1.2\nPING 192.168.1.2 (192.168.1.2) 56(84) bytes of data.\n64 bytes from 192.168.1.2: icmp_seq=1 ttl=62 time=561 ms\n64 bytes from 192.168.1.2: icmp_seq=2 ttl=62 time=0.731 ms\n</code></pre>\n\n<p>VM上还需要配置路由，这个我不是很懂，再琢磨一下先。</p>\n','也谈OpenvSwitch配置GRE隧道（一）','','inherit','open','open','','138-revision','','','2013-03-11 21:45:45','2013-03-11 13:45:45','','138','http://blog.wachang.net/2013/03/138-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('140','1','2013-03-11 21:48:05','2013-03-11 13:48:05','<h2>1 OpenvSwitch in Kernel</h2>\n\n<p>从3.3的内核开始，OpenvSwitch（简称OVS）集成到Linux内核中去了，也就是说以后源码安装OVS的时候就不需要编译内核模块了，但是目前内核中的OVS还不支持配置GRE隧道。于是王聪的文章说了在这种情况下如何给OVS配置GRE。</p>\n\n<p>王聪：<a href=\"http://wangcong.org/blog/archives/2163\">在 openvswitch 上配置 GRE tunnel</a></p>\n\n<p>以下是相关的一些笔记：</p>\n\n<blockquote>\n  <p>创建一个普通的 GRE tunnel，然后把它添加到 openvswitch bridge 中去就可以了。如下图：</p>\n  \n  <p>目标是让 HOST1 上面的两个 VM 和 HOST2 上面的两个 VM 通过 GRE tunnel 实现通信，在这个环境中，一个很可能的错误是把 HOST2 上的 uplink，即 eth0 也加入到 openvswitch 的 bridge 中，这是不对的，需要加入仅仅的是 GRE tunnel 设备，即 gre1 （你当然也可以把它命名为其它名字）。</p>\n</blockquote>\n\n<p><code>注意，此时的gre设备不是在OVS中创建的，是在系统中创建的。</code></p>\n\n<p>至于为什么会这样，可以参考我之前的学习笔记，大概的原理就是让VM的数据包的路由通过GRE设备，这样就可以进行GRE封装，封装后的数据源目地址就成了10.16.43.xx，这样再走eth0实际网卡出去，就能到达对端。</p>\n\n<blockquote>\n  <p>剩下的一个最重要的问题是，GRE tunnel 是无法回应 ARP 的，因为它是一个 point to point 的设备（ip addr add 192.168.2.1/24 peer 192.168.1.1/24 dev gre1），所以很明显设置了 NOARP。这个问题是这里的关键。因为这个的缘故，即使你在 VM1 上也无法 ping HOST2 上的 gre1。所以这里需要一个技巧，就是要给 bridge 本身配置一个 IP 地址，然后让 bridge 做一个 ARP proxy！</p>\n</blockquote>\n\n<p>首先要明白这个环境中为什么需要ARP。首先，<code>OVS与VM连接，VM的VNIC是有一个MAC地址的</code>。其次，这个GRE隧道是OVS和OVS之间的，所以，VM间的通信是二层MAC针的形式，在到达交互的时候MAC帧应该是<code>[dmac][smac][dip][sip][data]</code>这种形式，所以H1的VM ping H2的VM的时候，一定需要先由ARP请求得到VM的MAC地址（实际上是OVS的port的MAC地址）。那么按此推断，此时GRE封装的应该是二层数据。看看最后H2主机（不是VM）的设置：</p>\n\n<pre><code>[root@host2 ~]# ip tunnel show\ngre0: gre/ip  remote any  local any  ttl inherit  nopmtudisc\ngre1: gre/ip  remote 10.16.43.214  local 10.16.43.215  ttl inherit #首先H2是有一个gre设备\n\n[root@host2 ~]# ip r s\n192.168.2.0/24 dev ovsbr0  proto kernel  scope link  src 192.168.2.4\n192.168.1.0/24 dev gre1  scope link\n##上面一条路由相当重要，后面有解释\n192.168.122.0/24 dev virbr0  proto kernel  scope link  src 192.168.122.1\n10.16.40.0/21 dev eth0  proto kernel  scope link  src 10.16.43.215\n169.254.0.0/16 dev eth0  scope link  metric 1005\ndefault via 10.16.47.254 dev eth0\n</code></pre>\n\n<p>首先，VM通信的时候经过OVS，那么到达内核的数据就是二层的了。这个时候路由表示目的地址为192.168.1.0需要做GRE封装，于是这个二层帧被GRE封装，又根据设备gre1的性质，这个数据再三成上被封装为：</p>\n\n<pre><code>[remote_ip:10.16.43.214][local_ip:10.16.43.215][原始L2 DATA]\n</code></pre>\n\n<p>这个数据包从路由来看，又是该走eth0出去，于是再包裹一个二层：</p>\n\n<pre><code>[dmac(H1 eth0 MAC)][smac(H2 eth0 MAC)][remote_ip:10.16.43.214][local_ip:10.16.43.215][原始L2 DATA]\n</code></pre>\n\n<p>于是数据到达H1了。H1经过解封到达OVS，再到达VM。</p>\n\n<blockquote>\n  <p>HOST2 上面的 VM1 只需添加一个路由即可，配置如下：</p>\n</blockquote>\n\n<pre><code>[root@localhost ~]# ip r s\n192.168.2.0/24 dev eth1  proto kernel  scope link  src 192.168.2.2\n192.168.1.0/24 dev eth1  scope link  src 192.168.2.2\n[root@localhost ~]# ping 192.168.1.2\nPING 192.168.1.2 (192.168.1.2) 56(84) bytes of data.\n64 bytes from 192.168.1.2: icmp_seq=1 ttl=62 time=561 ms\n64 bytes from 192.168.1.2: icmp_seq=2 ttl=62 time=0.731 ms\n</code></pre>\n\n<p>VM上还需要配置路由，这个我不是很懂，再琢磨一下先。</p>\n','也谈OpenvSwitch配置GRE隧道（一）','','inherit','open','open','','138-revision-2','','','2013-03-11 21:48:05','2013-03-11 13:48:05','','138','http://blog.wachang.net/2013/03/138-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('141','1','2013-03-11 21:48:28','2013-03-11 13:48:28','<h2>1 OpenvSwitch in Kernel</h2>\n\n<p>从3.3的内核开始，OpenvSwitch（简称OVS）集成到Linux内核中去了，也就是说以后源码安装OVS的时候就不需要编译内核模块了，但是目前内核中的OVS还不支持配置GRE隧道。于是王聪的文章说了在这种情况下如何给OVS配置GRE。</p>\n\n<p>王聪：<a href=\"http://wangcong.org/blog/archives/2163\">在 openvswitch 上配置 GRE tunnel</a></p>\n\n<p>以下是相关的一些笔记：</p>\n\n<blockquote>\n  <p>创建一个普通的 GRE tunnel，然后把它添加到 openvswitch bridge 中去就可以了。如下图：</p>\n  \n  <p>目标是让 HOST1 上面的两个 VM 和 HOST2 上面的两个 VM 通过 GRE tunnel 实现通信，在这个环境中，一个很可能的错误是把 HOST2 上的 uplink，即 eth0 也加入到 openvswitch 的 bridge 中，这是不对的，需要加入仅仅的是 GRE tunnel 设备，即 gre1 （你当然也可以把它命名为其它名字）。\n  <!--more-->\n  <code>注意，此时的gre设备不是在OVS中创建的，是在系统中创建的。</code></p>\n</blockquote>\n\n<p>至于为什么会这样，可以参考我之前的学习笔记，大概的原理就是让VM的数据包的路由通过GRE设备，这样就可以进行GRE封装，封装后的数据源目地址就成了10.16.43.xx，这样再走eth0实际网卡出去，就能到达对端。</p>\n\n<blockquote>\n  <p>剩下的一个最重要的问题是，GRE tunnel 是无法回应 ARP 的，因为它是一个 point to point 的设备（ip addr add 192.168.2.1/24 peer 192.168.1.1/24 dev gre1），所以很明显设置了 NOARP。这个问题是这里的关键。因为这个的缘故，即使你在 VM1 上也无法 ping HOST2 上的 gre1。所以这里需要一个技巧，就是要给 bridge 本身配置一个 IP 地址，然后让 bridge 做一个 ARP proxy！</p>\n</blockquote>\n\n<p>首先要明白这个环境中为什么需要ARP。首先，<code>OVS与VM连接，VM的VNIC是有一个MAC地址的</code>。其次，这个GRE隧道是OVS和OVS之间的，所以，VM间的通信是二层MAC针的形式，在到达交互的时候MAC帧应该是<code>[dmac][smac][dip][sip][data]</code>这种形式，所以H1的VM ping H2的VM的时候，一定需要先由ARP请求得到VM的MAC地址（实际上是OVS的port的MAC地址）。那么按此推断，此时GRE封装的应该是二层数据。看看最后H2主机（不是VM）的设置：</p>\n\n<pre><code>[root@host2 ~]# ip tunnel show\ngre0: gre/ip  remote any  local any  ttl inherit  nopmtudisc\ngre1: gre/ip  remote 10.16.43.214  local 10.16.43.215  ttl inherit #首先H2是有一个gre设备\n\n[root@host2 ~]# ip r s\n192.168.2.0/24 dev ovsbr0  proto kernel  scope link  src 192.168.2.4\n192.168.1.0/24 dev gre1  scope link\n##上面一条路由相当重要，后面有解释\n192.168.122.0/24 dev virbr0  proto kernel  scope link  src 192.168.122.1\n10.16.40.0/21 dev eth0  proto kernel  scope link  src 10.16.43.215\n169.254.0.0/16 dev eth0  scope link  metric 1005\ndefault via 10.16.47.254 dev eth0\n</code></pre>\n\n<p>首先，VM通信的时候经过OVS，那么到达内核的数据就是二层的了。这个时候路由表示目的地址为192.168.1.0需要做GRE封装，于是这个二层帧被GRE封装，又根据设备gre1的性质，这个数据再三成上被封装为：</p>\n\n<pre><code>[remote_ip:10.16.43.214][local_ip:10.16.43.215][原始L2 DATA]\n</code></pre>\n\n<p>这个数据包从路由来看，又是该走eth0出去，于是再包裹一个二层：</p>\n\n<pre><code>[dmac(H1 eth0 MAC)][smac(H2 eth0 MAC)][remote_ip:10.16.43.214][local_ip:10.16.43.215][原始L2 DATA]\n</code></pre>\n\n<p>于是数据到达H1了。H1经过解封到达OVS，再到达VM。</p>\n\n<blockquote>\n  <p>HOST2 上面的 VM1 只需添加一个路由即可，配置如下：</p>\n</blockquote>\n\n<pre><code>[root@localhost ~]# ip r s\n192.168.2.0/24 dev eth1  proto kernel  scope link  src 192.168.2.2\n192.168.1.0/24 dev eth1  scope link  src 192.168.2.2\n[root@localhost ~]# ping 192.168.1.2\nPING 192.168.1.2 (192.168.1.2) 56(84) bytes of data.\n64 bytes from 192.168.1.2: icmp_seq=1 ttl=62 time=561 ms\n64 bytes from 192.168.1.2: icmp_seq=2 ttl=62 time=0.731 ms\n</code></pre>\n\n<p>VM上还需要配置路由，这个我不是很懂，再琢磨一下先。</p>\n','也谈OpenvSwitch配置GRE隧道（一）','','inherit','open','open','','138-revision-3','','','2013-03-11 21:48:28','2013-03-11 13:48:28','','138','http://blog.wachang.net/2013/03/138-revision-3/','0','revision','','0');");
E_D("replace into `wp_posts` values('142','1','2013-03-12 01:07:55','0000-00-00 00:00:00','<p>http://www.longgeek.com/2013/03/11/openstack-grizzly-g3-for-ubuntu-12-04-all-in-one-installation/\nhttp://docs.gridcentric.com/canary/usage.html\nhttps://wiki.openstack.org/wiki/PerformanceMonitoringTools\nhttp://blog.csdn.net/21aspnet/article/details/6729724</p>\n','','','draft','open','open','','','','','2013-03-12 01:07:55','2013-03-11 17:07:55','','0','http://blog.wachang.net/?p=142','0','post','','0');");
E_D("replace into `wp_posts` values('143','1','2013-03-13 10:35:19','0000-00-00 00:00:00','<p>http://blog.csdn.net/yahohi/article/details/6631934</p>\n','OVS使用','','draft','open','open','','','','','2013-03-13 10:35:19','2013-03-13 02:35:19','','0','http://blog.wachang.net/?p=143','0','post','','0');");
E_D("replace into `wp_posts` values('144','1','2013-03-12 21:46:47','2013-03-12 13:46:47','<p>http://blog.csdn.net/yahohi/article/details/6631934</p>\n','OVS使用','','inherit','open','open','','143-revision','','','2013-03-12 21:46:47','2013-03-12 13:46:47','','143','http://blog.wachang.net/2013/03/143-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('145','1','2013-03-13 15:39:27','0000-00-00 00:00:00','<p>https://wiki.openstack.org/wiki/ConfigureOpenvswitch</p>\n\n<p>https://wiki.openstack.org/wiki/Quantum</p>\n','OpenStack Folsom Quantum GRE模式工作流程','','draft','open','open','','','','','2013-03-13 15:39:27','2013-03-13 07:39:27','','0','http://blog.wachang.net/?p=145','0','post','','0');");
E_D("replace into `wp_posts` values('146','1','2013-03-13 15:37:37','2013-03-13 07:37:37','<p>https://wiki.openstack.org/wiki/ConfigureOpenvswitch</p>\n','OpenStack Folsom Quantum GRE模式工作流程','','inherit','open','open','','145-revision','','','2013-03-13 15:37:37','2013-03-13 07:37:37','','145','http://blog.wachang.net/2013/03/145-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('147','1','2013-03-13 18:08:45','0000-00-00 00:00:00','<p>http://www.sebastien-han.fr/blog/2012/09/28/quantum-plugin-comparison/</p>\n','openstack插件概况','','draft','open','open','','','','','2013-03-13 18:08:45','2013-03-13 10:08:45','','0','http://blog.wachang.net/?p=147','0','post','','0');");
E_D("replace into `wp_posts` values('148','1','2013-03-13 18:08:39','2013-03-13 10:08:39','\n','openstack插件概况','','inherit','open','open','','147-revision','','','2013-03-13 18:08:39','2013-03-13 10:08:39','','147','http://blog.wachang.net/2013/03/147-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('149','1','2013-03-13 22:52:54','2013-03-13 14:52:54','','openvswitch-gre','','inherit','open','open','','openvswitch-gre','','','2013-03-13 22:52:54','2013-03-13 14:52:54','','138','http://blog.wachang.net/wp-content/uploads/2013/03/openvswitch-gre.jpg','0','attachment','image/jpeg','0');");
E_D("replace into `wp_posts` values('150','1','2013-03-11 21:50:06','2013-03-11 13:50:06','<h2>1 OpenvSwitch in Kernel</h2>\n\n<p>从3.3的内核开始，OpenvSwitch（简称OVS）集成到Linux内核中去了，也就是说以后源码安装OVS的时候就不需要编译内核模块了，但是目前内核中的OVS还不支持配置GRE隧道。于是王聪的文章说了在这种情况下如何给OVS配置GRE。</p>\n\n<p>王聪：<a href=\"http://wangcong.org/blog/archives/2163\">在 openvswitch 上配置 GRE tunnel</a></p>\n\n<p>以下是相关的一些笔记：</p>\n\n<blockquote>\n  <p>创建一个普通的 GRE tunnel，然后把它添加到 openvswitch bridge 中去就可以了。如下图：</p>\n  \n  <p>目标是让 HOST1 上面的两个 VM 和 HOST2 上面的两个 VM 通过 GRE tunnel 实现通信，在这个环境中，一个很可能的错误是把 HOST2 上的 uplink，即 eth0 也加入到 openvswitch 的 bridge 中，这是不对的，需要加入仅仅的是 GRE tunnel 设备，即 gre1 （你当然也可以把它命名为其它名字）。</p>\n</blockquote>\n\n<!--more-->\n\n<p><code>注意，此时的gre设备不是在OVS中创建的，是在系统中创建的。</code></p>\n\n<p>至于为什么会这样，可以参考我之前的学习笔记，大概的原理就是让VM的数据包的路由通过GRE设备，这样就可以进行GRE封装，封装后的数据源目地址就成了10.16.43.xx，这样再走eth0实际网卡出去，就能到达对端。</p>\n\n<blockquote>\n  <p>剩下的一个最重要的问题是，GRE tunnel 是无法回应 ARP 的，因为它是一个 point to point 的设备（ip addr add 192.168.2.1/24 peer 192.168.1.1/24 dev gre1），所以很明显设置了 NOARP。这个问题是这里的关键。因为这个的缘故，即使你在 VM1 上也无法 ping HOST2 上的 gre1。所以这里需要一个技巧，就是要给 bridge 本身配置一个 IP 地址，然后让 bridge 做一个 ARP proxy！</p>\n</blockquote>\n\n<p>首先要明白这个环境中为什么需要ARP。首先，<code>OVS与VM连接，VM的VNIC是有一个MAC地址的</code>。其次，这个GRE隧道是OVS和OVS之间的，所以，VM间的通信是二层MAC针的形式，在到达交互的时候MAC帧应该是<code>[dmac][smac][dip][sip][data]</code>这种形式，所以H1的VM ping H2的VM的时候，一定需要先由ARP请求得到VM的MAC地址（实际上是OVS的port的MAC地址）。那么按此推断，此时GRE封装的应该是二层数据。看看最后H2主机（不是VM）的设置：</p>\n\n<pre><code>[root@host2 ~]# ip tunnel show\ngre0: gre/ip  remote any  local any  ttl inherit  nopmtudisc\ngre1: gre/ip  remote 10.16.43.214  local 10.16.43.215  ttl inherit #首先H2是有一个gre设备\n\n[root@host2 ~]# ip r s\n192.168.2.0/24 dev ovsbr0  proto kernel  scope link  src 192.168.2.4\n192.168.1.0/24 dev gre1  scope link\n##上面一条路由相当重要，后面有解释\n192.168.122.0/24 dev virbr0  proto kernel  scope link  src 192.168.122.1\n10.16.40.0/21 dev eth0  proto kernel  scope link  src 10.16.43.215\n169.254.0.0/16 dev eth0  scope link  metric 1005\ndefault via 10.16.47.254 dev eth0\n</code></pre>\n\n<p>首先，VM通信的时候经过OVS，那么到达内核的数据就是二层的了。这个时候路由表示目的地址为192.168.1.0需要做GRE封装，于是这个二层帧被GRE封装，又根据设备gre1的性质，这个数据再三成上被封装为：</p>\n\n<pre><code>[remote_ip:10.16.43.214][local_ip:10.16.43.215][原始L2 DATA]\n</code></pre>\n\n<p>这个数据包从路由来看，又是该走eth0出去，于是再包裹一个二层：</p>\n\n<pre><code>[dmac(H1 eth0 MAC)][smac(H2 eth0 MAC)][remote_ip:10.16.43.214][local_ip:10.16.43.215][原始L2 DATA]\n</code></pre>\n\n<p>于是数据到达H1了。H1经过解封到达OVS，再到达VM。</p>\n\n<blockquote>\n  <p>HOST2 上面的 VM1 只需添加一个路由即可，配置如下：</p>\n</blockquote>\n\n<pre><code>[root@localhost ~]# ip r s\n192.168.2.0/24 dev eth1  proto kernel  scope link  src 192.168.2.2\n192.168.1.0/24 dev eth1  scope link  src 192.168.2.2\n[root@localhost ~]# ping 192.168.1.2\nPING 192.168.1.2 (192.168.1.2) 56(84) bytes of data.\n64 bytes from 192.168.1.2: icmp_seq=1 ttl=62 time=561 ms\n64 bytes from 192.168.1.2: icmp_seq=2 ttl=62 time=0.731 ms\n</code></pre>\n\n<p>VM上还需要配置路由，这个我不是很懂，再琢磨一下先。</p>\n','也谈OpenvSwitch配置GRE隧道（一）','','inherit','open','open','','138-revision-4','','','2013-03-11 21:50:06','2013-03-11 13:50:06','','138','http://blog.wachang.net/2013/03/138-revision-4/','0','revision','','0');");
E_D("replace into `wp_posts` values('151','1','2013-03-13 23:18:51','2013-03-13 15:18:51','<p>又看了王聪大神的两篇文章，感觉对于隧道技术有新的理解了。</p>\n\n<p>文章1：王聪：<a href=\"http://wangcong.org/blog/archives/1683\">各种 tunnel</a></p>\n\n<p>还是罗列一下我的学习笔记：</p>\n\n<blockquote>\n  <p>概括地讲，所谓 tunnel 就是把下一层（比如IPv4层）的包封装到上一层（比如 SSH，HTTP）或者同一层（比如IPv6层）的协议中进行传输，从而实现网络之间的穿透。很明显，这种实现有个前提，那就是，发送端和接收端必须各有一个解析这种包的程序或者内核模块才能实现正常通信。</p>\n</blockquote>\n\n<p><strong>之前我知道GRE是三层协议，以为就是封装网络层的数据，从这么看的话，不是的，GRE应该是可以封装2层和三层的！！！</strong></p>\n\n<!--more-->\n\n<blockquote>\n  <p>内核中可以支持四种隧道：ipip、gre、sit、isatap</p>\n  \n  <p>ipip 是把 IP 层封装到 IP 层的一个 tunnel，看起来似乎是浪费，实则不然。它的作用其实基本上就相当于一个基于IP层的网桥！我们知道，普通的网桥是基于mac层的，根本不需 IP，而这个 ipip 则是通过两端的路由做一个 tunnel，把两个本来不通的网络通过点对点连接起来。ipip 的源代码在内核 net/ipv4/ipip.c 中可以找到。</p>\n  \n  <p>sit 和 isatap 都是 IPv6 over IPv4 的 tunnel，它们的源代码在 net/ipv6/sit.c 中。它们之间也不同，和IPv6的地址有关，写在这里恐怕放不下了，故省略。</p>\n  \n  <p>IPSec 还用到一个叫 L2TP 的 tunnel，在内核源代码 net/l2tp 中，PPTP 是另外一个，在 drivers/net/pptp.c 中实现。</p>\n  \n  <p>gre 和它类似，但它功能还要更强大一些，还支持广播，它可以取代 ipip。</p>\n</blockquote>\n\n<p>王聪的另外一个文章详细讲解了GRE隧道的特点：</p>\n\n<p>王聪：<a href=\"http://wangcong.org/blog/archives/2149\">深入理解 GRE tunnel</a></p>\n\n<p>也是好文章，直接引用~~~</p>\n\n<p>首先，多数tunnel都是点到点的，也就是说，<strong>是从机器的一端到另外一个机器的一端</strong>，如下图：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/sit_tunnel1.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/sit_tunnel1.jpg\" alt=\"sit_tunnel1\" width=\"794\" height=\"442\" class=\"aligncenter size-full wp-image-152\" /></a></p>\n\n<p>除了端点的 host A 和 host B之外，中间经过的任何设备都是看不到里面的 IPv6 的头，对于它们来说，经过 sit 发出的包和其它的 IPv4 的包没有任何区别。</p>\n\n<p>GRE tunnel 却不一样了，它的原理从根本上和 sit，ipip 这样的 tunnel 就不一样。除了外层的 IP 头和内层的 IP 头之间多了一个 GRE 头之外，它最大的不同是，tunnel 不是建立在最终的 host 上，而是在中间的 router 上！换句话说，对于端点 host A 和 host B 来说，该 tunnel 是透明的（对比上面的 sit tunnel）。这是网上很多教程里没有直接告诉你的。理解这一点非常关键，正是因为它这么设计的，所以它才能解决 ipip tunnel 解决不了的问题。所以，经过 GRE tunnel 发送的包（从 host A 发送到 host B）大体过程是这样子的：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre_tunnel.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre_tunnel.jpg\" alt=\"gre_tunnel\" width=\"847\" height=\"445\" class=\"aligncenter size-full wp-image-154\" /></a></p>\n\n<p>我们可以看出，从 host A 发出的包其实就是一个很普通的 IP 包，除了目的地址不直接可达外。该 GRE tunnel 的一端是建立在 router A上，另一段是建立在 router B上，所以添加外部的 IP 头是在 router A 上完成的，而去掉外面的 IP 头是在 router B上完成的，两个端点的 host 上几乎什么都不用做（除了配置路由，把发送到 10.0.2.0 的包路由到 router A）！</p>\n\n<p>这么设计的好处也就很容易看出来了，ipip tunnel 是端对端的，通信也就只能是点对点的，而 GRE tunnel 却可以进行多播。</p>\n\n<p>最后来一张GRE报文格式图：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre_header.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre_header.png\" alt=\"gre_header\" width=\"479\" height=\"119\" class=\"aligncenter size-full wp-image-155\" /></a></p>\n\n<h2>参考文章：</h2>\n\n<p><a href=\"http://www.linuxdocs.org/HOWTOs/Adv-Routing-HOWTO-5.html\">http://www.linuxdocs.org/HOWTOs/Adv-Routing-HOWTO-5.html</a></p>\n','隧道技术GRE/PPTP/SSH等学习笔记','','publish','open','open','','tunnel-techology-note','','','2013-03-13 23:19:23','2013-03-13 15:19:23','','0','http://blog.wachang.net/?p=151','0','post','','0');");
E_D("replace into `wp_posts` values('152','1','2013-03-13 23:13:42','2013-03-13 15:13:42','','sit_tunnel1','','inherit','open','open','','sit_tunnel1','','','2013-03-13 23:13:42','2013-03-13 15:13:42','','151','http://blog.wachang.net/wp-content/uploads/2013/03/sit_tunnel1.jpg','0','attachment','image/jpeg','0');");
E_D("replace into `wp_posts` values('153','1','2013-03-13 23:14:52','2013-03-13 15:14:52','','gre_tunnel1','','inherit','open','open','','gre_tunnel1','','','2013-03-13 23:14:52','2013-03-13 15:14:52','','151','http://blog.wachang.net/wp-content/uploads/2013/03/gre_tunnel1.jpg','0','attachment','image/jpeg','0');");
E_D("replace into `wp_posts` values('154','1','2013-03-13 23:15:32','2013-03-13 15:15:32','','gre_tunnel','','inherit','open','open','','gre_tunnel','','','2013-03-13 23:15:32','2013-03-13 15:15:32','','151','http://blog.wachang.net/wp-content/uploads/2013/03/gre_tunnel.jpg','0','attachment','image/jpeg','0');");
E_D("replace into `wp_posts` values('155','1','2013-03-13 23:16:39','2013-03-13 15:16:39','','gre_header','','inherit','open','open','','gre_header','','','2013-03-13 23:16:39','2013-03-13 15:16:39','','151','http://blog.wachang.net/wp-content/uploads/2013/03/gre_header.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('156','1','2013-03-13 23:17:02','2013-03-13 15:17:02','<p>又看了王聪大神的两篇文章，感觉对于隧道技术有新的理解了。</p>\n\n<p>文章1：王聪：<a href=\"http://wangcong.org/blog/archives/1683\">各种 tunnel</a></p>\n\n<p>还是罗列一下我的学习笔记：</p>\n\n<blockquote>\n  <p>概括地讲，所谓 tunnel 就是把下一层（比如IPv4层）的包封装到上一层（比如 SSH，HTTP）或者同一层（比如IPv6层）的协议中进行传输，从而实现网络之间的穿透。很明显，这种实现有个前提，那就是，发送端和接收端必须各有一个解析这种包的程序或者内核模块才能实现正常通信。</p>\n</blockquote>\n\n<p><strong>之前我知道GRE是三层协议，以为就是封装网络层的数据，从这么看的话，不是的，GRE应该是可以封装2层和三层的！！！</strong></p>\n\n<blockquote>\n  <p>内核中可以支持四种隧道：ipip、gre、sit、isatap</p>\n  \n  <p>ipip 是把 IP 层封装到 IP 层的一个 tunnel，看起来似乎是浪费，实则不然。它的作用其实基本上就相当于一个基于IP层的网桥！我们知道，普通的网桥是基于mac层的，根本不需 IP，而这个 ipip 则是通过两端的路由做一个 tunnel，把两个本来不通的网络通过点对点连接起来。ipip 的源代码在内核 net/ipv4/ipip.c 中可以找到。</p>\n  \n  <p>sit 和 isatap 都是 IPv6 over IPv4 的 tunnel，它们的源代码在 net/ipv6/sit.c 中。它们之间也不同，和IPv6的地址有关，写在这里恐怕放不下了，故省略。</p>\n  \n  <p>IPSec 还用到一个叫 L2TP 的 tunnel，在内核源代码 net/l2tp 中，PPTP 是另外一个，在 drivers/net/pptp.c 中实现。</p>\n  \n  <p>gre 和它类似，但它功能还要更强大一些，还支持广播，它可以取代 ipip。</p>\n</blockquote>\n\n<p>王聪的另外一个文章详细讲解了GRE隧道的特点：</p>\n\n<p>王聪：<a href=\"http://wangcong.org/blog/archives/2149\">深入理解 GRE tunnel</a></p>\n\n<p>也是好文章，直接引用~~~</p>\n\n<p>首先，多数tunnel都是点到点的，也就是说，<strong>是从机器的一端到另外一个机器的一端</strong>，如下图：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/sit_tunnel1.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/sit_tunnel1.jpg\" alt=\"sit_tunnel1\" width=\"794\" height=\"442\" class=\"aligncenter size-full wp-image-152\" /></a></p>\n\n<p>除了端点的 host A 和 host B之外，中间经过的任何设备都是看不到里面的 IPv6 的头，对于它们来说，经过 sit 发出的包和其它的 IPv4 的包没有任何区别。</p>\n\n<p>GRE tunnel 却不一样了，它的原理从根本上和 sit，ipip 这样的 tunnel 就不一样。除了外层的 IP 头和内层的 IP 头之间多了一个 GRE 头之外，它最大的不同是，tunnel 不是建立在最终的 host 上，而是在中间的 router 上！换句话说，对于端点 host A 和 host B 来说，该 tunnel 是透明的（对比上面的 sit tunnel）。这是网上很多教程里没有直接告诉你的。理解这一点非常关键，正是因为它这么设计的，所以它才能解决 ipip tunnel 解决不了的问题。所以，经过 GRE tunnel 发送的包（从 host A 发送到 host B）大体过程是这样子的：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre_tunnel.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre_tunnel.jpg\" alt=\"gre_tunnel\" width=\"847\" height=\"445\" class=\"aligncenter size-full wp-image-154\" /></a></p>\n\n<p>我们可以看出，从 host A 发出的包其实就是一个很普通的 IP 包，除了目的地址不直接可达外。该 GRE tunnel 的一端是建立在 router A上，另一段是建立在 router B上，所以添加外部的 IP 头是在 router A 上完成的，而去掉外面的 IP 头是在 router B上完成的，两个端点的 host 上几乎什么都不用做（除了配置路由，把发送到 10.0.2.0 的包路由到 router A）！</p>\n\n<p>这么设计的好处也就很容易看出来了，ipip tunnel 是端对端的，通信也就只能是点对点的，而 GRE tunnel 却可以进行多播。</p>\n\n<p>最后来一张GRE报文格式图：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre_header.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre_header.png\" alt=\"gre_header\" width=\"479\" height=\"119\" class=\"aligncenter size-full wp-image-155\" /></a></p>\n\n<h2>参考文章：</h2>\n\n<p><a href=\"http://www.linuxdocs.org/HOWTOs/Adv-Routing-HOWTO-5.html\">http://www.linuxdocs.org/HOWTOs/Adv-Routing-HOWTO-5.html</a></p>\n','隧道技术GRE/PPTP/SSH等学习笔记','','inherit','open','open','','151-revision','','','2013-03-13 23:17:02','2013-03-13 15:17:02','','151','http://blog.wachang.net/2013/03/151-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('157','1','2013-03-13 23:18:51','2013-03-13 15:18:51','<p>又看了王聪大神的两篇文章，感觉对于隧道技术有新的理解了。</p>\n\n<p>文章1：王聪：<a href=\"http://wangcong.org/blog/archives/1683\">各种 tunnel</a></p>\n\n<p>还是罗列一下我的学习笔记：</p>\n\n<blockquote>\n  <p>概括地讲，所谓 tunnel 就是把下一层（比如IPv4层）的包封装到上一层（比如 SSH，HTTP）或者同一层（比如IPv6层）的协议中进行传输，从而实现网络之间的穿透。很明显，这种实现有个前提，那就是，发送端和接收端必须各有一个解析这种包的程序或者内核模块才能实现正常通信。</p>\n</blockquote>\n\n<p><strong>之前我知道GRE是三层协议，以为就是封装网络层的数据，从这么看的话，不是的，GRE应该是可以封装2层和三层的！！！</strong></p>\n\n<blockquote>\n  <p>内核中可以支持四种隧道：ipip、gre、sit、isatap</p>\n  \n  <p>ipip 是把 IP 层封装到 IP 层的一个 tunnel，看起来似乎是浪费，实则不然。它的作用其实基本上就相当于一个基于IP层的网桥！我们知道，普通的网桥是基于mac层的，根本不需 IP，而这个 ipip 则是通过两端的路由做一个 tunnel，把两个本来不通的网络通过点对点连接起来。ipip 的源代码在内核 net/ipv4/ipip.c 中可以找到。</p>\n  \n  <p>sit 和 isatap 都是 IPv6 over IPv4 的 tunnel，它们的源代码在 net/ipv6/sit.c 中。它们之间也不同，和IPv6的地址有关，写在这里恐怕放不下了，故省略。</p>\n  \n  <p>IPSec 还用到一个叫 L2TP 的 tunnel，在内核源代码 net/l2tp 中，PPTP 是另外一个，在 drivers/net/pptp.c 中实现。</p>\n  \n  <p>gre 和它类似，但它功能还要更强大一些，还支持广播，它可以取代 ipip。</p>\n</blockquote>\n\n<p>王聪的另外一个文章详细讲解了GRE隧道的特点：</p>\n\n<p>王聪：<a href=\"http://wangcong.org/blog/archives/2149\">深入理解 GRE tunnel</a></p>\n\n<p>也是好文章，直接引用~~~</p>\n\n<p>首先，多数tunnel都是点到点的，也就是说，<strong>是从机器的一端到另外一个机器的一端</strong>，如下图：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/sit_tunnel1.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/sit_tunnel1.jpg\" alt=\"sit_tunnel1\" width=\"794\" height=\"442\" class=\"aligncenter size-full wp-image-152\" /></a></p>\n\n<p>除了端点的 host A 和 host B之外，中间经过的任何设备都是看不到里面的 IPv6 的头，对于它们来说，经过 sit 发出的包和其它的 IPv4 的包没有任何区别。</p>\n\n<p>GRE tunnel 却不一样了，它的原理从根本上和 sit，ipip 这样的 tunnel 就不一样。除了外层的 IP 头和内层的 IP 头之间多了一个 GRE 头之外，它最大的不同是，tunnel 不是建立在最终的 host 上，而是在中间的 router 上！换句话说，对于端点 host A 和 host B 来说，该 tunnel 是透明的（对比上面的 sit tunnel）。这是网上很多教程里没有直接告诉你的。理解这一点非常关键，正是因为它这么设计的，所以它才能解决 ipip tunnel 解决不了的问题。所以，经过 GRE tunnel 发送的包（从 host A 发送到 host B）大体过程是这样子的：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre_tunnel.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre_tunnel.jpg\" alt=\"gre_tunnel\" width=\"847\" height=\"445\" class=\"aligncenter size-full wp-image-154\" /></a></p>\n\n<p>我们可以看出，从 host A 发出的包其实就是一个很普通的 IP 包，除了目的地址不直接可达外。该 GRE tunnel 的一端是建立在 router A上，另一段是建立在 router B上，所以添加外部的 IP 头是在 router A 上完成的，而去掉外面的 IP 头是在 router B上完成的，两个端点的 host 上几乎什么都不用做（除了配置路由，把发送到 10.0.2.0 的包路由到 router A）！</p>\n\n<p>这么设计的好处也就很容易看出来了，ipip tunnel 是端对端的，通信也就只能是点对点的，而 GRE tunnel 却可以进行多播。</p>\n\n<p>最后来一张GRE报文格式图：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre_header.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/gre_header.png\" alt=\"gre_header\" width=\"479\" height=\"119\" class=\"aligncenter size-full wp-image-155\" /></a></p>\n\n<h2>参考文章：</h2>\n\n<p><a href=\"http://www.linuxdocs.org/HOWTOs/Adv-Routing-HOWTO-5.html\">http://www.linuxdocs.org/HOWTOs/Adv-Routing-HOWTO-5.html</a></p>\n','隧道技术GRE/PPTP/SSH等学习笔记','','inherit','open','open','','151-revision-2','','','2013-03-13 23:18:51','2013-03-13 15:18:51','','151','http://blog.wachang.net/2013/03/151-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('158','1','2013-03-14 22:46:50','0000-00-00 00:00:00','\n','自动草稿','','auto-draft','open','open','','','','','2013-03-14 22:46:50','0000-00-00 00:00:00','','0','http://blog.wachang.net/?p=158','0','post','','0');");
E_D("replace into `wp_posts` values('159','1','2013-03-19 22:28:22','2013-03-19 14:28:22','<p>今天看到mirantis把hadoop和openstack进行了一个集成，提出了一个EHO系统，从架构上看还是很有意思的。对于我做过OpenStack开发的话，还是蛮有收获。重点是EHO现在的文档做的相当好，就很有参考价值了。</p>\n\n<p>主页：<a href=\"http://eho.mirantis.com/index.html\">http://eho.mirantis.com/index.html</a></p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/EHO-ARCH.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/EHO-ARCH.jpg\" alt=\"EHO ARCH\" width=\"787\" height=\"453\" class=\"aligncenter size-full wp-image-176\" /></a></p>\n','Mirantis-Elastic Hadoop on OpenStack','','publish','open','open','','mirantis-elastic-hadoop-on-openstack','','','2013-03-19 22:28:22','2013-03-19 14:28:22','','0','http://blog.wachang.net/?p=159','0','post','','0');");
E_D("replace into `wp_posts` values('160','1','2013-03-15 19:37:56','2013-03-15 11:37:56','\n','Elastic Hadoop on OpenStack','','inherit','open','open','','159-revision','','','2013-03-15 19:37:56','2013-03-15 11:37:56','','159','http://blog.wachang.net/2013/03/159-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('161','1','2013-03-15 21:19:00','0000-00-00 00:00:00','<p>有时候看代码需要总结，这个类之间的关系很复杂，懒得有手写，就想用一点工具来自动生成。于是就找了找Python的UML工具，至于什么是UML，随便一查就知道了。具体需求正如以下这哥们所说：</p>\n\n<blockquote>\n  <p>随着项目进展，类越来越多，原来做总体设计的时候没有想到有这么复杂的情况:(。现在我想画出uml图来反映各个类之间的关系。</p>\n</blockquote>\n\n<p>于是找了下，有这么些工具：</p>\n\n<h2>1 Ecplise插件pyuml</h2>\n\n<h2>2 Python UML Tool</h2>\n\n<p>在http://sourceforge.net/projects/pyut/上找到的，版不过版本确实比较老了，最后更新是09年的。</p>\n\n<h2>3 Pynsource</h2>\n\n<p><a href=\"http://www.andypatterns.com/index.php/products/pynsource/\">项目主页</a></p>\n\n<p><a href=\"https://code.google.com/p/pynsource/downloads/list\">下载</a></p>\n\n<p>使用上比较方便，导入python文件后就可以自动生成相应的类关系，特别是支持把关系转换成asic表，这个我就喜欢！</p>\n\n<h2>4 Gaphor</h2>\n\n<p>sourceforge.net/projects/gaphor/</p>\n\n<h2>Dia</h2>\n\n<p>Dia是基于GTK的图形绘制程序，适用于Linux, Unix和Window DIA软件启动界面 s，以 GPL 许可发布。通俗的说，一个10MB量级的免费软件，代替visio基本没问题，被收入了“最好的300款免费软件”。也有些用户认为Dia很多地方不太好用，但无论如何，它是综合性能最高的免费解决方案。</p>\n\n<h2>参考文章</h2>\n\n<p>http://imtx.me/archives/155.html</p>\n\n<p>http://www.cnblogs.com/dkblog/archive/2011/05/06/2039124.html</p>\n\n<p>http://www.blogjava.net/xiaohuzi2008/archive/2012/12/25/393463.html</p>\n\n<p>http://blog.chinaunix.net/uid-20446794-id-1677395.html</p>\n\n<p>http://tgic.me/2010/02/05/%E8%A7%A3%E5%86%B3-gaphor-uml-%E4%B8%8D%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E7%9A%84%E9%97%AE%E9%A2%98/</p>\n\n<p>https://cacoo.com</p>\n','UML Tools For Python','','draft','open','open','','uml-tools-for-python','','','2013-03-15 21:19:00','2013-03-15 13:19:00','','0','http://blog.wachang.net/?p=161','0','post','','0');");
E_D("replace into `wp_posts` values('162','1','2013-03-15 20:48:36','2013-03-15 12:48:36','<p>有时候看代码需要总结，这个类之间的关系很复杂，懒得有手写，就想用一点工具来自动生成。于是就找了找Python的UML工具，至于什么是UML，随便一查就知道了。具体需求正如以下这哥们所说：</p>\n\n<blockquote>\n  <p>随着项目进展，类越来越多，原来做总体设计的时候没有想到有这么复杂的情况:(。现在我想画出uml图来反映各个类之间的关系。</p>\n</blockquote>\n\n<p>于是找了下，有这么些工具：</p>\n\n<h2>1 Ecplise插件pyuml</h2>\n\n<h2>2 Python UML Tool</h2>\n\n<p>在http://sourceforge.net/projects/pyut/上找到的，版不过版本确实比较老了，最后更新是09年的。</p>\n\n<h2>3 Pynsource</h2>\n\n<p><a href=\"http://www.andypatterns.com/index.php/products/pynsource/\">项目主页</a></p>\n\n<p><a href=\"https://code.google.com/p/pynsource/downloads/list\">下载</a></p>\n\n<h2>4 Gaphor</h2>\n\n<p>sourceforge.net/projects/gaphor/</p>\n\n<h2>Dia</h2>\n\n<p>Dia是基于GTK的图形绘制程序，适用于Linux, Unix和Window\n  DIA软件启动界面\ns，以 GPL 许可发布。通俗的说，一个10MB量级的免费软件，代替visio基本没问题，被收入了“最好的300款免费软件”。也有些用户认为Dia很多地方不太好用，但无论如何，它是综合性能最高的免费解决方案。</p>\n\n<h2>参考文章</h2>\n\n<p>http://imtx.me/archives/155.html</p>\n','UML Tools For Python','','inherit','open','open','','161-revision','','','2013-03-15 20:48:36','2013-03-15 12:48:36','','161','http://blog.wachang.net/2013/03/161-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('163','1','2013-03-15 20:55:42','2013-03-15 12:55:42','<p>有时候看代码需要总结，这个类之间的关系很复杂，懒得有手写，就想用一点工具来自动生成。于是就找了找Python的UML工具，至于什么是UML，随便一查就知道了。具体需求正如以下这哥们所说：</p>\n\n<blockquote>\n  <p>随着项目进展，类越来越多，原来做总体设计的时候没有想到有这么复杂的情况:(。现在我想画出uml图来反映各个类之间的关系。</p>\n</blockquote>\n\n<p>于是找了下，有这么些工具：</p>\n\n<h2>1 Ecplise插件pyuml</h2>\n\n<h2>2 Python UML Tool</h2>\n\n<p>在http://sourceforge.net/projects/pyut/上找到的，版不过版本确实比较老了，最后更新是09年的。</p>\n\n<h2>3 Pynsource</h2>\n\n<p><a href=\"http://www.andypatterns.com/index.php/products/pynsource/\">项目主页</a></p>\n\n<p><a href=\"https://code.google.com/p/pynsource/downloads/list\">下载</a></p>\n\n<p>使用上比较方便，导入python文件后就可以自动生成相应的类关系，特别是支持把关系转换成asic表，这个我就喜欢！</p>\n\n<h2>4 Gaphor</h2>\n\n<p>sourceforge.net/projects/gaphor/</p>\n\n<h2>Dia</h2>\n\n<p>Dia是基于GTK的图形绘制程序，适用于Linux, Unix和Window DIA软件启动界面 s，以 GPL 许可发布。通俗的说，一个10MB量级的免费软件，代替visio基本没问题，被收入了“最好的300款免费软件”。也有些用户认为Dia很多地方不太好用，但无论如何，它是综合性能最高的免费解决方案。</p>\n\n<h2>参考文章</h2>\n\n<p>http://imtx.me/archives/155.html</p>\n','UML Tools For Python','','inherit','open','open','','161-revision-2','','','2013-03-15 20:55:42','2013-03-15 12:55:42','','161','http://blog.wachang.net/2013/03/161-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('164','1','2013-03-15 21:08:21','2013-03-15 13:08:21','<p>有时候看代码需要总结，这个类之间的关系很复杂，懒得有手写，就想用一点工具来自动生成。于是就找了找Python的UML工具，至于什么是UML，随便一查就知道了。具体需求正如以下这哥们所说：</p>\n\n<blockquote>\n  <p>随着项目进展，类越来越多，原来做总体设计的时候没有想到有这么复杂的情况:(。现在我想画出uml图来反映各个类之间的关系。</p>\n</blockquote>\n\n<p>于是找了下，有这么些工具：</p>\n\n<h2>1 Ecplise插件pyuml</h2>\n\n<h2>2 Python UML Tool</h2>\n\n<p>在http://sourceforge.net/projects/pyut/上找到的，版不过版本确实比较老了，最后更新是09年的。</p>\n\n<h2>3 Pynsource</h2>\n\n<p><a href=\"http://www.andypatterns.com/index.php/products/pynsource/\">项目主页</a></p>\n\n<p><a href=\"https://code.google.com/p/pynsource/downloads/list\">下载</a></p>\n\n<p>使用上比较方便，导入python文件后就可以自动生成相应的类关系，特别是支持把关系转换成asic表，这个我就喜欢！</p>\n\n<h2>4 Gaphor</h2>\n\n<p>sourceforge.net/projects/gaphor/</p>\n\n<h2>Dia</h2>\n\n<p>Dia是基于GTK的图形绘制程序，适用于Linux, Unix和Window DIA软件启动界面 s，以 GPL 许可发布。通俗的说，一个10MB量级的免费软件，代替visio基本没问题，被收入了“最好的300款免费软件”。也有些用户认为Dia很多地方不太好用，但无论如何，它是综合性能最高的免费解决方案。</p>\n\n<h2>参考文章</h2>\n\n<p>http://imtx.me/archives/155.html</p>\n\n<p>http://www.cnblogs.com/dkblog/archive/2011/05/06/2039124.html</p>\n\n<p>http://www.blogjava.net/xiaohuzi2008/archive/2012/12/25/393463.html</p>\n\n<p>http://blog.chinaunix.net/uid-20446794-id-1677395.html</p>\n\n<p>http://tgic.me/2010/02/05/%E8%A7%A3%E5%86%B3-gaphor-uml-%E4%B8%8D%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E7%9A%84%E9%97%AE%E9%A2%98/</p>\n\n<p>https://cacoo.com</p>\n','UML Tools For Python','','inherit','open','open','','161-revision-3','','','2013-03-15 21:08:21','2013-03-15 13:08:21','','161','http://blog.wachang.net/2013/03/161-revision-3/','0','revision','','0');");
E_D("replace into `wp_posts` values('165','1','2013-03-19 14:48:10','2013-03-19 06:48:10','<p>OpenvSwitch配置GRE隧道另外一个比较有用的地方就是在OpenFlow环境中通过GRE隧道连接两个Switch，从而实现多个单独OpenFlow网络的互通。这在做实验的环境下还是非常有用的。</p>\n\n<ul>\n<li>OpenvSwitch gre隧道配置</li>\n</ul>\n\n<p>文章地址：<a href=\"https://github.com/PeerXu/blog/blob/master/_posts/2013-1-15-open-vswitch-gre-tunnel-configuration.md\">https://github.com/PeerXu/blog/blob/master/_posts/2013-1-15-open-vswitch-gre-tunnel-configuration.md</a></p>\n\n<p>本地下载：[wpdm_file id=1]</p>\n\n<!--more-->\n\n<ul>\n<li>Open vSwitch的GRE Tunnel配置</li>\n</ul>\n\n<p>这个文章同样也是用GRE来连接两个OpenFlow网络，不过讲的更详细一点，原文文档可以点下面的连接下载，做一点笔记~</p>\n\n<p>感觉这个的配置稍微有点复杂啊</p>\n\n<p>文章地址:<a href=\"http://kimi4ysr.me/?p=251\">http://kimi4ysr.me/?p=251</a></p>\n\n<p>本地下载：[wpdm_file id=2]</p>\n\n<p>一点参考文章：</p>\n\n<p><a href=\"http://networkstatic.net/open-vswitch-gre-tunnel-configuration/\">http://networkstatic.net/open-vswitch-gre-tunnel-configuration/</a></p>\n\n<p><a href=\"http://networkstatic.net/openvswitch-and-gre-tunnel-notes/\">http://networkstatic.net/openvswitch-and-gre-tunnel-notes/</a></p>\n\n<p><a href=\"http://wangcong.org/blog/archives/2238\">http://wangcong.org/blog/archives/2238</a></p>\n','也谈OpenvSwitch配置GRE隧道（二）','','publish','open','open','','openvswitch-configure-gre-note-2','','http://networkstatic.net/open-vswitch-gre-tunnel-configuration/\nhttp://kimi4ysr.me/?p=251\nhttp://kimi4ysr.me/?p=251\nhttp://networkstatic.net/openvswitch-and-gre-tunnel-notes/','2013-03-19 15:19:21','2013-03-19 07:19:21','','0','http://blog.wachang.net/?p=165','0','post','','0');");
E_D("replace into `wp_posts` values('166','1','2013-03-19 14:38:30','2013-03-19 06:38:30','<p>OpenvSwitch配置GRE隧道另外一个比较有用的地方就是在OpenFlow环境中通过GRE隧道连接两个Switch，从而实现多个单独OpenFlow网络的互通。这在做实验的环境下还是非常有用的。</p>\n\n<ul>\n<li>OpenvSwitch gre隧道配置</li>\n</ul>\n\n<p>文章地址：https://github.com/PeerXu/blog/blob/master/_posts/2013-1-15-open-vswitch-gre-tunnel-configuration.md</p>\n','也谈OpenvSwitch配置GRE隧道','','inherit','open','open','','165-revision','','','2013-03-19 14:38:30','2013-03-19 06:38:30','','165','http://blog.wachang.net/2013/03/165-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('167','1','2013-03-19 14:38:32','2013-03-19 06:38:32','<p>OpenvSwitch配置GRE隧道另外一个比较有用的地方就是在OpenFlow环境中通过GRE隧道连接两个Switch，从而实现多个单独OpenFlow网络的互通。这在做实验的环境下还是非常有用的。</p>\n\n<ul>\n<li>OpenvSwitch gre隧道配置</li>\n</ul>\n\n<p>文章地址：https://github.com/PeerXu/blog/blob/master/_posts/2013-1-15-open-vswitch-gre-tunnel-configuration.md</p>\n','也谈OpenvSwitch配置GRE隧道','','inherit','open','open','','165-revision-2','','','2013-03-19 14:38:32','2013-03-19 06:38:32','','165','http://blog.wachang.net/2013/03/165-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('168','1','2013-03-19 14:45:06','2013-03-19 06:45:06','<p>OpenvSwitch配置GRE隧道另外一个比较有用的地方就是在OpenFlow环境中通过GRE隧道连接两个Switch，从而实现多个单独OpenFlow网络的互通。这在做实验的环境下还是非常有用的。</p>\n\n<ul>\n<li>OpenvSwitch gre隧道配置</li>\n</ul>\n\n<p>文章地址：https://github.com/PeerXu/blog/blob/master/_posts/2013-1-15-open-vswitch-gre-tunnel-configuration.md</p>\n\n<p>[wpdm_file id=1]</p>\n','也谈OpenvSwitch配置GRE隧道','','inherit','open','open','','165-revision-3','','','2013-03-19 14:45:06','2013-03-19 06:45:06','','165','http://blog.wachang.net/2013/03/165-revision-3/','0','revision','','0');");
E_D("replace into `wp_posts` values('169','1','2013-03-19 15:16:53','2013-03-19 07:16:53','<p>OpenvSwitch配置GRE隧道另外一个比较有用的地方就是在OpenFlow环境中通过GRE隧道连接两个Switch，从而实现多个单独OpenFlow网络的互通。这在做实验的环境下还是非常有用的。</p>\n\n<ul>\n<li>OpenvSwitch gre隧道配置</li>\n</ul>\n\n<p>文章地址：<a href=\"https://github.com/PeerXu/blog/blob/master/_posts/2013-1-15-open-vswitch-gre-tunnel-configuration.md\">https://github.com/PeerXu/blog/blob/master/_posts/2013-1-15-open-vswitch-gre-tunnel-configuration.md</a></p>\n\n<p>本地下载：[wpdm_file id=1]</p>\n\n<ul>\n<li>Open vSwitch的GRE Tunnel配置</li>\n</ul>\n\n<p>这个文章同样也是用GRE来连接两个OpenFlow网络，不过讲的更详细一点，原文文档可以点下面的连接下载，做一点笔记~</p>\n\n<p>感觉这个的配置稍微有点复杂啊</p>\n\n<p>文章地址:<a href=\"http://kimi4ysr.me/?p=251\">http://kimi4ysr.me/?p=251</a></p>\n\n<p>本地下载：[wpdm_file id=2]</p>\n','也谈OpenvSwitch配置GRE隧道','','inherit','open','open','','165-autosave','','','2013-03-19 15:16:53','2013-03-19 07:16:53','','165','http://blog.wachang.net/2013/03/165-autosave/','0','revision','','0');");
E_D("replace into `wp_posts` values('170','1','2013-03-19 14:48:10','2013-03-19 06:48:10','<p>OpenvSwitch配置GRE隧道另外一个比较有用的地方就是在OpenFlow环境中通过GRE隧道连接两个Switch，从而实现多个单独OpenFlow网络的互通。这在做实验的环境下还是非常有用的。</p>\n\n<ul>\n<li>OpenvSwitch gre隧道配置</li>\n</ul>\n\n<p>文章地址：<a href=\"https://github.com/PeerXu/blog/blob/master/_posts/2013-1-15-open-vswitch-gre-tunnel-configuration.md\">https://github.com/PeerXu/blog/blob/master/_posts/2013-1-15-open-vswitch-gre-tunnel-configuration.md</a></p>\n\n<p>本地下载：[wpdm_file id=1]</p>\n','也谈OpenvSwitch配置GRE隧道','','inherit','open','open','','165-revision-4','','','2013-03-19 14:48:10','2013-03-19 06:48:10','','165','http://blog.wachang.net/2013/03/165-revision-4/','0','revision','','0');");
E_D("replace into `wp_posts` values('171','1','2013-03-19 15:17:47','2013-03-19 07:17:47','<p>OpenvSwitch配置GRE隧道另外一个比较有用的地方就是在OpenFlow环境中通过GRE隧道连接两个Switch，从而实现多个单独OpenFlow网络的互通。这在做实验的环境下还是非常有用的。</p>\n\n<ul>\n<li>OpenvSwitch gre隧道配置</li>\n</ul>\n\n<p>文章地址：<a href=\"https://github.com/PeerXu/blog/blob/master/_posts/2013-1-15-open-vswitch-gre-tunnel-configuration.md\">https://github.com/PeerXu/blog/blob/master/_posts/2013-1-15-open-vswitch-gre-tunnel-configuration.md</a></p>\n\n<p>本地下载：[wpdm_file id=1]</p>\n\n<!--more-->\n\n<ul>\n<li>Open vSwitch的GRE Tunnel配置</li>\n</ul>\n\n<p>这个文章同样也是用GRE来连接两个OpenFlow网络，不过讲的更详细一点，原文文档可以点下面的连接下载，做一点笔记~</p>\n\n<p>感觉这个的配置稍微有点复杂啊</p>\n\n<p>文章地址:<a href=\"http://kimi4ysr.me/?p=251\">http://kimi4ysr.me/?p=251</a></p>\n\n<p>本地下载：[wpdm_file id=2]</p>\n\n<p>一点参考文章：</p>\n\n<p><a href=\"http://networkstatic.net/open-vswitch-gre-tunnel-configuration/\">http://networkstatic.net/open-vswitch-gre-tunnel-configuration/</a></p>\n','也谈OpenvSwitch配置GRE隧道（二）','','inherit','open','open','','165-revision-5','','','2013-03-19 15:17:47','2013-03-19 07:17:47','','165','http://blog.wachang.net/2013/03/165-revision-5/','0','revision','','0');");
E_D("replace into `wp_posts` values('172','1','2013-03-19 23:25:28','2013-03-19 15:25:28','<blockquote>\n  <p>本文主要是我学习IETF文档NVGRE: Network Virtualization using Generic Routing Encapsulation的一个笔记。版本是02.文档地址：<a href=\"http://tools.ietf.org/html/draft-sridharan-virtualization-nvgre-02\">http://tools.ietf.org/html/draft-sridharan-virtualization-nvgre-02</a>，文末是文档的本地PDF下载。这个文档主要讲的事如何用GRE协议来实现网络虚拟化。相关的定义就是NVGRE协议。</p>\n</blockquote>\n\n<h2>1. Introduction</h2>\n\n<p>传统数据中心的规模很大，因为是在二层，所以在资源动态分配和容量上有局限，于是RSTP（Rapid Spanning Tree Protocol）协议能很好的解决冗余阻塞环路的问题，但是优惠造成网络容量的浪费以及网络超额，于是像TRILL协议等又被提出解决这个问题。</p>\n\n<p>因为使用了VLAN技术来做广播隔离，网络的利用率其实很低。VLAN既作为流量控制的手段，也作为租户之间服务安全的保证，于是2层网络就被切割成许多小的子网，通常一个子网有一个VLAN ID，但是VLAN ID又有4K的限制，数量太少。于是下一代数据中心网络就要考虑到以下问题：</p>\n\n<ul>\n<li>逻辑L2 L3网络的扩展 </li>\n<li>当各种服务在DC中移动的时候要保护地址信息，或者L2段</li>\n<li>提供广播隔离</li>\n</ul>\n\n<p>于是，提出了一个NVGRE。</p>\n\n<!--more-->\n\n<h2>3. Network Virtualization using GRE</h2>\n\n<p>网络虚拟化Network Virtualization包括：在实际的L2/L3网络中创建虚拟的L2/L3网络拓扑。那么虚拟拓扑之间的通信，就是通过把虚拟拓扑产生的以太帧封装的实际网络的IP中，（隧道技术），那么，有一些定义：</p>\n\n<p>没一个虚拟L2网络有一个24bit的标示符identifier，叫做Virtual Subnet Identifier (VSID，24bit足够1600万个虚拟subnet同时处在一个管理与上。一个VSID可以认为是一个广播域，有点类似VLAN ID。这个VSID在隧道封装中是可以作为头部信息的。</p>\n\n<p>GRE这个协议是IETF RFC 2784提出的，特点就是<code>可以把任意协议封装到IP上</code>。而NVGRE补充了GRE协议，使得在每个包中药携带一个VSID的信息。</p>\n\n<h3>3.1. NVGRE Endpoint</h3>\n\n<p>NVGRE Endpoint就是在虚拟网络和实际网络之间出入的端点，任意屋里服务器或者网络设备都可以作为NVGRE Endpoint。但是在实际中常见的是<code>作为hypervisor</code>的一部分。endpoint主要功能有以下：</p>\n\n<ul>\n<li>封装以太帧到GRE设备/从GRE设备解封出以太帧</li>\n<li>可以作为一个虚拟拓扑的网关</li>\n</ul>\n\n<p>为了封装以太帧，endpoint需要知道帧中目的地址的位置信息，这个地址可以通过管理层分配，本文档假设位置信息，包括VSID，在NVGRE endpoint是存在的。</p>\n\n<h3>3.2. NVGRE frame format</h3>\n\n<p>RFC 2784 RFC 2890中GRE头部的定义被用来在 NVGRE endpoints间通信。 NVGRE 扩展了头部信息，加入了VSID，GRE中二层包封装的格式如下，注意，从上往下看，就是整个数据的从外到内看：</p>\n\n<p>首先，在网络中实际传输的MAC帧的格式 Outer Ethernet Header:</p>\n\n<pre><code>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                (Outer) Destination MAC Address                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|(Outer)Destination MAC Address |  (Outer)Source MAC Address    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                  (Outer) Source MAC Address                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Optional Ethertype=C-Tag 802.1Q| Outer VLAN Tag Information    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre>\n\n<p>其次，剥掉上面一层，则是网络中传输的IP报文的格式：</p>\n\n<p>Outer IPv4 Header:</p>\n\n<pre><code>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Version|  IHL  |Type of Service|          Total Length         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Identification        |Flags|      Fragment Offset    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Time to Live | Protocol 0x2F |         Header Checksum       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      (Outer) Source Address                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                  (Outer) Destination Address                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre>\n\n<p>剥掉上面一层，则是NVGRE Header：</p>\n\n<pre><code>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0| |1|0| Reserved0       | Ver |   Protocol Type 0x6558        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               Virtual Subnet ID (VSID)        |   Reserved    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre>\n\n<p>剥掉GRE头信息，则是相应的虚拟拓扑的信息，也就是原始需要通信端点的信息 Inner Ethernet Header：</p>\n\n<pre><code>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                (Inner) Destination MAC Address                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|(Inner)Destination MAC Address |  (Inner)Source MAC Address    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                  (Inner) Source MAC Address                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Optional Ethertype=C-Tag 802.1Q| PCP |0| VID set to 0          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       Ethertype 0x0800        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre>\n\n<p>最后，才是原始的IP层信息 Inner IPv4 Header:</p>\n\n<pre><code>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Version|  IHL  |Type of Service|          Total Length         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Identification        |Flags|      Fragment Offset    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Time to Live |    Protocol   |         Header Checksum       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Source Address                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Destination Address                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Options                    |    Padding    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Original IP Payload                      |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre>\n\n<p>有一个解释，这个我好好翻译下：</p>\n\n<ul>\n<li>The outer Ethernet header：源地址是NVGRE endpoint（一个物理设备或者虚拟的设备）的MAC地址，目的地址是吓一跳指定节点，也是一个NVGRE endpoint节点的MAC地址。VLAN可以让这个帧跨越子网的。</li>\n<li>The outer IP header:就是上一层的IP层地址信息。</li>\n<li>C (Checksum Present)和S (Sequence Number Present)必须为0</li>\n<li>The K bit (Key Present) 32bit，NVGRE用这个key来携带VSID.</li>\n</ul>\n\n<p>具体来说32bit的key值，钱24bit用来携带VSID，后8bit用来携带一个FlowID，这个可以用来在VS中进一步划分流。</p>\n\n<ul>\n<li><p>GRE头信息中，协议类型0x6558，(transparent Ethernet bridging)</p></li>\n<li><p>在GRE中不仅仅能封装IP层，其他层都可以，NVGRE也是一样。</p></li>\n</ul>\n\n<h2>4 广播和多播</h2>\n\n<p>传统来说，像GRE这种点到点的tunnel是不能支持多播和广播的，NVGRE提出一个思想，就是为每一个subnet，或者说VSID所表示的虚拟网络指定一个广播和多播地址，从而解决这个问题。</p>\n\n<h3>4.2. Unicast Traffic 这段话很重要</h3>\n\n<p>NVGRE endpoint在GRE中封装2层报文，source PA（packet address）是这个endpoint的地址，而destination PA则是相应的对端endpoint地址。一个endpoint可以有多个地址，就有一个策略来选择是使用哪个地址，经过GRE封装以后，<code>The encapsulated GRE packet is bridged and routed normally by the physical network to the destination.</code>以及<code>On the destination the NVGRE endpoint decapsulates the GRE packet to recover the original Layer-2 frame.</code></p>\n\n<h3>4.3. IP Fragmentation</h3>\n\n<p>在IP中，长的IP报文是有一个分段的，那么NVGRE这种是IP报文进行了一次封装，就最好不要分段，再一下草案中可能会提出解决分段的机制。</p>\n\n<h3>4.4. Address/Policy Management &amp; Routing</h3>\n\n<h3>4.5. Cross-subnet, Cross-premise Communication</h3>\n\n<p>主要是一个VPN gateway，建立一个site-to-site的隧道，注意不是端到端的。从而使得交叉的subnets之间可以通信。如下图：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/nvgre-cross-subnets.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/nvgre-cross-subnets.jpg\" alt=\"nvgre-cross-subnets\" width=\"633\" height=\"747\" class=\"aligncenter size-full wp-image-178\" /></a></p>\n','NVGRE: Network Virtualization using Generic Routing Encapsulation','','publish','open','open','','nvgre-network-virtualization-using-generic-routing-encapsulation','','','2013-03-19 23:27:24','2013-03-19 15:27:24','','0','http://blog.wachang.net/?p=172','0','post','','0');");
E_D("replace into `wp_posts` values('173','1','2013-03-19 16:06:54','2013-03-19 08:06:54','<blockquote>\n  <p>本文主要是我学习IETF文档NVGRE: Network Virtualization using Generic Routing Encapsulation的一个笔记。版本是02.文档地址：<a href=\"http://tools.ietf.org/html/draft-sridharan-virtualization-nvgre-02\">http://tools.ietf.org/html/draft-sridharan-virtualization-nvgre-02</a>，文末是文档的本地PDF下载。这个文档主要讲的事如何用GRE协议来实现网络虚拟化。相关的定义就是NVGRE协议。</p>\n</blockquote>\n\n<h2>1. Introduction</h2>\n\n<p>传统数据中心的规模很大，因为是在二层，所以在资源动态分配和容量上有局限，于是RSTP（Rapid Spanning Tree Protocol）协议能很好的解决冗余阻塞环路的问题，但是优惠造成网络容量的浪费以及网络超额，于是像TRILL协议等又被提出解决这个问题。</p>\n\n<p>因为使用了VLAN技术来做广播隔离，网络的利用率其实很低。VLAN既作为流量控制的手段，也作为租户之间服务安全的保证，于是2层网络就被切割成许多小的子网，通常一个子网有一个VLAN ID，但是VLAN ID又有4K的限制，数量太少。于是下一代数据中心网络就要考虑到以下问题：</p>\n\n<ul>\n<li>逻辑L2 L3网络的扩展 </li>\n<li>当各种服务在DC中移动的时候要保护地址信息，或者L2段</li>\n<li>提供广播隔离</li>\n</ul>\n\n<p>于是，提出了一个NVGRE。</p>\n\n<h2>3. Network Virtualization using GRE</h2>\n\n<p>网络虚拟化Network Virtualization包括：在实际的L2/L3网络中创建虚拟的L2/L3网络拓扑。那么虚拟拓扑之间的通信，就是通过把虚拟拓扑产生的以太帧封装的实际网络的IP中，（隧道技术），那么，有一些定义：</p>\n\n<p>没一个虚拟L2网络有一个24bit的标示符identifier，叫做Virtual Subnet Identifier (VSID，24bit足够1600万个虚拟subnet同时处在一个管理与上。一个VSID可以认为是一个广播域，有点类似VLAN ID。这个VSID在隧道封装中是可以作为头部信息的。</p>\n\n<p>GRE这个协议是IETF RFC 2784提出的，特点就是<code>可以把任意协议封装到IP上</code>。而NVGRE补充了GRE协议，使得在每个包中药携带一个VSID的信息。</p>\n\n<h3>3.1. NVGRE Endpoint</h3>\n\n<p>NVGRE Endpoint就是在虚拟网络和实际网络之间出入的端点，任意屋里服务器或者网络设备都可以作为NVGRE Endpoint。但是在实际中常见的</p>\n','NVGRE: Network Virtualization using Generic Routing Encapsulation','','inherit','open','open','','172-revision','','','2013-03-19 16:06:54','2013-03-19 08:06:54','','172','http://blog.wachang.net/2013/03/172-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('174','1','2013-03-19 21:36:50','2013-03-19 13:36:50','<blockquote>\n  <p>本文主要是我学习IETF文档NVGRE: Network Virtualization using Generic Routing Encapsulation的一个笔记。版本是02.文档地址：<a href=\"http://tools.ietf.org/html/draft-sridharan-virtualization-nvgre-02\">http://tools.ietf.org/html/draft-sridharan-virtualization-nvgre-02</a>，文末是文档的本地PDF下载。这个文档主要讲的事如何用GRE协议来实现网络虚拟化。相关的定义就是NVGRE协议。</p>\n</blockquote>\n\n<h2>1. Introduction</h2>\n\n<p>传统数据中心的规模很大，因为是在二层，所以在资源动态分配和容量上有局限，于是RSTP（Rapid Spanning Tree Protocol）协议能很好的解决冗余阻塞环路的问题，但是优惠造成网络容量的浪费以及网络超额，于是像TRILL协议等又被提出解决这个问题。</p>\n\n<p>因为使用了VLAN技术来做广播隔离，网络的利用率其实很低。VLAN既作为流量控制的手段，也作为租户之间服务安全的保证，于是2层网络就被切割成许多小的子网，通常一个子网有一个VLAN ID，但是VLAN ID又有4K的限制，数量太少。于是下一代数据中心网络就要考虑到以下问题：</p>\n\n<ul>\n<li>逻辑L2 L3网络的扩展 </li>\n<li>当各种服务在DC中移动的时候要保护地址信息，或者L2段</li>\n<li>提供广播隔离</li>\n</ul>\n\n<p>于是，提出了一个NVGRE。</p>\n\n<h2>3. Network Virtualization using GRE</h2>\n\n<p>网络虚拟化Network Virtualization包括：在实际的L2/L3网络中创建虚拟的L2/L3网络拓扑。那么虚拟拓扑之间的通信，就是通过把虚拟拓扑产生的以太帧封装的实际网络的IP中，（隧道技术），那么，有一些定义：</p>\n\n<p>没一个虚拟L2网络有一个24bit的标示符identifier，叫做Virtual Subnet Identifier (VSID，24bit足够1600万个虚拟subnet同时处在一个管理与上。一个VSID可以认为是一个广播域，有点类似VLAN ID。这个VSID在隧道封装中是可以作为头部信息的。</p>\n\n<p>GRE这个协议是IETF RFC 2784提出的，特点就是<code>可以把任意协议封装到IP上</code>。而NVGRE补充了GRE协议，使得在每个包中药携带一个VSID的信息。</p>\n\n<h3>3.1. NVGRE Endpoint</h3>\n\n<p>NVGRE Endpoint就是在虚拟网络和实际网络之间出入的端点，任意屋里服务器或者网络设备都可以作为NVGRE Endpoint。但是在实际中常见的是<code>作为hypervisor</code>的一部分。endpoint主要功能有以下：</p>\n\n<ul>\n<li>封装以太帧到GRE设备/从GRE设备解封出以太帧</li>\n<li>可以作为一个虚拟拓扑的网关</li>\n</ul>\n\n<p>为了封装以太帧，endpoint需要知道帧中目的地址的位置信息，这个地址可以通过管理层分配，本文档假设位置信息，包括VSID，在NVGRE endpoint是存在的。</p>\n\n<h3>3.2. NVGRE frame format</h3>\n\n<p>RFC 2784 RFC 2890中GRE头部的定义被用来在 NVGRE endpoints间通信。 NVGRE 扩展了头部信息，加入了VSID，GRE中二层包封装的格式如下，注意，从上往下看，就是整个数据的从外到内看：</p>\n\n<p>首先，在网络中实际传输的MAC帧的格式 Outer Ethernet Header:</p>\n\n<pre><code>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                (Outer) Destination MAC Address                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|(Outer)Destination MAC Address |  (Outer)Source MAC Address    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                  (Outer) Source MAC Address                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Optional Ethertype=C-Tag 802.1Q| Outer VLAN Tag Information    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre>\n\n<p>其次，剥掉上面一层，则是网络中传输的IP报文的格式：</p>\n\n<p>Outer IPv4 Header:</p>\n\n<pre><code>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Version|  IHL  |Type of Service|          Total Length         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Identification        |Flags|      Fragment Offset    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Time to Live | Protocol 0x2F |         Header Checksum       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      (Outer) Source Address                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                  (Outer) Destination Address                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre>\n\n<p>剥掉上面一层，则是NVGRE Header：</p>\n\n<pre><code>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0| |1|0| Reserved0       | Ver |   Protocol Type 0x6558        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               Virtual Subnet ID (VSID)        |   Reserved    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre>\n\n<p>剥掉GRE头信息，则是相应的虚拟拓扑的信息，也就是原始需要通信端点的信息 Inner Ethernet Header：</p>\n\n<pre><code>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                (Inner) Destination MAC Address                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|(Inner)Destination MAC Address |  (Inner)Source MAC Address    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                  (Inner) Source MAC Address                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Optional Ethertype=C-Tag 802.1Q| PCP |0| VID set to 0          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       Ethertype 0x0800        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre>\n\n<p>最后，才是原始的IP层信息 Inner IPv4 Header:</p>\n\n<pre><code>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Version|  IHL  |Type of Service|          Total Length         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Identification        |Flags|      Fragment Offset    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Time to Live |    Protocol   |         Header Checksum       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Source Address                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Destination Address                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Options                    |    Padding    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Original IP Payload                      |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre>\n\n<p>有一个解释，这个我好好翻译下：</p>\n\n<ul>\n<li>The outer Ethernet header：源地址是NVGRE endpoint（一个物理设备或者虚拟的设备）的MAC地址，目的地址是吓一跳指定节点，也是一个NVGRE endpoint节点的MAC地址。VLAN可以让这个帧跨越子网的。</li>\n<li>The outer IP header:就是上一层的IP层地址信息。</li>\n<li>C (Checksum Present)和S (Sequence Number Present)必须为0</li>\n<li>The K bit (Key Present) 32bit，NVGRE用这个key来携带VSID.</li>\n</ul>\n\n<p>具体来说32bit的key值，钱24bit用来携带VSID，后8bit用来携带一个FlowID，这个可以用来在VS中进一步划分流。</p>\n\n<ul>\n<li><p>GRE头信息中，协议类型0x6558，(transparent Ethernet bridging)</p></li>\n<li><p>在GRE中不仅仅能封装IP层，其他层都可以，NVGRE也是一样。</p></li>\n</ul>\n','NVGRE: Network Virtualization using Generic Routing Encapsulation','','inherit','open','open','','172-revision-2','','','2013-03-19 21:36:50','2013-03-19 13:36:50','','172','http://blog.wachang.net/2013/03/172-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('175','1','2013-03-19 22:11:33','0000-00-00 00:00:00','','自动草稿','','auto-draft','open','open','','','','','2013-03-19 22:11:33','0000-00-00 00:00:00','','0','http://blog.wachang.net/?page_id=175','0','page','','0');");
E_D("replace into `wp_posts` values('176','1','2013-03-19 22:27:40','2013-03-19 14:27:40','','EHO ARCH','','inherit','open','open','','eho-arch','','','2013-03-19 22:27:40','2013-03-19 14:27:40','','159','http://blog.wachang.net/wp-content/uploads/2013/03/EHO-ARCH.jpg','0','attachment','image/jpeg','0');");
E_D("replace into `wp_posts` values('177','1','2013-03-19 22:28:17','2013-03-19 14:28:17','<p>今天看到mirantis把hadoop和openstack进行了一个集成，提出了一个EHO系统，从架构上看还是很有意思的。对于我做过OpenStack开发的话，还是蛮有收获。重点是EHO现在的文档做的相当好，就很有参考价值了。</p>\n\n<p>主页：<a href=\"http://eho.mirantis.com/index.html\">http://eho.mirantis.com/index.html</a></p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/EHO-ARCH.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/EHO-ARCH.jpg\" alt=\"EHO ARCH\" width=\"787\" height=\"453\" class=\"aligncenter size-full wp-image-176\" /></a></p>\n','Mirantis-Elastic Hadoop on OpenStack','','inherit','open','open','','159-revision-2','','','2013-03-19 22:28:17','2013-03-19 14:28:17','','159','http://blog.wachang.net/2013/03/159-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('178','1','2013-03-19 23:22:17','2013-03-19 15:22:17','','nvgre-cross-subnets','','inherit','open','open','','nvgre-cross-subnets','','','2013-03-19 23:22:17','2013-03-19 15:22:17','','172','http://blog.wachang.net/wp-content/uploads/2013/03/nvgre-cross-subnets.jpg','0','attachment','image/jpeg','0');");
E_D("replace into `wp_posts` values('179','1','2013-03-19 23:23:06','2013-03-19 15:23:06','<blockquote>\n  <p>本文主要是我学习IETF文档NVGRE: Network Virtualization using Generic Routing Encapsulation的一个笔记。版本是02.文档地址：<a href=\"http://tools.ietf.org/html/draft-sridharan-virtualization-nvgre-02\">http://tools.ietf.org/html/draft-sridharan-virtualization-nvgre-02</a>，文末是文档的本地PDF下载。这个文档主要讲的事如何用GRE协议来实现网络虚拟化。相关的定义就是NVGRE协议。</p>\n</blockquote>\n\n<h2>1. Introduction</h2>\n\n<p>传统数据中心的规模很大，因为是在二层，所以在资源动态分配和容量上有局限，于是RSTP（Rapid Spanning Tree Protocol）协议能很好的解决冗余阻塞环路的问题，但是优惠造成网络容量的浪费以及网络超额，于是像TRILL协议等又被提出解决这个问题。</p>\n\n<p>因为使用了VLAN技术来做广播隔离，网络的利用率其实很低。VLAN既作为流量控制的手段，也作为租户之间服务安全的保证，于是2层网络就被切割成许多小的子网，通常一个子网有一个VLAN ID，但是VLAN ID又有4K的限制，数量太少。于是下一代数据中心网络就要考虑到以下问题：</p>\n\n<ul>\n<li>逻辑L2 L3网络的扩展 </li>\n<li>当各种服务在DC中移动的时候要保护地址信息，或者L2段</li>\n<li>提供广播隔离</li>\n</ul>\n\n<p>于是，提出了一个NVGRE。</p>\n\n<h2>3. Network Virtualization using GRE</h2>\n\n<p>网络虚拟化Network Virtualization包括：在实际的L2/L3网络中创建虚拟的L2/L3网络拓扑。那么虚拟拓扑之间的通信，就是通过把虚拟拓扑产生的以太帧封装的实际网络的IP中，（隧道技术），那么，有一些定义：</p>\n\n<p>没一个虚拟L2网络有一个24bit的标示符identifier，叫做Virtual Subnet Identifier (VSID，24bit足够1600万个虚拟subnet同时处在一个管理与上。一个VSID可以认为是一个广播域，有点类似VLAN ID。这个VSID在隧道封装中是可以作为头部信息的。</p>\n\n<p>GRE这个协议是IETF RFC 2784提出的，特点就是<code>可以把任意协议封装到IP上</code>。而NVGRE补充了GRE协议，使得在每个包中药携带一个VSID的信息。</p>\n\n<h3>3.1. NVGRE Endpoint</h3>\n\n<p>NVGRE Endpoint就是在虚拟网络和实际网络之间出入的端点，任意屋里服务器或者网络设备都可以作为NVGRE Endpoint。但是在实际中常见的是<code>作为hypervisor</code>的一部分。endpoint主要功能有以下：</p>\n\n<ul>\n<li>封装以太帧到GRE设备/从GRE设备解封出以太帧</li>\n<li>可以作为一个虚拟拓扑的网关</li>\n</ul>\n\n<p>为了封装以太帧，endpoint需要知道帧中目的地址的位置信息，这个地址可以通过管理层分配，本文档假设位置信息，包括VSID，在NVGRE endpoint是存在的。</p>\n\n<h3>3.2. NVGRE frame format</h3>\n\n<p>RFC 2784 RFC 2890中GRE头部的定义被用来在 NVGRE endpoints间通信。 NVGRE 扩展了头部信息，加入了VSID，GRE中二层包封装的格式如下，注意，从上往下看，就是整个数据的从外到内看：</p>\n\n<p>首先，在网络中实际传输的MAC帧的格式 Outer Ethernet Header:</p>\n\n<pre><code>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                (Outer) Destination MAC Address                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|(Outer)Destination MAC Address |  (Outer)Source MAC Address    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                  (Outer) Source MAC Address                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Optional Ethertype=C-Tag 802.1Q| Outer VLAN Tag Information    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre>\n\n<p>其次，剥掉上面一层，则是网络中传输的IP报文的格式：</p>\n\n<p>Outer IPv4 Header:</p>\n\n<pre><code>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Version|  IHL  |Type of Service|          Total Length         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Identification        |Flags|      Fragment Offset    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Time to Live | Protocol 0x2F |         Header Checksum       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      (Outer) Source Address                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                  (Outer) Destination Address                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre>\n\n<p>剥掉上面一层，则是NVGRE Header：</p>\n\n<pre><code>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0| |1|0| Reserved0       | Ver |   Protocol Type 0x6558        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               Virtual Subnet ID (VSID)        |   Reserved    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre>\n\n<p>剥掉GRE头信息，则是相应的虚拟拓扑的信息，也就是原始需要通信端点的信息 Inner Ethernet Header：</p>\n\n<pre><code>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                (Inner) Destination MAC Address                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|(Inner)Destination MAC Address |  (Inner)Source MAC Address    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                  (Inner) Source MAC Address                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Optional Ethertype=C-Tag 802.1Q| PCP |0| VID set to 0          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       Ethertype 0x0800        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre>\n\n<p>最后，才是原始的IP层信息 Inner IPv4 Header:</p>\n\n<pre><code>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Version|  IHL  |Type of Service|          Total Length         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Identification        |Flags|      Fragment Offset    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Time to Live |    Protocol   |         Header Checksum       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Source Address                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Destination Address                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Options                    |    Padding    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Original IP Payload                      |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre>\n\n<p>有一个解释，这个我好好翻译下：</p>\n\n<ul>\n<li>The outer Ethernet header：源地址是NVGRE endpoint（一个物理设备或者虚拟的设备）的MAC地址，目的地址是吓一跳指定节点，也是一个NVGRE endpoint节点的MAC地址。VLAN可以让这个帧跨越子网的。</li>\n<li>The outer IP header:就是上一层的IP层地址信息。</li>\n<li>C (Checksum Present)和S (Sequence Number Present)必须为0</li>\n<li>The K bit (Key Present) 32bit，NVGRE用这个key来携带VSID.</li>\n</ul>\n\n<p>具体来说32bit的key值，钱24bit用来携带VSID，后8bit用来携带一个FlowID，这个可以用来在VS中进一步划分流。</p>\n\n<ul>\n<li><p>GRE头信息中，协议类型0x6558，(transparent Ethernet bridging)</p></li>\n<li><p>在GRE中不仅仅能封装IP层，其他层都可以，NVGRE也是一样。</p></li>\n</ul>\n\n<h2>4 广播和多播</h2>\n\n<p>传统来说，像GRE这种点到点的tunnel是不能支持多播和广播的，NVGRE提出一个思想，就是为每一个subnet，或者说VSID所表示的虚拟网络指定一个广播和多播地址，从而解决这个问题。</p>\n\n<h3>4.2. Unicast Traffic 这段话很重要</h3>\n\n<p>NVGRE endpoint在GRE中封装2层报文，source PA（packet address）是这个endpoint的地址，而destination PA则是相应的对端endpoint地址。一个endpoint可以有多个地址，就有一个策略来选择是使用哪个地址，经过GRE封装以后，<code>The encapsulated GRE packet is bridged and routed normally by the physical network to the destination.</code>以及<code>On the destination the NVGRE endpoint decapsulates the GRE packet to recover the original Layer-2 frame.</code></p>\n\n<h3>4.3. IP Fragmentation</h3>\n\n<p>在IP中，长的IP报文是有一个分段的，那么NVGRE这种是IP报文进行了一次封装，就最好不要分段，再一下草案中可能会提出解决分段的机制。</p>\n\n<h3>4.4. Address/Policy Management &amp; Routing</h3>\n\n<h3>4.5. Cross-subnet, Cross-premise Communication</h3>\n\n<p>主要是一个VPN gateway，建立一个site-to-site的隧道，注意不是端到端的。从而使得交叉的subnets之间可以通信。如下图：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/nvgre-cross-subnets.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/nvgre-cross-subnets.jpg\" alt=\"nvgre-cross-subnets\" width=\"633\" height=\"747\" class=\"aligncenter size-full wp-image-178\" /></a></p>\n','NVGRE: Network Virtualization using Generic Routing Encapsulation','','inherit','open','open','','172-revision-3','','','2013-03-19 23:23:06','2013-03-19 15:23:06','','172','http://blog.wachang.net/2013/03/172-revision-3/','0','revision','','0');");
E_D("replace into `wp_posts` values('180','1','2013-03-19 23:25:28','2013-03-19 15:25:28','<blockquote>\n  <p>本文主要是我学习IETF文档NVGRE: Network Virtualization using Generic Routing Encapsulation的一个笔记。版本是02.文档地址：<a href=\"http://tools.ietf.org/html/draft-sridharan-virtualization-nvgre-02\">http://tools.ietf.org/html/draft-sridharan-virtualization-nvgre-02</a>，文末是文档的本地PDF下载。这个文档主要讲的事如何用GRE协议来实现网络虚拟化。相关的定义就是NVGRE协议。</p>\n</blockquote>\n\n<h2>1. Introduction</h2>\n\n<p>传统数据中心的规模很大，因为是在二层，所以在资源动态分配和容量上有局限，于是RSTP（Rapid Spanning Tree Protocol）协议能很好的解决冗余阻塞环路的问题，但是优惠造成网络容量的浪费以及网络超额，于是像TRILL协议等又被提出解决这个问题。</p>\n\n<p>因为使用了VLAN技术来做广播隔离，网络的利用率其实很低。VLAN既作为流量控制的手段，也作为租户之间服务安全的保证，于是2层网络就被切割成许多小的子网，通常一个子网有一个VLAN ID，但是VLAN ID又有4K的限制，数量太少。于是下一代数据中心网络就要考虑到以下问题：</p>\n\n<ul>\n<li>逻辑L2 L3网络的扩展 </li>\n<li>当各种服务在DC中移动的时候要保护地址信息，或者L2段</li>\n<li>提供广播隔离</li>\n</ul>\n\n<p>于是，提出了一个NVGRE。</p>\n\n<h2>3. Network Virtualization using GRE</h2>\n\n<p>网络虚拟化Network Virtualization包括：在实际的L2/L3网络中创建虚拟的L2/L3网络拓扑。那么虚拟拓扑之间的通信，就是通过把虚拟拓扑产生的以太帧封装的实际网络的IP中，（隧道技术），那么，有一些定义：</p>\n\n<p>没一个虚拟L2网络有一个24bit的标示符identifier，叫做Virtual Subnet Identifier (VSID，24bit足够1600万个虚拟subnet同时处在一个管理与上。一个VSID可以认为是一个广播域，有点类似VLAN ID。这个VSID在隧道封装中是可以作为头部信息的。</p>\n\n<p>GRE这个协议是IETF RFC 2784提出的，特点就是<code>可以把任意协议封装到IP上</code>。而NVGRE补充了GRE协议，使得在每个包中药携带一个VSID的信息。</p>\n\n<h3>3.1. NVGRE Endpoint</h3>\n\n<p>NVGRE Endpoint就是在虚拟网络和实际网络之间出入的端点，任意屋里服务器或者网络设备都可以作为NVGRE Endpoint。但是在实际中常见的是<code>作为hypervisor</code>的一部分。endpoint主要功能有以下：</p>\n\n<ul>\n<li>封装以太帧到GRE设备/从GRE设备解封出以太帧</li>\n<li>可以作为一个虚拟拓扑的网关</li>\n</ul>\n\n<p>为了封装以太帧，endpoint需要知道帧中目的地址的位置信息，这个地址可以通过管理层分配，本文档假设位置信息，包括VSID，在NVGRE endpoint是存在的。</p>\n\n<h3>3.2. NVGRE frame format</h3>\n\n<p>RFC 2784 RFC 2890中GRE头部的定义被用来在 NVGRE endpoints间通信。 NVGRE 扩展了头部信息，加入了VSID，GRE中二层包封装的格式如下，注意，从上往下看，就是整个数据的从外到内看：</p>\n\n<p>首先，在网络中实际传输的MAC帧的格式 Outer Ethernet Header:</p>\n\n<pre><code>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                (Outer) Destination MAC Address                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|(Outer)Destination MAC Address |  (Outer)Source MAC Address    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                  (Outer) Source MAC Address                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Optional Ethertype=C-Tag 802.1Q| Outer VLAN Tag Information    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre>\n\n<p>其次，剥掉上面一层，则是网络中传输的IP报文的格式：</p>\n\n<p>Outer IPv4 Header:</p>\n\n<pre><code>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Version|  IHL  |Type of Service|          Total Length         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Identification        |Flags|      Fragment Offset    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Time to Live | Protocol 0x2F |         Header Checksum       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      (Outer) Source Address                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                  (Outer) Destination Address                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre>\n\n<p>剥掉上面一层，则是NVGRE Header：</p>\n\n<pre><code>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0| |1|0| Reserved0       | Ver |   Protocol Type 0x6558        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               Virtual Subnet ID (VSID)        |   Reserved    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre>\n\n<p>剥掉GRE头信息，则是相应的虚拟拓扑的信息，也就是原始需要通信端点的信息 Inner Ethernet Header：</p>\n\n<pre><code>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                (Inner) Destination MAC Address                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|(Inner)Destination MAC Address |  (Inner)Source MAC Address    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                  (Inner) Source MAC Address                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Optional Ethertype=C-Tag 802.1Q| PCP |0| VID set to 0          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       Ethertype 0x0800        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre>\n\n<p>最后，才是原始的IP层信息 Inner IPv4 Header:</p>\n\n<pre><code>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Version|  IHL  |Type of Service|          Total Length         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Identification        |Flags|      Fragment Offset    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Time to Live |    Protocol   |         Header Checksum       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Source Address                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Destination Address                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Options                    |    Padding    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Original IP Payload                      |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</code></pre>\n\n<p>有一个解释，这个我好好翻译下：</p>\n\n<ul>\n<li>The outer Ethernet header：源地址是NVGRE endpoint（一个物理设备或者虚拟的设备）的MAC地址，目的地址是吓一跳指定节点，也是一个NVGRE endpoint节点的MAC地址。VLAN可以让这个帧跨越子网的。</li>\n<li>The outer IP header:就是上一层的IP层地址信息。</li>\n<li>C (Checksum Present)和S (Sequence Number Present)必须为0</li>\n<li>The K bit (Key Present) 32bit，NVGRE用这个key来携带VSID.</li>\n</ul>\n\n<p>具体来说32bit的key值，钱24bit用来携带VSID，后8bit用来携带一个FlowID，这个可以用来在VS中进一步划分流。</p>\n\n<ul>\n<li><p>GRE头信息中，协议类型0x6558，(transparent Ethernet bridging)</p></li>\n<li><p>在GRE中不仅仅能封装IP层，其他层都可以，NVGRE也是一样。</p></li>\n</ul>\n\n<h2>4 广播和多播</h2>\n\n<p>传统来说，像GRE这种点到点的tunnel是不能支持多播和广播的，NVGRE提出一个思想，就是为每一个subnet，或者说VSID所表示的虚拟网络指定一个广播和多播地址，从而解决这个问题。</p>\n\n<h3>4.2. Unicast Traffic 这段话很重要</h3>\n\n<p>NVGRE endpoint在GRE中封装2层报文，source PA（packet address）是这个endpoint的地址，而destination PA则是相应的对端endpoint地址。一个endpoint可以有多个地址，就有一个策略来选择是使用哪个地址，经过GRE封装以后，<code>The encapsulated GRE packet is bridged and routed normally by the physical network to the destination.</code>以及<code>On the destination the NVGRE endpoint decapsulates the GRE packet to recover the original Layer-2 frame.</code></p>\n\n<h3>4.3. IP Fragmentation</h3>\n\n<p>在IP中，长的IP报文是有一个分段的，那么NVGRE这种是IP报文进行了一次封装，就最好不要分段，再一下草案中可能会提出解决分段的机制。</p>\n\n<h3>4.4. Address/Policy Management &amp; Routing</h3>\n\n<h3>4.5. Cross-subnet, Cross-premise Communication</h3>\n\n<p>主要是一个VPN gateway，建立一个site-to-site的隧道，注意不是端到端的。从而使得交叉的subnets之间可以通信。如下图：</p>\n\n<p><a href=\"http://blog.wachang.net/wp-content/uploads/2013/03/nvgre-cross-subnets.jpg\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/03/nvgre-cross-subnets.jpg\" alt=\"nvgre-cross-subnets\" width=\"633\" height=\"747\" class=\"aligncenter size-full wp-image-178\" /></a></p>\n','NVGRE: Network Virtualization using Generic Routing Encapsulation','','inherit','open','open','','172-revision-4','','','2013-03-19 23:25:28','2013-03-19 15:25:28','','172','http://blog.wachang.net/2013/03/172-revision-4/','0','revision','','0');");
E_D("replace into `wp_posts` values('181','1','2013-03-20 02:34:00','2013-03-19 18:34:00','<blockquote>\n  <p>这是转自我Octopress博客的文章，现在我的主力还是放到Wordpress吧，毕竟在WIN下用太geek的工具还是有一些问题</p>\n</blockquote>\n\n<p>Python WSGI标准<a href=\"http://www.python.org/dev/peps/pep-0333/\">PEP-0333</a>中说到一个WSGI是一个可调用callable的对象，这包含了一个函数，一个方法，一个类，或者拥有call方法的实例。下面我就对这句话做一个总结，举几个例子。这里的WSGI应用的功能都是返回请求的环境信息environ。</p>\n\n<!--more-->\n\n<h2>1 服务端</h2>\n\n<p>采用简单的WSGI服务器参考实现，如下：</p>\n\n<pre><code>if __name__ == ''__main__'':\n    from wsgiref.simple_server import make_server\n    server = make_server(''192.168.1.11'', 7070, wsgi_application)\n    server.serve_forever()\n</code></pre>\n\n<h2>2 函数方法</h2>\n\n<p>这是最简单的方法，先调用<code>start_response()</code>处理返回头信息，函数再返回可迭代对象，比如列表或者字符串。</p>\n\n<pre><code>def app1(environ,start_response):\n    start_response(\"200 OK\",[(\"Content-type\",\"text/plain\")])\n    content = []\n    for k,v in environ.iteritems():\n        content.append(''%s:%s \\\\n'' % (k,v))\n    return content#返回的列表或者字符串\n</code></pre>\n\n<p>相应的服务端：</p>\n\n<pre><code>server = make_server(''192.168.1.11'', 7070, app1)\n</code></pre>\n\n<h2>3 带有call方法的实例</h2>\n\n<p>类定义中实现call方法，WSGI应用是这个类的一个实例。</p>\n\n<pre><code>class app2(object):\n    def __init__(self):\n       pass\n    def __call__(self,environ,start_response):\n       start_response(\"200 OK\",[(\"Content-type\",\"text/plain\")])\n       content = []\n       for k,v in environ.iteritems():\n           content.append(''%s:%s \\\\n'' % (k,v))\n       return content#返回的列表或者字符串\n\napplication = app2()\n</code></pre>\n\n<p>服务端：</p>\n\n<pre><code>server = make_server(''192.168.1.11'', 7070, application)\n</code></pre>\n\n<h2>4 类class</h2>\n\n<p>用类作为WSGI应用不太一样，调用这个类时会产生一个类的实例，这个实例随后会需要<strong>iter</strong>迭代返回值。</p>\n\n<pre><code>class app3(object):\n    def __init__(self, environ, start_response):\n        self.environ = environ\n        self.start = start_response\n\n    def __iter__(self):\n        status = ''200 OK''\n        response_headers = [(''Content-type'', ''text/plain'')]\n        self.start(status, response_headers)\n        content = ''''\n        for k,v in self.environ.iteritems():\n            content += ''%s:%s \\\\n'' % (k,v)\n        yield content#返回的是字符串\n</code></pre>\n\n<p>服务端：</p>\n\n<pre><code>server = make_server(''192.168.1.11'', 7070, app3)\n</code></pre>\n\n<p>这里注意，和上面的比较可以看出，如果需要把类的实例作为WSGI应用，则类中需要实现call方法，并且作为WSGI应用的应该是这个类的实例。</p>\n\n<h2>5 方法method</h2>\n\n<p>用一个方法来作为WSGI应用，那么这个方法不可能是实例方法（上面已经讲过），一种方式肯定就是类中的静态方法了，类中的静态方法，就当做一个全局函数一样理解吧。</p>\n\n<pre><code>class app4(object):\n    def __init__(self):\n        pass\n    @staticmethod\n    def wsgi(environ,start_response):\n        start_response(\"200 OK\",[(\"Content-type\",\"text/plain\")])\n        content = []\n        for k,v in environ.iteritems():\n            content.append(''%s:%s \\\\n'' % (k,v))\n        return content#返回的是列表或者字符串\n</code></pre>\n\n<p>服务端：</p>\n\n<pre><code>server = make_server(''192.168.1.11'', 7070, app4.wsgi)\n</code></pre>\n\n<p>那么，类方法，可以用么，当然可以，<code>classmethod</code>和<code>staticmethod</code>在使用上可以看做只是参数有个区别而已，如下：</p>\n\n<pre><code>class app5(object):\n    def __init__(self):\n        print ''This is app5''\n        pass\n    @classmethod\n    def wsgi(cls,environ,start_response):\n        start_response(\"200 OK\",[(\"Content-type\",\"text/plain\")])\n        content = []\n        for k,v in environ.iteritems():\n            content.append(''%s:%s \\\\n'' % (k,v))\n        return content #返回列表或者字符串\n</code></pre>\n\n<p>服务端：</p>\n\n<pre><code>server = make_server(''192.168.1.11'', 7070, app5.wsgi)\n</code></pre>\n','WSGI应用常见的几种写法-基本形式','','publish','open','open','','wsgi-application-style-base','','','2013-03-20 02:34:32','2013-03-19 18:34:32','','0','http://blog.wachang.net/?p=181','0','post','','0');");
E_D("replace into `wp_posts` values('182','1','2013-03-20 02:33:29','2013-03-19 18:33:29','<blockquote>\n  <p>这是转自我Octopress博客的文章，现在我的主力还是放到Wordpress吧，毕竟在WIN下用太geek的工具还是有一些问题</p>\n</blockquote>\n\n<p>Python WSGI标准<a href=\"http://www.python.org/dev/peps/pep-0333/\">PEP-0333</a>中说到一个WSGI是一个可调用callable的对象，这包含了一个函数，一个方法，一个类，或者拥有call方法的实例。下面我就对这句话做一个总结，举几个例子。这里的WSGI应用的功能都是返回请求的环境信息environ。</p>\n\n<!--more-->\n\n<h2>1 服务端</h2>\n\n<p>采用简单的WSGI服务器参考实现，如下：</p>\n\n<pre><code>if __name__ == ''__main__'':\n    from wsgiref.simple_server import make_server\n    server = make_server(''192.168.1.11'', 7070, wsgi_application)\n    server.serve_forever()\n</code></pre>\n\n<h2>2 函数方法</h2>\n\n<p>这是最简单的方法，先调用<code>start_response()</code>处理返回头信息，函数再返回可迭代对象，比如列表或者字符串。</p>\n\n<pre><code>def app1(environ,start_response):\n    start_response(\"200 OK\",[(\"Content-type\",\"text/plain\")])\n    content = []\n    for k,v in environ.iteritems():\n        content.append(''%s:%s \\\\n'' % (k,v))\n    return content#返回的列表或者字符串\n</code></pre>\n\n<p>相应的服务端：</p>\n\n<pre><code>server = make_server(''192.168.1.11'', 7070, app1)\n</code></pre>\n\n<h2>3 带有call方法的实例</h2>\n\n<p>类定义中实现call方法，WSGI应用是这个类的一个实例。</p>\n\n<pre><code>class app2(object):\n    def __init__(self):\n       pass\n    def __call__(self,environ,start_response):\n       start_response(\"200 OK\",[(\"Content-type\",\"text/plain\")])\n       content = []\n       for k,v in environ.iteritems():\n           content.append(''%s:%s \\\\n'' % (k,v))\n       return content#返回的列表或者字符串\n\napplication = app2()\n</code></pre>\n\n<p>服务端：</p>\n\n<pre><code>server = make_server(''192.168.1.11'', 7070, application)\n</code></pre>\n\n<h2>4 类class</h2>\n\n<p>用类作为WSGI应用不太一样，调用这个类时会产生一个类的实例，这个实例随后会需要<strong>iter</strong>迭代返回值。</p>\n\n<pre><code>class app3(object):\n    def __init__(self, environ, start_response):\n        self.environ = environ\n        self.start = start_response\n\n    def __iter__(self):\n        status = ''200 OK''\n        response_headers = [(''Content-type'', ''text/plain'')]\n        self.start(status, response_headers)\n        content = ''''\n        for k,v in self.environ.iteritems():\n            content += ''%s:%s \\\\n'' % (k,v)\n        yield content#返回的是字符串\n</code></pre>\n\n<p>服务端：</p>\n\n<pre><code>server = make_server(''192.168.1.11'', 7070, app3)\n</code></pre>\n\n<p>这里注意，和上面的比较可以看出，如果需要把类的实例作为WSGI应用，则类中需要实现call方法，并且作为WSGI应用的应该是这个类的实例。</p>\n\n<h2>5 方法method</h2>\n\n<p>用一个方法来作为WSGI应用，那么这个方法不可能是实例方法（上面已经讲过），一种方式肯定就是类中的静态方法了，类中的静态方法，就当做一个全局函数一样理解吧。</p>\n\n<pre><code>class app4(object):\n    def __init__(self):\n        pass\n    @staticmethod\n    def wsgi(environ,start_response):\n        start_response(\"200 OK\",[(\"Content-type\",\"text/plain\")])\n        content = []\n        for k,v in environ.iteritems():\n            content.append(''%s:%s \\\\n'' % (k,v))\n        return content#返回的是列表或者字符串\n</code></pre>\n\n<p>服务端：</p>\n\n<pre><code>server = make_server(''192.168.1.11'', 7070, app4.wsgi)\n</code></pre>\n\n<p>那么，类方法，可以用么，当然可以，<code>classmethod</code>和<code>staticmethod</code>在使用上可以看做只是参数有个区别而已，如下：</p>\n\n<pre><code>class app5(object):\n    def __init__(self):\n        print ''This is app5''\n        pass\n    @classmethod\n    def wsgi(cls,environ,start_response):\n        start_response(\"200 OK\",[(\"Content-type\",\"text/plain\")])\n        content = []\n        for k,v in environ.iteritems():\n            content.append(''%s:%s \\\\n'' % (k,v))\n        return content #返回列表或者字符串\n</code></pre>\n\n<p>服务端：</p>\n\n<pre><code>server = make_server(''192.168.1.11'', 7070, app5.wsgi)\n</code></pre>\n','WSGI应用常见的几种写法-基本形式','','inherit','open','open','','181-revision','','','2013-03-20 02:33:29','2013-03-19 18:33:29','','181','http://blog.wachang.net/2013/03/181-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('183','1','2013-03-20 02:34:00','2013-03-19 18:34:00','<blockquote>\n  <p>这是转自我Octopress博客的文章，现在我的主力还是放到Wordpress吧，毕竟在WIN下用太geek的工具还是有一些问题</p>\n</blockquote>\n\n<p>Python WSGI标准<a href=\"http://www.python.org/dev/peps/pep-0333/\">PEP-0333</a>中说到一个WSGI是一个可调用callable的对象，这包含了一个函数，一个方法，一个类，或者拥有call方法的实例。下面我就对这句话做一个总结，举几个例子。这里的WSGI应用的功能都是返回请求的环境信息environ。\n<!--more--></p>\n\n<h2>1 服务端</h2>\n\n<p>采用简单的WSGI服务器参考实现，如下：</p>\n\n<pre><code>if __name__ == ''__main__'':\n    from wsgiref.simple_server import make_server\n    server = make_server(''192.168.1.11'', 7070, wsgi_application)\n    server.serve_forever()\n</code></pre>\n\n<h2>2 函数方法</h2>\n\n<p>这是最简单的方法，先调用<code>start_response()</code>处理返回头信息，函数再返回可迭代对象，比如列表或者字符串。</p>\n\n<pre><code>def app1(environ,start_response):\n    start_response(\"200 OK\",[(\"Content-type\",\"text/plain\")])\n    content = []\n    for k,v in environ.iteritems():\n        content.append(''%s:%s \\\\n'' % (k,v))\n    return content#返回的列表或者字符串\n</code></pre>\n\n<p>相应的服务端：</p>\n\n<pre><code>server = make_server(''192.168.1.11'', 7070, app1)\n</code></pre>\n\n<h2>3 带有call方法的实例</h2>\n\n<p>类定义中实现call方法，WSGI应用是这个类的一个实例。</p>\n\n<pre><code>class app2(object):\n    def __init__(self):\n       pass\n    def __call__(self,environ,start_response):\n       start_response(\"200 OK\",[(\"Content-type\",\"text/plain\")])\n       content = []\n       for k,v in environ.iteritems():\n           content.append(''%s:%s \\\\n'' % (k,v))\n       return content#返回的列表或者字符串\n\napplication = app2()\n</code></pre>\n\n<p>服务端：</p>\n\n<pre><code>server = make_server(''192.168.1.11'', 7070, application)\n</code></pre>\n\n<h2>4 类class</h2>\n\n<p>用类作为WSGI应用不太一样，调用这个类时会产生一个类的实例，这个实例随后会需要<strong>iter</strong>迭代返回值。</p>\n\n<pre><code>class app3(object):\n    def __init__(self, environ, start_response):\n        self.environ = environ\n        self.start = start_response\n\n    def __iter__(self):\n        status = ''200 OK''\n        response_headers = [(''Content-type'', ''text/plain'')]\n        self.start(status, response_headers)\n        content = ''''\n        for k,v in self.environ.iteritems():\n            content += ''%s:%s \\\\n'' % (k,v)\n        yield content#返回的是字符串\n</code></pre>\n\n<p>服务端：</p>\n\n<pre><code>server = make_server(''192.168.1.11'', 7070, app3)\n</code></pre>\n\n<p>这里注意，和上面的比较可以看出，如果需要把类的实例作为WSGI应用，则类中需要实现call方法，并且作为WSGI应用的应该是这个类的实例。</p>\n\n<h2>5 方法method</h2>\n\n<p>用一个方法来作为WSGI应用，那么这个方法不可能是实例方法（上面已经讲过），一种方式肯定就是类中的静态方法了，类中的静态方法，就当做一个全局函数一样理解吧。</p>\n\n<pre><code>class app4(object):\n    def __init__(self):\n        pass\n    @staticmethod\n    def wsgi(environ,start_response):\n        start_response(\"200 OK\",[(\"Content-type\",\"text/plain\")])\n        content = []\n        for k,v in environ.iteritems():\n            content.append(''%s:%s \\\\n'' % (k,v))\n        return content#返回的是列表或者字符串\n</code></pre>\n\n<p>服务端：</p>\n\n<pre><code>server = make_server(''192.168.1.11'', 7070, app4.wsgi)\n</code></pre>\n\n<p>那么，类方法，可以用么，当然可以，<code>classmethod</code>和<code>staticmethod</code>在使用上可以看做只是参数有个区别而已，如下：</p>\n\n<pre><code>class app5(object):\n    def __init__(self):\n        print ''This is app5''\n        pass\n    @classmethod\n    def wsgi(cls,environ,start_response):\n        start_response(\"200 OK\",[(\"Content-type\",\"text/plain\")])\n        content = []\n        for k,v in environ.iteritems():\n            content.append(''%s:%s \\\\n'' % (k,v))\n        return content #返回列表或者字符串\n</code></pre>\n\n<p>服务端：</p>\n\n<pre><code>server = make_server(''192.168.1.11'', 7070, app5.wsgi)\n</code></pre>\n','WSGI应用常见的几种写法-基本形式','','inherit','open','open','','181-revision-2','','','2013-03-20 02:34:00','2013-03-19 18:34:00','','181','http://blog.wachang.net/2013/03/181-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('184','1','2013-03-20 02:38:13','2013-03-19 18:38:13','<p>上一节中说到了WSGI应用的几种基本形式，这一节就来说一些高级的用法，所谓高级，我理解的也就是使用装饰器<code>@</code>，WebOb，以及中间件的形式，当然，还有一些更有意思的用法，比如Paste.Deploy这种载入WSGI应用的形式，我以后会做总结。还是和前篇<a href=\"http://blog.wachang.net/wsgi-application-style-base/\">WSGI应用常见的几种写法-基本形式</a>一样，本文实现的WSGI应用都是一个回显请求环境信息的程序。</p>\n\n<!--more-->\n\n<h2>1 WebOb</h2>\n\n<p>WebOb就是将请求和相应封装成Request和Response类，就可以使用一个类方法简化真个操作，如下，直接将一个字符串作为resp_body传给给Response对象，而不用考虑WSGI中的可迭代对象，这里要注意，Response对象<code>是一个WSGI应用</code>，所以在最后的时候我们使用<code>resp(environ,start_response)</code>就返回了，我们不关心返回的细节问题了，而在标准WSGI中，这一步才只是WSGI应用的入口函数。</p>\n\n<pre><code>def app6(environ, start_response):\n    req = Request(environ)\n    resp_body = ''''\n    for k,v in req.environ.iteritems():\n        resp_body += ''%s:%s\\\\n'' % (k,v)\n    resp = Response(body=resp_body)\n    return resp(environ, start_response)\n</code></pre>\n\n<p>服务端：</p>\n\n<pre><code>server = make_server(''192.168.1.11'', 7070, app6)\n</code></pre>\n\n<h2>2 用装饰器@，Controller</h2>\n\n<p>用装饰器@以后，重要的思想就是把WSGI应用关于返回流程的处理（包括header，状态等）和返回Body的处理分开，这样的话实际上一个应用只关注于产生返回的Body就可，而其他的处理流程则交给装饰器controller来完成，这个controller，不要理解成控制神马的，只是一个名字，其原意是作为WSGI中<code>一个资源的控制</code>，不用太操心就当做一个名字就好。</p>\n\n<pre><code>def controller1(func):\n    def application(environ,start_response):\n        #do something else\n        resp_body = func(environ)\n        start_response(\"200 OK\",[(\"Content-type\",\"text/plain\")])\n        return resp_body\n    return application\n\n@controller1\ndef app7(environ):\n    content = []\n    for k,v in environ.iteritems():\n        content.append(''%s:%s \\\\n'' % (k,v))\n    return content\n</code></pre>\n\n<p>服务端：</p>\n\n<pre><code>server = make_server(''192.168.1.11'', 7070, app7)\n</code></pre>\n\n<h2>3 结合WebOb和装饰器</h2>\n\n<p>上面两种方式可能看起来没多大用，但是二者结合到一起，那就不一般了，这样子的话我们用装饰器controller来处理environ,并封装Request和Response，最后让应用函数来处理返回信息，只给出一个字符串Body就可以了。这会大大简化WSGI应用的开发流程。</p>\n\n<pre><code>def controller2(func):\n    def replacement(environ, start_response):\n        req = Request(environ)\n        try:\n            resp_body = func(req)\n        except exc.HTTPException, e:\n            resp_body = e\n        resp = Response(body=resp_body)#body must be a string\n        resp.status = ''200 very OK''\n        return resp(environ, start_response)\n    return replacement\n\n@controller2\ndef app8(req):\n    ret = ''''\n    for k,v in req.environ.iteritems():\n        ret = ret + ''%s:%s \\\\n'' % (k,v)\n    return ret\n</code></pre>\n\n<p>服务端：</p>\n\n<pre><code>    server = make_server(''192.168.1.11'', 7070, app8)\n</code></pre>\n\n<p>以上是用装饰器来装饰一个函数，还有一种用法，用装饰器来装饰一个类。</p>\n\n<pre><code>def controller3(cls):\n    def replacement(environ, start_response):\n        req = Request(environ)\n        instance = cls(req, **req.urlvars)\n        method = req.method\n        if method == ''GET'':\n            func = getattr(instance, method.lower())\n            resp_body = func()\n            if isinstance(resp_body, basestring):\n                resp = Response(body=resp_body)\n        return resp(environ,start_response)\n    return replacement\n\nclass App9(object):\n    def __init__(self,req,**args):\n        self.req = req\n    def get(self):\n        body = ''''\n        for k,v in self.req.environ.iteritems():\n            body += ''%s\"%s \\\\n'' % (k,v)\n        return body\n\napp9 = controller3(App9)\n</code></pre>\n\n<p>上面关于类的装饰器可以仔细琢磨一下哈，相应的服务端：</p>\n\n<pre><code>server = make_server(''192.168.1.11'', 7070, app9)\n</code></pre>\n\n<h2>4 总结</h2>\n\n<p>两篇文章我一共说明了9种WSGI应用的写法，当然WSGI只是一个协议，相应的实现还是很灵活的，以后再实践中再分享一些新的用法。整个代码我使用Gist存放，连接在此：<a href=\"https://gist.github.com/4378216\">https://gist.github.com/4378216</a></p>\n','WSGI应用常见的几种写法-高级形式','','publish','open','open','','wsgi-application-style-adv','','','2013-03-20 02:38:13','2013-03-19 18:38:13','','0','http://blog.wachang.net/?p=184','0','post','','0');");
E_D("replace into `wp_posts` values('185','1','2013-03-20 02:37:15','2013-03-19 18:37:15','<p>上一节中说到了WSGI应用的几种基本形式，这一节就来说一些高级的用法，所谓高级，我理解的也就是使用装饰器<code>@</code>，WebOb，以及中间件的形式，当然，还有一些更有意思的用法，比如Paste.Deploy这种载入WSGI应用的形式，我以后会做总结。还是和前篇<a href=\"http://op.wachang.net/blog/2012/12/wsgi-application-style-base/\">WSGI应用常见的几种写法-基本形式</a>一样，本文实现的WSGI应用都是一个回显请求环境信息的程序。</p>\n\n<!--more-->\n\n<h2>1 WebOb</h2>\n\n<p>WebOb就是将请求和相应封装成Request和Response类，就可以使用一个类方法简化真个操作，如下，直接将一个字符串作为resp_body传给给Response对象，而不用考虑WSGI中的可迭代对象，这里要注意，Response对象<code>是一个WSGI应用</code>，所以在最后的时候我们使用<code>resp(environ,start_response)</code>就返回了，我们不关心返回的细节问题了，而在标准WSGI中，这一步才只是WSGI应用的入口函数。</p>\n\n<pre><code>def app6(environ, start_response):\n    req = Request(environ)\n    resp_body = ''''\n    for k,v in req.environ.iteritems():\n        resp_body += ''%s:%s\\\\n'' % (k,v)\n    resp = Response(body=resp_body)\n    return resp(environ, start_response)\n</code></pre>\n\n<p>服务端：</p>\n\n<pre><code>server = make_server(''192.168.1.11'', 7070, app6)\n</code></pre>\n\n<h2>2 用装饰器@，Controller</h2>\n\n<p>用装饰器@以后，重要的思想就是把WSGI应用关于返回流程的处理（包括header，状态等）和返回Body的处理分开，这样的话实际上一个应用只关注于产生返回的Body就可，而其他的处理流程则交给装饰器controller来完成，这个controller，不要理解成控制神马的，只是一个名字，其原意是作为WSGI中<code>一个资源的控制</code>，不用太操心就当做一个名字就好。</p>\n\n<pre><code>def controller1(func):\n    def application(environ,start_response):\n        #do something else\n        resp_body = func(environ)\n        start_response(\"200 OK\",[(\"Content-type\",\"text/plain\")])\n        return resp_body\n    return application\n\n@controller1\ndef app7(environ):\n    content = []\n    for k,v in environ.iteritems():\n        content.append(''%s:%s \\\\n'' % (k,v))\n    return content\n</code></pre>\n\n<p>服务端：</p>\n\n<pre><code>server = make_server(''192.168.1.11'', 7070, app7)\n</code></pre>\n\n<h2>3 结合WebOb和装饰器</h2>\n\n<p>上面两种方式可能看起来没多大用，但是二者结合到一起，那就不一般了，这样子的话我们用装饰器controller来处理environ,并封装Request和Response，最后让应用函数来处理返回信息，只给出一个字符串Body就可以了。这会大大简化WSGI应用的开发流程。</p>\n\n<pre><code>def controller2(func):\n    def replacement(environ, start_response):\n        req = Request(environ)\n        try:\n            resp_body = func(req)\n        except exc.HTTPException, e:\n            resp_body = e\n        resp = Response(body=resp_body)#body must be a string\n        resp.status = ''200 very OK''\n        return resp(environ, start_response)\n    return replacement\n\n@controller2\ndef app8(req):\n    ret = ''''\n    for k,v in req.environ.iteritems():\n        ret = ret + ''%s:%s \\\\n'' % (k,v)\n    return ret\n</code></pre>\n\n<p>服务端：</p>\n\n<pre><code>    server = make_server(''192.168.1.11'', 7070, app8)\n</code></pre>\n\n<p>以上是用装饰器来装饰一个函数，还有一种用法，用装饰器来装饰一个类。</p>\n\n<pre><code>def controller3(cls):\n    def replacement(environ, start_response):\n        req = Request(environ)\n        instance = cls(req, **req.urlvars)\n        method = req.method\n        if method == ''GET'':\n            func = getattr(instance, method.lower())\n            resp_body = func()\n            if isinstance(resp_body, basestring):\n                resp = Response(body=resp_body)\n        return resp(environ,start_response)\n    return replacement\n\nclass App9(object):\n    def __init__(self,req,**args):\n        self.req = req\n    def get(self):\n        body = ''''\n        for k,v in self.req.environ.iteritems():\n            body += ''%s\"%s \\\\n'' % (k,v)\n        return body\n\napp9 = controller3(App9)\n</code></pre>\n\n<p>上面关于类的装饰器可以仔细琢磨一下哈，相应的服务端：</p>\n\n<pre><code>server = make_server(''192.168.1.11'', 7070, app9)\n</code></pre>\n\n<h2>4 总结</h2>\n\n<p>两篇文章我一共说明了9种WSGI应用的写法，当然WSGI只是一个协议，相应的实现还是很灵活的，以后再实践中再分享一些新的用法。整个代码我使用Gist存放，连接在此：<a href=\"https://gist.github.com/4378216\">https://gist.github.com/4378216</a></p>\n','WSGI应用常见的几种写法-高级形式','','inherit','open','open','','184-revision','','','2013-03-20 02:37:15','2013-03-19 18:37:15','','184','http://blog.wachang.net/2013/03/184-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('186','1','2013-03-20 20:20:41','0000-00-00 00:00:00','\n','自动草稿','','auto-draft','open','open','','','','','2013-03-20 20:20:41','0000-00-00 00:00:00','','0','http://blog.wachang.net/?p=186','0','post','','0');");

require("../../inc/footer.php");
?>