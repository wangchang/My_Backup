<?php
require("../../inc/header.php");

/*
		SoftName : EmpireBak Version 2010
		Author   : wm_chief
		Copyright: Powered by www.phome.net
*/

DoSetDbChar('utf8');
E_D("DROP TABLE IF EXISTS `wp_posts`;");
E_C("CREATE TABLE `wp_posts` (
  `ID` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `post_author` bigint(20) unsigned NOT NULL DEFAULT '0',
  `post_date` datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  `post_date_gmt` datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  `post_content` longtext NOT NULL,
  `post_title` text NOT NULL,
  `post_excerpt` text NOT NULL,
  `post_status` varchar(20) NOT NULL DEFAULT 'publish',
  `comment_status` varchar(20) NOT NULL DEFAULT 'open',
  `ping_status` varchar(20) NOT NULL DEFAULT 'open',
  `post_password` varchar(20) NOT NULL DEFAULT '',
  `post_name` varchar(200) NOT NULL DEFAULT '',
  `to_ping` text NOT NULL,
  `pinged` text NOT NULL,
  `post_modified` datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  `post_modified_gmt` datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  `post_content_filtered` longtext NOT NULL,
  `post_parent` bigint(20) unsigned NOT NULL DEFAULT '0',
  `guid` varchar(255) NOT NULL DEFAULT '',
  `menu_order` int(11) NOT NULL DEFAULT '0',
  `post_type` varchar(20) NOT NULL DEFAULT 'post',
  `post_mime_type` varchar(100) NOT NULL DEFAULT '',
  `comment_count` bigint(20) NOT NULL DEFAULT '0',
  PRIMARY KEY (`ID`),
  KEY `post_name` (`post_name`),
  KEY `type_status_date` (`post_type`,`post_status`,`post_date`,`ID`),
  KEY `post_parent` (`post_parent`),
  KEY `post_author` (`post_author`)
) ENGINE=InnoDB AUTO_INCREMENT=187 DEFAULT CHARSET=utf8");
E_D("replace into `wp_posts` values('1','1','2013-02-27 05:58:45','2013-02-27 05:58:45','欢迎使用 WordPress。这是系统自动生成的演示文章。编辑或者删除它，然后开始您的博客！','世界，你好！','','trash','open','open','','hello-world','','','2013-02-27 14:01:20','2013-02-27 06:01:20','','0','http://blog.wachang.net/?p=1','0','post','','1');");
E_D("replace into `wp_posts` values('2','1','2013-02-27 05:58:45','2013-02-27 05:58:45','这是示范页面。页面和博客文章不同，它的位置是固定的，通常会在站点导航栏显示。很多用户都创建一个“关于”页面，向访客介绍自己。例如，个人博客通常有类似这样的介绍：\n\n<blockquote>欢迎！我白天是个邮递员，晚上就是个有抱负的演员。这是我的博客。我住在天朝的帝都，有条叫做杰克的狗。</blockquote>\n\n... 公司博客可以这样写：\n\n<blockquote>XYZ Doohickey 公司成立于 1971 年，自从建立以来，我们一直向社会贡献着优秀 doohicky。我们的公司总部位于天朝魔都，有着超过两千名员工，对魔都政府税收有着巨大贡献。</blockquote>\n\n您可以访问<a href=\"http://blog.wachang.net/wp-admin/\">仪表盘</a>，删除本页面，然后添加您自己的内容。祝您使用愉快！','示例页面','','trash','open','open','','sample-page','','','2013-02-27 14:32:25','2013-02-27 06:32:25','','0','http://blog.wachang.net/?page_id=2','0','page','','0');");
E_D("replace into `wp_posts` values('4','1','2013-02-27 05:58:45','2013-02-27 05:58:45','欢迎使用 WordPress。这是系统自动生成的演示文章。编辑或者删除它，然后开始您的博客！','世界，你好！','','inherit','open','open','','1-revision','','','2013-02-27 05:58:45','2013-02-27 05:58:45','','1','http://blog.wachang.net/?p=4','0','revision','','0');");
E_D("replace into `wp_posts` values('7','1','2013-02-27 14:26:29','2013-02-27 06:26:29','<h2>haha</h2>\n\n<pre><code>def this is good!\nprint ''hello''\n</code></pre>\n\n<h1>!python</h1>\n\n<p>def class():</p>\n\n<p>不知道中文看起来怎么样啊</p>\n','test','','trash','open','open','','test-3','','','2013-02-27 19:57:06','2013-02-27 11:57:06','','0','http://blog.wachang.net/?p=7','0','post','','0');");
E_D("replace into `wp_posts` values('8','1','2013-02-27 14:25:20','2013-02-27 06:25:20','<h2>haha</h2>\n\n<pre><code>def this is good!\nprint ''hello''\n</code></pre>\n\n<p>python</p>\n','test','','inherit','open','open','','7-revision','','','2013-02-27 14:25:20','2013-02-27 06:25:20','','7','http://blog.wachang.net/index.php/2013/02/7-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('9','1','2013-02-27 14:26:20','2013-02-27 06:26:20','<h2>haha</h2>\n\n<pre><code>def this is good!\nprint ''hello''\n</code></pre>\n\n<h1>!python</h1>\n\n<p>def class():</p>\n\n<p>b</p>\n','test','','inherit','open','open','','7-revision-2','','','2013-02-27 14:26:20','2013-02-27 06:26:20','','7','http://blog.wachang.net/index.php/2013/02/7-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('10','1','2013-02-27 14:32:01','2013-02-27 06:32:01','##等待编辑','关于我','','publish','open','open','','about','','','2013-02-27 14:33:17','2013-02-27 06:33:17','','0','http://blog.wachang.net/?page_id=10','0','page','','0');");
E_D("replace into `wp_posts` values('11','1','2013-02-27 14:31:53','2013-02-27 06:31:53','','About','','inherit','open','open','','10-revision','','','2013-02-27 14:31:53','2013-02-27 06:31:53','','10','http://blog.wachang.net/index.php/2013/02/10-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('12','1','2013-02-27 14:31:53','2013-02-27 06:31:53','','About','','inherit','open','open','','10-revision-2','','','2013-02-27 14:31:53','2013-02-27 06:31:53','','10','http://blog.wachang.net/index.php/2013/02/10-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('14','1','2013-02-27 05:58:45','2013-02-27 05:58:45','这是示范页面。页面和博客文章不同，它的位置是固定的，通常会在站点导航栏显示。很多用户都创建一个“关于”页面，向访客介绍自己。例如，个人博客通常有类似这样的介绍：\n\n<blockquote>欢迎！我白天是个邮递员，晚上就是个有抱负的演员。这是我的博客。我住在天朝的帝都，有条叫做杰克的狗。</blockquote>\n\n... 公司博客可以这样写：\n\n<blockquote>XYZ Doohickey 公司成立于 1971 年，自从建立以来，我们一直向社会贡献着优秀 doohicky。我们的公司总部位于天朝魔都，有着超过两千名员工，对魔都政府税收有着巨大贡献。</blockquote>\n\n您可以访问<a href=\"http://blog.wachang.net/wp-admin/\">仪表盘</a>，删除本页面，然后添加您自己的内容。祝您使用愉快！','示例页面','','inherit','open','open','','2-revision','','','2013-02-27 05:58:45','2013-02-27 05:58:45','','2','http://blog.wachang.net/index.php/2013/02/2-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('15','1','2013-02-27 14:32:01','2013-02-27 06:32:01','','About','','inherit','open','open','','10-revision-3','','','2013-02-27 14:32:01','2013-02-27 06:32:01','','10','http://blog.wachang.net/index.php/2013/02/10-revision-3/','0','revision','','0');");
E_D("replace into `wp_posts` values('16','1','2013-02-27 14:32:41','2013-02-27 06:32:41','##等待编辑','About','','inherit','open','open','','10-revision-4','','','2013-02-27 14:32:41','2013-02-27 06:32:41','','10','http://blog.wachang.net/index.php/2013/02/10-revision-4/','0','revision','','0');");
E_D("replace into `wp_posts` values('18','1','2013-02-27 14:39:16','2013-02-27 06:39:16','<h2>我就是来测试下的</h2>\n\n<p>我擦</p>\n','test','','trash','open','open','','test','','','2013-02-27 15:30:29','2013-02-27 07:30:29','','0','http://blog.wachang.net/?p=18','0','post','','0');");
E_D("replace into `wp_posts` values('19','1','2013-02-27 14:39:03','2013-02-27 06:39:03','\n','test','','inherit','open','open','','18-revision','','','2013-02-27 14:39:03','2013-02-27 06:39:03','','18','http://blog.wachang.net/index.php/2013/02/18-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('21','1','2013-02-27 15:26:00','2013-02-27 07:26:00','<p>擦擦擦擦</p>\n','再来测试一下','','trash','open','open','','%e5%86%8d%e6%9d%a5%e6%b5%8b%e8%af%95%e4%b8%80%e4%b8%8b','','','2013-02-27 15:30:27','2013-02-27 07:30:27','','0','http://blog.wachang.net/?p=21','0','post','','0');");
E_D("replace into `wp_posts` values('22','1','2013-02-27 15:25:53','2013-02-27 07:25:53','\n','再来测试一下','','inherit','open','open','','21-revision','','','2013-02-27 15:25:53','2013-02-27 07:25:53','','21','http://blog.wachang.net/2013/02/21-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('23','1','2013-02-27 15:26:00','2013-02-27 07:26:00','<p>擦擦擦擦</p>\n','再来测试一下','','inherit','open','open','','21-revision-2','','','2013-02-27 15:26:00','2013-02-27 07:26:00','','21','http://blog.wachang.net/2013/02/21-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('24','1','2013-02-27 14:39:16','2013-02-27 06:39:16','<h2>我就是来测试下的</h2>\n\n<p>我擦</p>\n','test','','inherit','open','open','','18-revision-2','','','2013-02-27 14:39:16','2013-02-27 06:39:16','','18','http://blog.wachang.net/2013/02/18-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('25','1','2013-02-27 15:32:30','2013-02-27 07:32:30','<p>dfsfsdfsd</p>\n','dsafsf','','trash','open','open','','dsafsf','','','2013-02-27 19:57:03','2013-02-27 11:57:03','','0','http://blog.wachang.net/?p=25','0','post','','0');");
E_D("replace into `wp_posts` values('26','1','2013-02-27 15:32:28','2013-02-27 07:32:28','<p>dfs</p>\n','dsafsf','','inherit','open','open','','25-revision','','','2013-02-27 15:32:28','2013-02-27 07:32:28','','25','http://blog.wachang.net/2013/02/25-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('27','1','2013-02-27 17:59:49','2013-02-27 09:59:49','','极速版','','trash','open','open','','%e6%9e%81%e9%80%9f%e7%89%88','','','2013-03-09 23:59:36','2013-03-09 15:59:36','','0','http://blog.wachang.net/?page_id=27','0','page','','0');");
E_D("replace into `wp_posts` values('28','1','2013-02-27 17:59:13','2013-02-27 09:59:13','','极速版','','inherit','open','open','','27-revision','','','2013-02-27 17:59:13','2013-02-27 09:59:13','','27','http://blog.wachang.net/2013/02/27-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('29','1','2013-02-27 17:59:49','2013-02-27 09:59:49','','极速版','','inherit','open','open','','27-revision-2','','','2013-02-27 17:59:49','2013-02-27 09:59:49','','27','http://blog.wachang.net/2013/02/27-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('30','1','2013-02-27 18:41:39','2013-02-27 10:41:39','<h2>haha</h2>\n','test','','trash','open','open','','test-2','','','2013-02-27 19:57:00','2013-02-27 11:57:00','','0','http://blog.wachang.net/?p=30','0','post','','0');");
E_D("replace into `wp_posts` values('31','1','2013-02-27 18:40:00','2013-02-27 10:40:00','','logo','','inherit','open','open','','logo','','','2013-02-27 18:40:00','2013-02-27 10:40:00','','30','http://blog.wachang.net/wp-content/uploads/2013/02/logo.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('32','1','2013-02-27 18:40:08','2013-02-27 10:40:08','<h2>haha</h2>\n','','','inherit','open','open','','30-revision','','','2013-02-27 18:40:08','2013-02-27 10:40:08','','30','http://blog.wachang.net/2013/02/30-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('33','1','2013-02-27 19:52:41','2013-02-27 11:52:41','<p>LetoDMS(http://www.letodms.com/)是一个免费开源的文档管理系统，适合小型企业或者组织用来做整个的文档管理。因为是我们实验室需要相应的文档管理服务，所以在Opendocman和LetoDMS中都适用了一下，总的来看，有一下特点：</p>\n\n<ul>\n<li>Opendocman:界面清爽，中文支持较好，不支持LDAP，使用上不太友好。</li>\n<li>LetoDMS:界面不是很好看，但是使用很上手，最重要的，支持LDAP。</li>\n</ul>\n\n<p>LetoDMS虽说支持LDAP，但是官网上木有配置文档，网上也没多少资料，自己折腾了好久，然后对着代码一步步Debug,才终于搞定，下面做一个记录。</p>\n\n<!--more-->\n\n<h2>LetoDMS中LDAP验证过程</h2>\n\n<p>在LetoDMS中，配置了LDAP以后，会用登陆的uid和密码去匹配LDAP服务器中DN下的uid和密码，成功后再与LetoDMS本地用户数据库进行匹配：1）如果本地LetoDMS中木有相应的用户信息，则根据CN名字信息和UID等创建用户，但不设置密码；2）如果已经有相应的用户信息，则允许登陆，相应的LDAP认证代码在<strong>/op/op.Login.php</strong>中。</p>\n\n<h2>LetoDMS中LDAP验证配置</h2>\n\n<p>在conf/settings.xml中配置LDAP信息，有两个地方:</p>\n\n<pre><code>&lt;authentication enableGuestLogin=\"false\" enablePasswordForgotten=\"false\" restricted=\"false\" enableUserImage=\"false\" disableSelfEdit=\"false\" passwordStrength=\"0\" passwordExpiration=\"0\" passwordHistory=\"0\" passwordStrengthAlgorithm=\"simple\" loginFailure=\"0\" encryptionKey=\"88401c30b26bdf44f0facbf62849cf1e\"&gt;  \n</code></pre>\n\n<p>这里的restricted一定要设置为false。当然，这一个也可以通过admin登陆以后，在全局settings里设置。随后，设置LDAP信息：</p>\n\n<pre><code>&lt;connector enable=\"enable\" type=\"ldap\" host=\"ldap.oinlab.com\" port=\"389\" baseDN=\"ou=People,dc=oinlab\"&gt;\n</code></pre>\n\n<p>如果此时没效果，别急，编辑<code>inc/inc.ClassSettings.php</code>，再找到如下变量并设置好：</p>\n\n<pre><code>// LDAP\nvar \$_ldapHost = \"ldap.oinlab.com\"; // URIs are supported, e.g.: ldaps://ldap.host.com\nvar \$_ldapPort = 389; // Optional.\nvar \$_ldapBaseDN = \"ou=People,dc=oinlab\";\nvar \$_ldapAccountDomainName = \"oinlab\";\nvar \$_ldapType = 0; // 0 = ldap; 1 = AD\nvar \$_converters = array(); // list of commands used to convert files to text for Indexer\n</code></pre>\n\n<p>注意，实际上这个inc中的才是最基本的，这里面的变量值是通过读取<code>conf/setting.xml</code>中的值来的，当然，改了这里面的值得话settings.xml文件也无效了。最后，LetoDMS中相应的LDAP登陆代码位于<code>op/op.Login.php</code>中，有问题的话可以根据这里的代码做一些DEBUG.</p>\n','LetoDMS文档管理系统配置LDAP认证','','publish','open','open','','configure-letodms-with-ldap','','','2013-03-08 18:43:24','2013-03-08 10:43:24','','0','http://blog.wachang.net/?p=33','0','post','','1');");
E_D("replace into `wp_posts` values('34','1','2013-02-27 19:51:15','2013-02-27 11:51:15','<p>LetoDMS(http://www.letodms.com/)是一个免费开源的文档管理系统，适合小型企业或者组织用来做整个的文档管理。因为是我们实验室需要相应的文档管理服务，所以在Opendocman和LetoDMS中都适用了一下，总的来看，有一下特点：</p>\n\n<ul>\n<li>Opendocman:界面清爽，中文支持较好，不支持LDAP，使用上不太友好。</li>\n<li>LetoDMS:界面不是很好看，但是使用很上手，最重要的，支持LDAP。</li>\n</ul>\n\n<p>LetoDMS虽说支持LDAP，但是官网上木有配置文档，网上也没多少资料，自己折腾了好久，然后对着代码一步步Debug,才终于搞定，下面做一个记录。</p>\n\n<h2>LetoDMS中LDAP验证过程</h2>\n\n<p>在LetoDMS中，配置了LDAP以后，会用登陆的uid和密码去匹配LDAP服务器中DN下的uid和密码，成功后再与LetoDMS本地用户数据库进行匹配：1）如果本地LetoDMS中木有相应的用户信息，则根据CN名字信息和UID等创建用户，但不设置密码；2）如果已经有相应的用户信息，则允许登陆，相应的LDAP认证代码在<code>/op/op.Login.php</code>中。</p>\n\n<h2>LetoDMS中LDAP验证配置</h2>\n\n<p>在conf/settings.xml中配置LDAP信息，有两个地方:</p>\n\n<pre><code>&lt;authentication enableGuestLogin=\"false\" enablePasswordForgotten=\"false\" restricted=\"false\" enableUserImage=\"false\" disableSelfEdit=\"false\" passwordStrength=\"0\" passwordExpiration=\"0\" passwordHistory=\"0\" passwordStrengthAlgorithm=\"simple\" loginFailure=\"0\" encryptionKey=\"88401c30b26bdf44f0facbf62849cf1e\"&gt;\n</code></pre>\n\n<p>这里的restricted一定要设置为false。当然，这一个也可以通过admin登陆以后，在全局settings里设置。随后，设置LDAP信息：</p>\n\n<pre><code>&lt;connector enable=\"enable\" type=\"ldap\" host=\"ldap.oinlab.com\" port=\"389\" baseDN=\"ou=People,dc=oinlab\"&gt;\n</code></pre>\n\n<p>如果此时没效果，别急，编辑<code>inc/inc.ClassSettings.php</code>，再找到如下变量并设置好：</p>\n\n<pre><code>// LDAP\nvar \$_ldapHost = \"ldap.oinlab.com\"; // URIs are supported, e.g.: ldaps://ldap.host.com\nvar \$_ldapPort = 389; // Optional.\nvar \$_ldapBaseDN = \"ou=People,dc=oinlab\";\nvar \$_ldapAccountDomainName = \"oinlab\";\nvar \$_ldapType = 0; // 0 = ldap; 1 = AD\nvar \$_converters = array(); // list of commands used to convert files to text for Indexer\n</code></pre>\n\n<p>注意，实际上这个inc中的才是最基本的，这里面的变量值是通过读取<code>conf/setting.xml</code>中的值来的，当然，改了这里面的值得话settings.xml文件也无效了。最后，LetoDMS中相应的LDAP登陆代码位于<code>op/op.Login.php</code>中，有问题的话可以根据这里的代码做一些DEBUG.</p>\n','LetoDMS文档管理系统配置LDAP认证','','inherit','open','open','','33-revision','','','2013-02-27 19:51:15','2013-02-27 11:51:15','','33','http://blog.wachang.net/2013/02/33-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('35','1','2013-02-27 19:52:41','2013-02-27 11:52:41','<p>LetoDMS(http://www.letodms.com/)是一个免费开源的文档管理系统，适合小型企业或者组织用来做整个的文档管理。因为是我们实验室需要相应的文档管理服务，所以在Opendocman和LetoDMS中都适用了一下，总的来看，有一下特点：</p>\n\n<ul>\n<li>Opendocman:界面清爽，中文支持较好，不支持LDAP，使用上不太友好。</li>\n<li>LetoDMS:界面不是很好看，但是使用很上手，最重要的，支持LDAP。</li>\n</ul>\n\n<p>LetoDMS虽说支持LDAP，但是官网上木有配置文档，网上也没多少资料，自己折腾了好久，然后对着代码一步步Debug,才终于搞定，下面做一个记录。</p>\n\n<h2>LetoDMS中LDAP验证过程</h2>\n\n<p>在LetoDMS中，配置了LDAP以后，会用登陆的uid和密码去匹配LDAP服务器中DN下的uid和密码，成功后再与LetoDMS本地用户数据库进行匹配：1）如果本地LetoDMS中木有相应的用户信息，则根据CN名字信息和UID等创建用户，但不设置密码；2）如果已经有相应的用户信息，则允许登陆，相应的LDAP认证代码在<code>/op/op.Login.php</code>中。</p>\n\n<h2>LetoDMS中LDAP验证配置</h2>\n\n<p>在conf/settings.xml中配置LDAP信息，有两个地方:</p>\n\n<pre><code>&lt;authentication enableGuestLogin=\"false\" enablePasswordForgotten=\"false\" restricted=\"false\" enableUserImage=\"false\" disableSelfEdit=\"false\" passwordStrength=\"0\" passwordExpiration=\"0\" passwordHistory=\"0\" passwordStrengthAlgorithm=\"simple\" loginFailure=\"0\" encryptionKey=\"88401c30b26bdf44f0facbf62849cf1e\"&gt;\n</code></pre>\n\n<p>这里的restricted一定要设置为false。当然，这一个也可以通过admin登陆以后，在全局settings里设置。随后，设置LDAP信息：</p>\n\n<pre><code>&lt;connector enable=\"enable\" type=\"ldap\" host=\"ldap.oinlab.com\" port=\"389\" baseDN=\"ou=People,dc=oinlab\"&gt;\n</code></pre>\n\n<p>如果此时没效果，别急，编辑<code>inc/inc.ClassSettings.php</code>，再找到如下变量并设置好：</p>\n\n<pre><code>// LDAP\nvar \$_ldapHost = \"ldap.oinlab.com\"; // URIs are supported, e.g.: ldaps://ldap.host.com\nvar \$_ldapPort = 389; // Optional.\nvar \$_ldapBaseDN = \"ou=People,dc=oinlab\";\nvar \$_ldapAccountDomainName = \"oinlab\";\nvar \$_ldapType = 0; // 0 = ldap; 1 = AD\nvar \$_converters = array(); // list of commands used to convert files to text for Indexer\n</code></pre>\n\n<p>注意，实际上这个inc中的才是最基本的，这里面的变量值是通过读取<code>conf/setting.xml</code>中的值来的，当然，改了这里面的值得话settings.xml文件也无效了。最后，LetoDMS中相应的LDAP登陆代码位于<code>op/op.Login.php</code>中，有问题的话可以根据这里的代码做一些DEBUG.</p>\n','LetoDMS文档管理系统配置LDAP认证','','inherit','open','open','','33-revision-2','','','2013-02-27 19:52:41','2013-02-27 11:52:41','','33','http://blog.wachang.net/2013/02/33-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('36','1','2013-02-27 18:41:39','2013-02-27 10:41:39','<h2>haha</h2>\n','test','','inherit','open','open','','30-revision-2','','','2013-02-27 18:41:39','2013-02-27 10:41:39','','30','http://blog.wachang.net/2013/02/30-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('37','1','2013-02-27 15:32:30','2013-02-27 07:32:30','<p>dfsfsdfsd</p>\n','dsafsf','','inherit','open','open','','25-revision-2','','','2013-02-27 15:32:30','2013-02-27 07:32:30','','25','http://blog.wachang.net/2013/02/25-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('38','1','2013-02-27 14:26:29','2013-02-27 06:26:29','<h2>haha</h2>\n\n<pre><code>def this is good!\nprint ''hello''\n</code></pre>\n\n<h1>!python</h1>\n\n<p>def class():</p>\n\n<p>不知道中文看起来怎么样啊</p>\n','test','','inherit','open','open','','7-revision-3','','','2013-02-27 14:26:29','2013-02-27 06:26:29','','7','http://blog.wachang.net/2013/02/7-revision-3/','0','revision','','0');");
E_D("replace into `wp_posts` values('39','1','2013-03-08 18:42:44','2013-03-08 10:42:44','<p>LetoDMS(http://www.letodms.com/)是一个免费开源的文档管理系统，适合小型企业或者组织用来做整个的文档管理。因为是我们实验室需要相应的文档管理服务，所以在Opendocman和LetoDMS中都适用了一下，总的来看，有一下特点：</p>\n\n<ul>\n<li>Opendocman:界面清爽，中文支持较好，不支持LDAP，使用上不太友好。</li>\n<li>LetoDMS:界面不是很好看，但是使用很上手，最重要的，支持LDAP。</li>\n</ul>\n\n<p>LetoDMS虽说支持LDAP，但是官网上木有配置文档，网上也没多少资料，自己折腾了好久，然后对着代码一步步Debug,才终于搞定，下面做一个记录。</p>\n\n<!--more-->\n\n<h2>LetoDMS中LDAP验证过程</h2>\n\n<p>在LetoDMS中，配置了LDAP以后，会用登陆的uid和密码去匹配LDAP服务器中DN下的uid和密码，成功后再与LetoDMS本地用户数据库进行匹配：1）如果本地LetoDMS中木有相应的用户信息，则根据CN名字信息和UID等创建用户，但不设置密码；2）如果已经有相应的用户信息，则允许登陆，相应的LDAP认证代码在<strong>/op/op.Login.php</strong>中。</p>\n\n<h2>LetoDMS中LDAP验证配置</h2>\n\n<p>在conf/settings.xml中配置LDAP信息，有两个地方:</p>\n\n<pre><code>&lt;authentication enableGuestLogin=\"false\" enablePasswordForgotten=\"false\" restricted=\"false\" enableUserImage=\"false\" disableSelfEdit=\"false\" passwordStrength=\"0\" passwordExpiration=\"0\" passwordHistory=\"0\" passwordStrengthAlgorithm=\"simple\" loginFailure=\"0\" encryptionKey=\"88401c30b26bdf44f0facbf62849cf1e\"&gt;   \n</code></pre>\n\n<p>这里的restricted一定要设置为false。当然，这一个也可以通过admin登陆以后，在全局settings里设置。随后，设置LDAP信息：</p>\n\n<pre><code>&lt;connector enable=\"enable\" type=\"ldap\" host=\"ldap.oinlab.com\" port=\"389\" baseDN=\"ou=People,dc=oinlab\"&gt;\n</code></pre>\n\n<p>如果此时没效果，别急，编辑<code>inc/inc.ClassSettings.php</code>，再找到如下变量并设置好：</p>\n\n<pre><code>// LDAP\nvar \$_ldapHost = \"ldap.oinlab.com\"; // URIs are supported, e.g.: ldaps://ldap.host.com\nvar \$_ldapPort = 389; // Optional.\nvar \$_ldapBaseDN = \"ou=People,dc=oinlab\";\nvar \$_ldapAccountDomainName = \"oinlab\";\nvar \$_ldapType = 0; // 0 = ldap; 1 = AD\nvar \$_converters = array(); // list of commands used to convert files to text for Indexer\n</code></pre>\n\n<p>注意，实际上这个inc中的才是最基本的，这里面的变量值是通过读取<code>conf/setting.xml</code>中的值来的，当然，改了这里面的值得话settings.xml文件也无效了。最后，LetoDMS中相应的LDAP登陆代码位于<code>op/op.Login.php</code>中，有问题的话可以根据这里的代码做一些DEBUG.</p>\n','LetoDMS文档管理系统配置LDAP认证','','inherit','open','open','','33-autosave','','','2013-03-08 18:42:44','2013-03-08 10:42:44','','33','http://blog.wachang.net/2013/02/33-autosave/','0','revision','','0');");
E_D("replace into `wp_posts` values('40','1','2013-02-27 19:54:06','2013-02-27 11:54:06','<p>LetoDMS(http://www.letodms.com/)是一个免费开源的文档管理系统，适合小型企业或者组织用来做整个的文档管理。因为是我们实验室需要相应的文档管理服务，所以在Opendocman和LetoDMS中都适用了一下，总的来看，有一下特点：</p>\n\n<ul>\n<li>Opendocman:界面清爽，中文支持较好，不支持LDAP，使用上不太友好。</li>\n<li>LetoDMS:界面不是很好看，但是使用很上手，最重要的，支持LDAP。</li>\n</ul>\n\n<p>LetoDMS虽说支持LDAP，但是官网上木有配置文档，网上也没多少资料，自己折腾了好久，然后对着代码一步步Debug,才终于搞定，下面做一个记录。</p>\n\n<h2>LetoDMS中LDAP验证过程</h2>\n\n<p>在LetoDMS中，配置了LDAP以后，会用登陆的uid和密码去匹配LDAP服务器中DN下的uid和密码，成功后再与LetoDMS本地用户数据库进行匹配：1）如果本地LetoDMS中木有相应的用户信息，则根据CN名字信息和UID等创建用户，但不设置密码；2）如果已经有相应的用户信息，则允许登陆，相应的LDAP认证代码在<code>/op/op.Login.php</code>中。</p>\n\n<h2>LetoDMS中LDAP验证配置</h2>\n\n<p>在conf/settings.xml中配置LDAP信息，有两个地方:</p>\n\n<pre><code>&lt;authentication enableGuestLogin=\"false\" enablePasswordForgotten=\"false\" restricted=\"false\" enableUserImage=\"false\" disableSelfEdit=\"false\" passwordStrength=\"0\" passwordExpiration=\"0\" passwordHistory=\"0\" passwordStrengthAlgorithm=\"simple\" loginFailure=\"0\" encryptionKey=\"88401c30b26bdf44f0facbf62849cf1e\"&gt;\n</code></pre>\n\n<p>这里的restricted一定要设置为false。当然，这一个也可以通过admin登陆以后，在全局settings里设置。随后，设置LDAP信息：</p>\n\n<pre><code>&lt;connector enable=\"enable\" type=\"ldap\" host=\"ldap.oinlab.com\" port=\"389\" baseDN=\"ou=People,dc=oinlab\"&gt;\n</code></pre>\n\n<p>如果此时没效果，别急，编辑<code>inc/inc.ClassSettings.php</code>，再找到如下变量并设置好：</p>\n\n<pre><code>// LDAP\nvar \$_ldapHost = \"ldap.oinlab.com\"; // URIs are supported, e.g.: ldaps://ldap.host.com\nvar \$_ldapPort = 389; // Optional.\nvar \$_ldapBaseDN = \"ou=People,dc=oinlab\";\nvar \$_ldapAccountDomainName = \"oinlab\";\nvar \$_ldapType = 0; // 0 = ldap; 1 = AD\nvar \$_converters = array(); // list of commands used to convert files to text for Indexer\n</code></pre>\n\n<p>注意，实际上这个inc中的才是最基本的，这里面的变量值是通过读取<code>conf/setting.xml</code>中的值来的，当然，改了这里面的值得话settings.xml文件也无效了。最后，LetoDMS中相应的LDAP登陆代码位于<code>op/op.Login.php</code>中，有问题的话可以根据这里的代码做一些DEBUG.</p>\n','LetoDMS文档管理系统配置LDAP认证','','inherit','open','open','','33-revision-3','','','2013-02-27 19:54:06','2013-02-27 11:54:06','','33','http://blog.wachang.net/2013/02/33-revision-3/','0','revision','','0');");
E_D("replace into `wp_posts` values('41','1','2013-02-27 21:19:47','2013-02-27 13:19:47','','amqp-intro-1','','inherit','open','open','','amqp-intro-1','','','2013-02-27 21:19:47','2013-02-27 13:19:47','','0','http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-1.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('42','1','2013-02-27 21:36:56','2013-02-27 13:36:56','<blockquote>\n  <p>本文主要是翻译加总结，通过资料的查询，对AMQP有一定了解</p>\n  \n  <p>RabbitMQ使用的就是AMQP 0-9-1模型，所以本文其实也是在讲RabbitMQ中的一些原理</p>\n  \n  <p>文末会列出原文地址</p>\n</blockquote>\n\n<h2>What is AMQP?</h2>\n\n<p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，一个网络应用层协议的开放标准，为面向消息的中间件设计。</p>\n\n<p>说白了，这就是一个消费者生产者模型，模型就是生产者生产出一个消息，发送到一个队列Queue，消费者(也叫做worker)从队列里面取出这个消息。但是AMQP中，这个消息一般来说是一个任务，生产者消费者一般不在同一台机器上，所以，更好的解释就是，一个程序发送一个任务消息给一个队列，然后消费者程序从队列中拿出这个任务信息，进行执行，可能还需要返回结果。</p>\n\n<p>而RabbitMQ，就是实现了这么一个模型的软件，独立的开源实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、 Ruby、.NET、Java、JMS、C、PHP、 ActionScript、XMPP、STOMP等，支持AJAX。RabbitMQ就是一个服务器，实现了队列的管理，一个程序连接这个服务器，把任务发送给服务器（也即是进入了队列），消费者连接服务器，从队列中取出任务消息，然后执行。</p>\n\n<p>中英文对照： Messaging broker:消息协商器,它在TCP/IP等端口监听AMQ消息。 producers：应用程序，产生消息，并publish到消息队列中 consumers：应用程序，接收消息，然后进行处理。</p>\n\n<h2>AMQP 0-9-1 Model流程</h2>\n\n<p>AMQP 0-9-1 Model可以简单的总结如下:P产生消息，然后publish(发布)到exchange(交换机，类比成邮政的邮筒吧)，exchange根据一个规则(bindinds)把消息发送到队列(queue)中，消息协商器要么把消息传递给等待(订阅subdcribe)在某一队列上的的消费者(consumers)，要么消费者就从队列中根据自己的需要取消息。如下图： <img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-1.png\" alt=\"AMQP 0-9-1 Model in Brief\" /> 当publish消息的时候，P可能还会指定消息的属性（meta-data），可能一些meta会被broker使用，而其余的都是由C来使用的。</p>\n\n<p>因为网络不可靠，应用可能处理消息的时候就挂掉了，所以就有一个<code>消息确认机制message acknowledgements</code>:当消息传递给C的时候X需要通知broker。当使用消息确认机制的时候，一个broker只有在收到C对于此消息已经被接收的通知后才会删除消息。</p>\n\n<p>某些场景，消息发不到合适的C的时候，消息可能会被返回给P，丢弃，或者说放进一个“死亡队列”，由P来决定如何操作。</p>\n\n<p>队列，交换机，绑定作为AMQP中协作的三个元素。（Queues, exchanges and bindings are collectively referred to as AMQP entities.）</p>\n\n<h2>AMQP is a Programmable Protocol</h2>\n\n<h2>Exchanges and Exchange Types</h2>\n\n<p>交换机从P中接收到一个消息，然后路由?(route)发送到一个或者多个队列。交换机的类型和路由的规则和起来就叫做bindins，AMQP 0-9-1 brokers提供了四种交换类型。</p>\n\n<pre><code>交换类型                默认名字\nDirect exchange      空字符串或者amq.direct\nFanout exchange      amq.Fanout\nTopic exchange       amq.Topic\nHeaders exchange     amq.match (and amq.headers in RabbitMQ)\n</code></pre>\n','RabbitMQ/AMQP 0-9-1 模型入门介绍','','trash','open','open','','rabbitmqamqp-0-9-1-%e6%a8%a1%e5%9e%8b%e5%85%a5%e9%97%a8%e4%bb%8b%e7%bb%8d','','','2013-02-28 20:14:45','2013-02-28 12:14:45','','0','http://blog.wachang.net/?p=42','0','post','','0');");
E_D("replace into `wp_posts` values('43','1','2013-02-27 21:36:41','2013-02-27 13:36:41','<blockquote>\n  <p>本文主要是翻译加总结，通过资料的查询，对AMQP有一定了解</p>\n  \n  <p>RabbitMQ使用的就是AMQP 0-9-1模型，所以本文其实也是在讲RabbitMQ中的一些原理</p>\n  \n  <p>文末会列出原文地址</p>\n</blockquote>\n\n<h2>What is AMQP?</h2>\n\n<p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，一个网络应用层协议的开放标准，为面向消息的中间件设计。</p>\n\n<p>说白了，这就是一个消费者生产者模型，模型就是生产者生产出一个消息，发送到一个队列Queue，消费者(也叫做worker)从队列里面取出这个消息。但是AMQP中，这个消息一般来说是一个任务，生产者消费者一般不在同一台机器上，所以，更好的解释就是，一个程序发送一个任务消息给一个队列，然后消费者程序从队列中拿出这个任务信息，进行执行，可能还需要返回结果。</p>\n\n<p>而RabbitMQ，就是实现了这么一个模型的软件，独立的开源实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、 Ruby、.NET、Java、JMS、C、PHP、 ActionScript、XMPP、STOMP等，支持AJAX。RabbitMQ就是一个服务器，实现了队列的管理，一个程序连接这个服务器，把任务发送给服务器（也即是进入了队列），消费者连接服务器，从队列中取出任务消息，然后执行。</p>\n\n<p>中英文对照：\nMessaging broker:消息协商器,它在TCP/IP等端口监听AMQ消息。\nproducers：应用程序，产生消息，并publish到消息队列中\nconsumers：应用程序，接收消息，然后进行处理。</p>\n\n<h2>AMQP 0-9-1 Model流程</h2>\n\n<p>AMQP 0-9-1 Model可以简单的总结如下:P产生消息，然后publish(发布)到exchange(交换机，类比成邮政的邮筒吧)，exchange根据一个规则(bindinds)把消息发送到队列(queue)中，消息协商器要么把消息传递给等待(订阅subdcribe)在某一队列上的的消费者(consumers)，要么消费者就从队列中根据自己的需要取消息。如下图：\n<img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-1.png\" alt=\"AMQP 0-9-1 Model in Brief\" />\n当publish消息的时候，P可能还会指定消息的属性（meta-data），可能一些meta会被broker使用，而其余的都是由C来使用的。</p>\n\n<p>因为网络不可靠，应用可能处理消息的时候就挂掉了，所以就有一个<code>消息确认机制message acknowledgements</code>:当消息传递给C的时候X需要通知broker。当使用消息确认机制的时候，一个broker只有在收到C对于此消息已经被接收的通知后才会删除消息。</p>\n\n<p>某些场景，消息发不到合适的C的时候，消息可能会被返回给P，丢弃，或者说放进一个“死亡队列”，由P来决定如何操作。</p>\n\n<p>队列，交换机，绑定作为AMQP中协作的三个元素。（Queues, exchanges and bindings are collectively referred to as AMQP entities.）</p>\n\n<h2>AMQP is a Programmable Protocol</h2>\n\n<h2>Exchanges and Exchange Types</h2>\n\n<p>交换机从P中接收到一个消息，然后路由?(route)发送到一个或者多个队列。交换机的类型和路由的规则和起来就叫做bindins，AMQP 0-9-1 brokers提供了四种交换类型。</p>\n\n<pre><code>交换类型                默认名字\nDirect exchange      空字符串或者amq.direct\nFanout exchange      amq.Fanout\nTopic exchange       amq.Topic\nHeaders exchange     amq.match (and amq.headers in RabbitMQ)\n</code></pre>\n','RabbitMQ/AMQP 0-9-1 模型入门介绍','','inherit','open','open','','42-revision','','','2013-02-27 21:36:41','2013-02-27 13:36:41','','42','http://blog.wachang.net/2013/02/42-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('44','1','2013-02-27 21:36:53','2013-02-27 13:36:53','<blockquote>\n  <p>本文主要是翻译加总结，通过资料的查询，对AMQP有一定了解</p>\n  \n  <p>RabbitMQ使用的就是AMQP 0-9-1模型，所以本文其实也是在讲RabbitMQ中的一些原理</p>\n  \n  <p>文末会列出原文地址</p>\n</blockquote>\n\n<h2>What is AMQP?</h2>\n\n<p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，一个网络应用层协议的开放标准，为面向消息的中间件设计。</p>\n\n<p>说白了，这就是一个消费者生产者模型，模型就是生产者生产出一个消息，发送到一个队列Queue，消费者(也叫做worker)从队列里面取出这个消息。但是AMQP中，这个消息一般来说是一个任务，生产者消费者一般不在同一台机器上，所以，更好的解释就是，一个程序发送一个任务消息给一个队列，然后消费者程序从队列中拿出这个任务信息，进行执行，可能还需要返回结果。</p>\n\n<p>而RabbitMQ，就是实现了这么一个模型的软件，独立的开源实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、 Ruby、.NET、Java、JMS、C、PHP、 ActionScript、XMPP、STOMP等，支持AJAX。RabbitMQ就是一个服务器，实现了队列的管理，一个程序连接这个服务器，把任务发送给服务器（也即是进入了队列），消费者连接服务器，从队列中取出任务消息，然后执行。</p>\n\n<p>中英文对照：\nMessaging broker:消息协商器,它在TCP/IP等端口监听AMQ消息。\nproducers：应用程序，产生消息，并publish到消息队列中\nconsumers：应用程序，接收消息，然后进行处理。</p>\n\n<h2>AMQP 0-9-1 Model流程</h2>\n\n<p>AMQP 0-9-1 Model可以简单的总结如下:P产生消息，然后publish(发布)到exchange(交换机，类比成邮政的邮筒吧)，exchange根据一个规则(bindinds)把消息发送到队列(queue)中，消息协商器要么把消息传递给等待(订阅subdcribe)在某一队列上的的消费者(consumers)，要么消费者就从队列中根据自己的需要取消息。如下图：\n<img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-1.png\" alt=\"AMQP 0-9-1 Model in Brief\" />\n当publish消息的时候，P可能还会指定消息的属性（meta-data），可能一些meta会被broker使用，而其余的都是由C来使用的。</p>\n\n<p>因为网络不可靠，应用可能处理消息的时候就挂掉了，所以就有一个<code>消息确认机制message acknowledgements</code>:当消息传递给C的时候X需要通知broker。当使用消息确认机制的时候，一个broker只有在收到C对于此消息已经被接收的通知后才会删除消息。</p>\n\n<p>某些场景，消息发不到合适的C的时候，消息可能会被返回给P，丢弃，或者说放进一个“死亡队列”，由P来决定如何操作。</p>\n\n<p>队列，交换机，绑定作为AMQP中协作的三个元素。（Queues, exchanges and bindings are collectively referred to as AMQP entities.）</p>\n\n<h2>AMQP is a Programmable Protocol</h2>\n\n<h2>Exchanges and Exchange Types</h2>\n\n<p>交换机从P中接收到一个消息，然后路由?(route)发送到一个或者多个队列。交换机的类型和路由的规则和起来就叫做bindins，AMQP 0-9-1 brokers提供了四种交换类型。</p>\n\n<pre><code>交换类型                默认名字\nDirect exchange      空字符串或者amq.direct\nFanout exchange      amq.Fanout\nTopic exchange       amq.Topic\nHeaders exchange     amq.match (and amq.headers in RabbitMQ)\n</code></pre>\n','RabbitMQ/AMQP 0-9-1 模型入门介绍','','inherit','open','open','','42-revision-2','','','2013-02-27 21:36:53','2013-02-27 13:36:53','','42','http://blog.wachang.net/2013/02/42-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('45','1','2013-02-27 20:02:44','2013-02-27 12:02:44','<p>LetoDMS(http://www.letodms.com/)是一个免费开源的文档管理系统，适合小型企业或者组织用来做整个的文档管理。因为是我们实验室需要相应的文档管理服务，所以在Opendocman和LetoDMS中都适用了一下，总的来看，有一下特点：</p>\n\n<ul>\n<li>Opendocman:界面清爽，中文支持较好，不支持LDAP，使用上不太友好。</li>\n<li>LetoDMS:界面不是很好看，但是使用很上手，最重要的，支持LDAP。</li>\n</ul>\n\n<p>LetoDMS虽说支持LDAP，但是官网上木有配置文档，网上也没多少资料，自己折腾了好久，然后对着代码一步步Debug,才终于搞定，下面做一个记录。</p>\n\n<h2>LetoDMS中LDAP验证过程</h2>\n\n<p>在LetoDMS中，配置了LDAP以后，会用登陆的uid和密码去匹配LDAP服务器中DN下的uid和密码，成功后再与LetoDMS本地用户数据库进行匹配：1）如果本地LetoDMS中木有相应的用户信息，则根据CN名字信息和UID等创建用户，但不设置密码；2）如果已经有相应的用户信息，则允许登陆，相应的LDAP认证代码在<strong>/op/op.Login.php</strong>中。</p>\n\n<h2>LetoDMS中LDAP验证配置</h2>\n\n<p>在conf/settings.xml中配置LDAP信息，有两个地方:</p>\n\n<pre><code>&lt;authentication enableGuestLogin=\"false\" enablePasswordForgotten=\"false\" restricted=\"false\" enableUserImage=\"false\" disableSelfEdit=\"false\" passwordStrength=\"0\" passwordExpiration=\"0\" passwordHistory=\"0\" passwordStrengthAlgorithm=\"simple\" loginFailure=\"0\" encryptionKey=\"88401c30b26bdf44f0facbf62849cf1e\"&gt;\n</code></pre>\n\n<p>这里的restricted一定要设置为false。当然，这一个也可以通过admin登陆以后，在全局settings里设置。随后，设置LDAP信息：</p>\n\n<pre><code>&lt;connector enable=\"enable\" type=\"ldap\" host=\"ldap.oinlab.com\" port=\"389\" baseDN=\"ou=People,dc=oinlab\"&gt;\n</code></pre>\n\n<p>如果此时没效果，别急，编辑<code>inc/inc.ClassSettings.php</code>，再找到如下变量并设置好：</p>\n\n<pre><code>// LDAP\nvar \$_ldapHost = \"ldap.oinlab.com\"; // URIs are supported, e.g.: ldaps://ldap.host.com\nvar \$_ldapPort = 389; // Optional.\nvar \$_ldapBaseDN = \"ou=People,dc=oinlab\";\nvar \$_ldapAccountDomainName = \"oinlab\";\nvar \$_ldapType = 0; // 0 = ldap; 1 = AD\nvar \$_converters = array(); // list of commands used to convert files to text for Indexer\n</code></pre>\n\n<p>注意，实际上这个inc中的才是最基本的，这里面的变量值是通过读取<code>conf/setting.xml</code>中的值来的，当然，改了这里面的值得话settings.xml文件也无效了。最后，LetoDMS中相应的LDAP登陆代码位于<code>op/op.Login.php</code>中，有问题的话可以根据这里的代码做一些DEBUG.</p>\n','LetoDMS文档管理系统配置LDAP认证','','inherit','open','open','','33-revision-4','','','2013-02-27 20:02:44','2013-02-27 12:02:44','','33','http://blog.wachang.net/2013/02/33-revision-4/','0','revision','','0');");
E_D("replace into `wp_posts` values('47','1','2013-02-28 10:25:57','2013-02-28 02:25:57','<p>test</p>\n','test','','trash','open','open','','test-4','','','2013-02-28 10:47:52','2013-02-28 02:47:52','','0','http://blog.wachang.net/?p=47','0','post','','0');");
E_D("replace into `wp_posts` values('48','1','2013-02-28 10:25:54','2013-02-28 02:25:54','\n','test','','inherit','open','open','','47-revision','','','2013-02-28 10:25:54','2013-02-28 02:25:54','','47','http://blog.wachang.net/2013/02/47-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('50','1','2013-02-28 00:14:44','2013-02-27 16:14:44','<p>LetoDMS(http://www.letodms.com/)是一个免费开源的文档管理系统，适合小型企业或者组织用来做整个的文档管理。因为是我们实验室需要相应的文档管理服务，所以在Opendocman和LetoDMS中都适用了一下，总的来看，有一下特点：</p>\n\n<ul>\n<li>Opendocman:界面清爽，中文支持较好，不支持LDAP，使用上不太友好。</li>\n<li>LetoDMS:界面不是很好看，但是使用很上手，最重要的，支持LDAP。</li>\n</ul>\n\n<p>LetoDMS虽说支持LDAP，但是官网上木有配置文档，网上也没多少资料，自己折腾了好久，然后对着代码一步步Debug,才终于搞定，下面做一个记录。</p>\n\n<h2>LetoDMS中LDAP验证过程</h2>\n\n<p>在LetoDMS中，配置了LDAP以后，会用登陆的uid和密码去匹配LDAP服务器中DN下的uid和密码，成功后再与LetoDMS本地用户数据库进行匹配：1）如果本地LetoDMS中木有相应的用户信息，则根据CN名字信息和UID等创建用户，但不设置密码；2）如果已经有相应的用户信息，则允许登陆，相应的LDAP认证代码在<strong>/op/op.Login.php</strong>中。</p>\n\n<h2>LetoDMS中LDAP验证配置</h2>\n\n<p>在conf/settings.xml中配置LDAP信息，有两个地方:</p>\n\n<pre><code>&lt;authentication enableGuestLogin=\"false\" enablePasswordForgotten=\"false\" restricted=\"false\" enableUserImage=\"false\" disableSelfEdit=\"false\" passwordStrength=\"0\" passwordExpiration=\"0\" passwordHistory=\"0\" passwordStrengthAlgorithm=\"simple\" loginFailure=\"0\" encryptionKey=\"88401c30b26bdf44f0facbf62849cf1e\"&gt;\n</code></pre>\n\n<p>这里的restricted一定要设置为false。当然，这一个也可以通过admin登陆以后，在全局settings里设置。随后，设置LDAP信息：</p>\n\n<pre><code>&lt;connector enable=\"enable\" type=\"ldap\" host=\"ldap.oinlab.com\" port=\"389\" baseDN=\"ou=People,dc=oinlab\"&gt;\n</code></pre>\n\n<p>如果此时没效果，别急，编辑<code>inc/inc.ClassSettings.php</code>，再找到如下变量并设置好：</p>\n\n<pre><code>// LDAP\nvar \$_ldapHost = \"ldap.oinlab.com\"; // URIs are supported, e.g.: ldaps://ldap.host.com\nvar \$_ldapPort = 389; // Optional.\nvar \$_ldapBaseDN = \"ou=People,dc=oinlab\";\nvar \$_ldapAccountDomainName = \"oinlab\";\nvar \$_ldapType = 0; // 0 = ldap; 1 = AD\nvar \$_converters = array(); // list of commands used to convert files to text for Indexer\n</code></pre>\n\n<p>注意，实际上这个inc中的才是最基本的，这里面的变量值是通过读取<code>conf/setting.xml</code>中的值来的，当然，改了这里面的值得话settings.xml文件也无效了。最后，LetoDMS中相应的LDAP登陆代码位于<code>op/op.Login.php</code>中，有问题的话可以根据这里的代码做一些DEBUG.</p>\n','LetoDMS文档管理系统配置LDAP认证','','inherit','open','open','','33-revision-5','','','2013-02-28 00:14:44','2013-02-27 16:14:44','','33','http://blog.wachang.net/2013/02/33-revision-5/','0','revision','','0');");
E_D("replace into `wp_posts` values('51','1','2013-02-28 10:25:57','2013-02-28 02:25:57','<p>test</p>\n','test','','inherit','open','open','','47-revision-2','','','2013-02-28 10:25:57','2013-02-28 02:25:57','','47','http://blog.wachang.net/2013/02/47-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('52','1','2013-02-28 10:41:47','2013-02-28 02:41:47','<p>LetoDMS(http://www.letodms.com/)是一个免费开源的文档管理系统，适合小型企业或者组织用来做整个的文档管理。因为是我们实验室需要相应的文档管理服务，所以在Opendocman和LetoDMS中都适用了一下，总的来看，有一下特点：</p>\n\n<ul>\n<li>Opendocman:界面清爽，中文支持较好，不支持LDAP，使用上不太友好。</li>\n<li>LetoDMS:界面不是很好看，但是使用很上手，最重要的，支持LDAP。</li>\n</ul>\n\n<p>LetoDMS虽说支持LDAP，但是官网上木有配置文档，网上也没多少资料，自己折腾了好久，然后对着代码一步步Debug,才终于搞定，下面做一个记录。</p>\n\n<h2>LetoDMS中LDAP验证过程</h2>\n\n<p>在LetoDMS中，配置了LDAP以后，会用登陆的uid和密码去匹配LDAP服务器中DN下的uid和密码，成功后再与LetoDMS本地用户数据库进行匹配：1）如果本地LetoDMS中木有相应的用户信息，则根据CN名字信息和UID等创建用户，但不设置密码；2）如果已经有相应的用户信息，则允许登陆，相应的LDAP认证代码在<strong>/op/op.Login.php</strong>中。</p>\n\n<h2>LetoDMS中LDAP验证配置</h2>\n\n<p>在conf/settings.xml中配置LDAP信息，有两个地方:</p>\n\n<pre><code>&lt;authentication enableGuestLogin=\"false\" enablePasswordForgotten=\"false\" restricted=\"false\" enableUserImage=\"false\" disableSelfEdit=\"false\" passwordStrength=\"0\" passwordExpiration=\"0\" passwordHistory=\"0\" passwordStrengthAlgorithm=\"simple\" loginFailure=\"0\" encryptionKey=\"88401c30b26bdf44f0facbf62849cf1e\"&gt;\n</code></pre>\n\n<p>这里的restricted一定要设置为false。当然，这一个也可以通过admin登陆以后，在全局settings里设置。随后，设置LDAP信息：</p>\n\n<pre><code>&lt;connector enable=\"enable\" type=\"ldap\" host=\"ldap.oinlab.com\" port=\"389\" baseDN=\"ou=People,dc=oinlab\"&gt;\n</code></pre>\n\n<p>如果此时没效果，别急，编辑<code>inc/inc.ClassSettings.php</code>，再找到如下变量并设置好：</p>\n\n<pre><code>// LDAP\nvar \$_ldapHost = \"ldap.oinlab.com\"; // URIs are supported, e.g.: ldaps://ldap.host.com\nvar \$_ldapPort = 389; // Optional.\nvar \$_ldapBaseDN = \"ou=People,dc=oinlab\";\nvar \$_ldapAccountDomainName = \"oinlab\";\nvar \$_ldapType = 0; // 0 = ldap; 1 = AD\nvar \$_converters = array(); // list of commands used to convert files to text for Indexer\n</code></pre>\n\n<p>注意，实际上这个inc中的才是最基本的，这里面的变量值是通过读取<code>conf/setting.xml</code>中的值来的，当然，改了这里面的值得话settings.xml文件也无效了。最后，LetoDMS中相应的LDAP登陆代码位于<code>op/op.Login.php</code>中，有问题的话可以根据这里的代码做一些DEBUG.</p>\n','LetoDMS文档管理系统配置LDAP认证','','inherit','open','open','','33-revision-6','','','2013-02-28 10:41:47','2013-02-28 02:41:47','','33','http://blog.wachang.net/2013/02/33-revision-6/','0','revision','','0');");
E_D("replace into `wp_posts` values('53','1','2013-02-28 12:55:58','2013-02-28 04:55:58','<p>LetoDMS(http://www.letodms.com/)是一个免费开源的文档管理系统，适合小型企业或者组织用来做整个的文档管理。因为是我们实验室需要相应的文档管理服务，所以在Opendocman和LetoDMS中都适用了一下，总的来看，有一下特点：</p>\n\n<ul>\n<li>Opendocman:界面清爽，中文支持较好，不支持LDAP，使用上不太友好。</li>\n<li>LetoDMS:界面不是很好看，但是使用很上手，最重要的，支持LDAP。</li>\n</ul>\n\n<p>LetoDMS虽说支持LDAP，但是官网上木有配置文档，网上也没多少资料，自己折腾了好久，然后对着代码一步步Debug,才终于搞定，下面做一个记录。\n<!--more--></p>\n\n<h2>LetoDMS中LDAP验证过程</h2>\n\n<p>在LetoDMS中，配置了LDAP以后，会用登陆的uid和密码去匹配LDAP服务器中DN下的uid和密码，成功后再与LetoDMS本地用户数据库进行匹配：1）如果本地LetoDMS中木有相应的用户信息，则根据CN名字信息和UID等创建用户，但不设置密码；2）如果已经有相应的用户信息，则允许登陆，相应的LDAP认证代码在<strong>/op/op.Login.php</strong>中。</p>\n\n<h2>LetoDMS中LDAP验证配置</h2>\n\n<p>在conf/settings.xml中配置LDAP信息，有两个地方:</p>\n\n<pre><code>&lt;authentication enableGuestLogin=\"false\" enablePasswordForgotten=\"false\" restricted=\"false\" enableUserImage=\"false\" disableSelfEdit=\"false\" passwordStrength=\"0\" passwordExpiration=\"0\" passwordHistory=\"0\" passwordStrengthAlgorithm=\"simple\" loginFailure=\"0\" encryptionKey=\"88401c30b26bdf44f0facbf62849cf1e\"&gt;\n</code></pre>\n\n<p>这里的restricted一定要设置为false。当然，这一个也可以通过admin登陆以后，在全局settings里设置。随后，设置LDAP信息：</p>\n\n<pre><code>&lt;connector enable=\"enable\" type=\"ldap\" host=\"ldap.oinlab.com\" port=\"389\" baseDN=\"ou=People,dc=oinlab\"&gt;\n</code></pre>\n\n<p>如果此时没效果，别急，编辑<code>inc/inc.ClassSettings.php</code>，再找到如下变量并设置好：</p>\n\n<pre><code>// LDAP\nvar \$_ldapHost = \"ldap.oinlab.com\"; // URIs are supported, e.g.: ldaps://ldap.host.com\nvar \$_ldapPort = 389; // Optional.\nvar \$_ldapBaseDN = \"ou=People,dc=oinlab\";\nvar \$_ldapAccountDomainName = \"oinlab\";\nvar \$_ldapType = 0; // 0 = ldap; 1 = AD\nvar \$_converters = array(); // list of commands used to convert files to text for Indexer\n</code></pre>\n\n<p>注意，实际上这个inc中的才是最基本的，这里面的变量值是通过读取<code>conf/setting.xml</code>中的值来的，当然，改了这里面的值得话settings.xml文件也无效了。最后，LetoDMS中相应的LDAP登陆代码位于<code>op/op.Login.php</code>中，有问题的话可以根据这里的代码做一些DEBUG.</p>\n','LetoDMS文档管理系统配置LDAP认证','','inherit','open','open','','33-revision-7','','','2013-02-28 12:55:58','2013-02-28 04:55:58','','33','http://blog.wachang.net/2013/02/33-revision-7/','0','revision','','0');");
E_D("replace into `wp_posts` values('54','1','2013-02-28 19:58:38','2013-02-28 11:58:38','<blockquote>\n  <p>1本文主要是翻译加总结，通过资料的查询，对AMQP有一定了解; 2 RabbitMQ使用的就是AMQP 0-9-1模型，所以本文其实也是在讲RabbitMQ中的一些原理; 3 文末会列出原文地址</p>\n</blockquote>\n\n<h2>1 What is AMQP?</h2>\n\n<p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，一个网络应用层协议的开放标准，为面向消息的中间件设计。</p>\n\n<p>说白了，这就是一个消费者生产者模型，生产者生产出一个消息，发送到一个队列Queue，消费者(也叫做worker)从队列里面取出这个消息。但是AMQP中，这个消息一般来说是一个任务，生产者消费者一般不在同一台机器上，所以，更好的解释就是，一个程序发送一个任务消息给一个队列，然后消费者程序从队列中拿出这个任务信息，进行执行，可能还需要返回结果。</p>\n\n<p>而RabbitMQ，就是实现了这么一个模型的软件，独立的开源实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、 Ruby、.NET、Java、JMS、C、PHP、 ActionScript、XMPP、STOMP等，支持AJAX。RabbitMQ就是一个服务器，实现了队列的管理，一个程序连接这个服务器，把任务发送给服务器（也即是进入了队列），消费者连接服务器，从队列中取出任务消息，然后执行。</p>\n\n<p>中英文对照： Messaging broker:消息协商器,它在TCP/IP等端口监听AMQ消息，其实就是AMQP的实现，比如RabbitMQ等。 producers：应用程序，产生消息，并publish到消息队列中，下文简称P。 consumers：应用程序，接收消息，然后进行处理，下文简称C。 AMQP client：AMQP客户端，指与AMQP broker连接的P或者C。</p>\n\n<h2>2 AMQP协议</h2>\n\n<h3>2.1 协议概述</h3>\n\n<p>从整体来看，AMQP协议可划分为三层： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-256x300.png\" alt=\"amqp-protocol\" width=\"256\" height=\"300\" class=\"alignnone size-medium wp-image-55\" /></a> AMQP定义了合适的服务器端域模型，用于规范服务器的行为(AMQP服务器端可称为broker)。在这里Model层决定这些基本域模型所产生的行为，这种行为在AMQP中用”command”表示，在后文中会着重来分析这些域模型。Session层定义客户端与broker之间的通信(通信双方都是一个peer，可互称做partner)，为command的可靠传输提供保障。Transport层专注于数据传送，并与Session保持交互，接受上层的数据，组装成二进制流，传送到receiver后再解析数据，交付给Session层。Session层需要Transport层完成网络异常情况的汇报，顺序传送command等工作。</p>\n\n<h3>2.2 协议模型</h3>\n\n<p>AMQP broker主要功能是消息的路由(Routing)和缓存(Buffering)，如下图： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-2.png\" alt=\"amqp-protocol-2\" width=\"571\" height=\"239\" class=\"alignnone size-full wp-image-59\" /></a> Exchange接收消息生产者(Producer)发送的消息根据不同的路由算法将消息发送往Message queue。Message queue会在消息不能被正常消费时缓存这些消息，具体的缓存策略由实现者决定，当message queue与消息消费者(Message consumer)之间的连接通畅时，Message queue有将消息转发到consumer的责任。</p>\n\n<p>Message是当前模型中所操纵的基本单位,基本结构有两部分: Header和Body(playload),Header是由Producer添加上的各种属性的集合，这些属性有控制Message是否可被缓存，接收的queue是哪个，优先级是多少等。Body是真正需要传送的数据，它是对Broker不可见的二进制数据流，在传输过程中不应该受到影响。</p>\n\n<p>一个broker中会存在多个Message queue，Exchange通过binding知道要把消息发送到哪个Message queue,在创建Message queue后需要确定它来接收并保存哪个Exchange路由的结果。Binding是用来关联Exchange与Message queue的域模型,通过关键字bindinds_key。</p>\n\n<p>在与多个Message queue关联后，Exchange中就会存在一个路由表，这个表中存储着每个Message queue所需要消息的限制条件。Exchange就会检查它接受到的每个Message的Header及Body信息，来决定将Message路由到哪个queue中去。Message的Header中应该有个属性叫Routing Key，它由Message发送者产生，提供给Exchange路由这条Message的标准。Exchange根据不同路由算法有不同有Exchange Type。比如有Direct类似，需要Binding key 等于Routing key；也有Binding key与Routing key符合一个模式关系；也有根据Message包含的某些属性来判断。一些基础的路由算法由AMQP所提供，client application也可以自定义各种自己的扩展路由算法。 <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-3.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-3.png\" alt=\"amqp-protocol-3\" width=\"714\" height=\"117\" class=\"alignnone size-full wp-image-58\" /></a> 对于，上图，有一些具体的概念，下面会详细讨论。</p>\n\n<h3>2.3 AMQP 0-9-1 Model流程</h3>\n\n<p>AMQP 0-9-1 Model可以简单的总结如下:P产生消息，然后publish(发布)到exchange(交换机，类比成邮政的邮筒吧)，exchange根据一个规则(bindinds)把消息发送到队列(queue)中，消息协商器要么把消息传递给等待(订阅subdcribe)在某一队列上的的消费者(consumers)，要么消费者就从队列中根据自己的需要取消息。如下图： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-11.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-11.png\" alt=\"amqp-intro-1\" width=\"712\" height=\"319\" class=\"alignnone size-full wp-image-60\" /></a></p>\n\n<p>当publish消息的时候，P可能还会指定消息的属性（meta-data），可能一些meta会被broker使用，而其余的都是由C来使用的。</p>\n\n<p>因为网络不可靠，应用可能处理消息的时候就挂掉了，所以就有一个<code>消息确认机制message acknowledgements</code>:当消息传递给C的时候需要通知broker。当使用消息确认机制的时候，一个broker只有在收到C对于此消息已经被接收的通知后才会删除消息。</p>\n\n<p>某些场景，消息发不到合适的C的时候，消息可能会被返回给P，丢弃，或者说放进一个“死亡队列”，由P来决定如何操作。</p>\n\n<p>队列，交换机，绑定作为AMQP中协作的三个元素。（Queues, exchanges and bindings are collectively referred to as AMQP entities.）</p>\n\n<h2>3 Exchanges and Exchange Types交换机和交换类型</h2>\n\n<p>交换机可以理解成具有路由表的路由程序，仅此而已。每个消息都有一个称为路由键（routing key）的属性，就是一个简单的字符串。交换机当中有一系列的绑定（binding），即路由规则（routes），例如，指明具有路由键 “X” 的消息要到名为timbuku的队列当中去。</p>\n\n<p>交换机从P中接收到一个消息，然后路由(route)发送到一个或者多个队列，AMQP 0-9-1 brokers提供了四种交换类型。</p>\n\n<pre><code>交换类型                默认名字\nDirect exchange      空字符串或者amq.direct\nFanout exchange      amq.Fanout\nTopic exchange       amq.Topic\nHeaders exchange     amq.match (and amq.headers in RabbitMQ)\n</code></pre>\n\n<p>除了交换类型以后，定义交换机的时候还有其他的属性，最重要的几个是：</p>\n\n<ul>\n<li>Name</li>\n<li>Durability（当broker重启后交换机是否能继续工作）</li>\n<li>Auto-delete（所有队列都适用完以后，交换机就被删除）</li>\n<li>Arguments（根据broker的选择而定）</li>\n</ul>\n\n<p>exchanges交换机有两种模式(交换模式与交换类型概念不一样)，Durability表示在broker重启的时候能够恢复之前的工作，而transient模式下则会丢失之前的数据。</p>\n\n<h3>3.1 默认交换exchange</h3>\n\n<p>默认的交换机是一个已经预定义了的没有名字的Direct交换模式，他有一个简单的特性：每创建一个队列，都会通过一个routing&#95;key与exchange绑定，而这个routing&#95;key是和队列名字一样的。</p>\n\n<h3>3.2 直接交换Direct exchange</h3>\n\n<p>处理路由键。需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。这是一个完整的匹配。如果一个队列绑定到该交换机上要求路由键 “dog”，则只有被标记为“dog”的消息才被转发，不会转发dog.puppy，也不会转发dog.guard，只会转发dog。</p>\n\n<ul>\n<li>一个队列通过routing_key K与一个exchange绑定。</li>\n<li>当一个携带routing_key K的消息到达exchange的时候，exchange将消息路由给队列。</li>\n</ul>\n\n<p>直接交换主要用来在多个C，或者说worker（相同的程序实例）之间通过轮训方式分发任务，但是要记住，在AMQP 0-9-1中，消息时在C之间进行负载均衡而不是队列之间进行的。直接交换可以看看下图： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-2.png\" alt=\"amqp-intro-2\" width=\"689\" height=\"511\" class=\"alignnone size-full wp-image-62\" /></a></p>\n\n<h3>3.3 fanout Exchange</h3>\n\n<p>fanout模式将消息发送给所有与之绑定的队列，不处理路由键。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout交换机转发消息是最快的。如下图： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-3-fanout.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-3-fanout.png\" alt=\"amqp-intro-3-fanout\" width=\"713\" height=\"447\" class=\"alignnone size-full wp-image-61\" /></a></p>\n\n<h3>3.4 Topic exchange</h3>\n\n<p>根据消息的routing_key以及队列和交换机绑定的类型，Topic Exchange把消息传递给一个或者多个队列。这就是一个多播的概念。当场景中需要多个C，并且C是有根据的获得消息的时候，Topic Exchange就应该被考虑。具体来说，就是将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“<em>”匹配不多不少一个词。因此“audit.#”能够匹配到“audit.irs.corporate”，但是“audit.</em>” 只会匹配到“audit.irs”。</p>\n\n<h3>3.5 Headers Exchange</h3>\n\n<p>如果不适应routing&#95;key，而是根据消息的多个属性（表现为消息头的形式）的交换就是Headers Exchange，Headers Exchange会忽略routing&#95;key值，相反，用来路由的信息实行消息的头属性中获得的。</p>\n\n<h2>5 队列Queue</h2>\n\n<p>在AMQP中队列就是一个消息的管道，存储C需要的消息，队列知道exchange的一些属性，同时增加了一些自己的属性：</p>\n\n<ul>\n<li>名字</li>\n<li>持续性（Durability），队列在broker重启后恢复</li>\n<li>Exclusive，单个连接中使用，连接断掉后队列被删除</li>\n<li>auto-delete：当C不在获得消息的时候队列被删除</li>\n<li>Arguments：一些broker自己实现的附加功能</li>\n</ul>\n\n<p>在队列使用之前必须被申明（declare），当队列不存在的时候申明队列会创建一个队列，如果队列已经存在，申明队列就不会进行其他操作，但是可以完成对队列存在与否的确认。</p>\n\n<h3>5.1 Queue Names</h3>\n\n<p>应用需要提供队列名，这样broker才能产生一个相应的队列。UTF-8格式，最多255字节，提供一个空字符作为队列名的话，broker会产生一个唯一的队列，同样的方式在C端也可以保证C取得的是P端产生的对应序列，因为P,C都是在一个channel下，而channel是能够记住上一次服务器产生的队列名的。</p>\n\n<p>队列名以\"amq.\"开头的是用于broker内部使用的队列。</p>\n\n<h3>5.2 Queue Durability</h3>\n\n<p>持续当broker重启的时候队列能够恢复，不具有持续性的队列就叫做transient。但是，<code>这里队列的持续性只是当broker重启的时候会自动重新申明队列，而要保证消息不丢失，还需要设置消息为永久性的（消息就存于磁盘而不是内存中）。</code></p>\n\n<h3>5.3 Bindings</h3>\n\n<p>bindings就是一些规则，用来决定消息要路由到哪个队列中去，比如，需要一个交换机E路由一个消息到队列Q，则Q需要先和E进行绑定。Bindings可能需要一些可选的routing&#95;key，routing&#95;key的作用就是选择被publish的特定信息到相应绑定的队列，换句话说，routing_key有点像是一个过滤器。举个例子:</p>\n\n<ul>\n<li>你住在纽约，队列就相当于你的目的地</li>\n<li>交换机就相当于XXX航空</li>\n<li>bindinds就XXX航空到你的住址的线路，可能没得，也可能有多条</li>\n</ul>\n\n<p>如果消息无法送到相应的队列，那么就会丢弃或者返回给P,这些就看相应的机制是怎么样的了。</p>\n\n<h3>5.6 Consumers</h3>\n\n<p>在队列中存储的消息一定要被C所使用。在AMQP 0-9-1模型中，应用程序有两种处理消息的模式：</p>\n\n<ul>\n<li>队列主动把消息传递给C应用(push API)</li>\n<li>C从队列中抓取自己需要的消息(pull API)</li>\n</ul>\n\n<p>在push模式下，应用C需要指明对哪个序列的哪类消息感兴趣，我们称此时队列注册了一个C，或者C订阅了一个队列。一个队列可以有多个C。</p>\n\n<p>每个C都有一个标示符叫做consumer tag，可以用来取消(unsubscribe)对队列消息的订阅，这个tag是一个字符串。</p>\n\n<h2>6 Message消息</h2>\n\n<h3>6.1 Message Acknowledgements 消息确认机制</h3>\n\n<p>Consumer applications-取得消息并且处理消息的应用，有时候可能会因为各种问题挂掉，于是乎就有，AMQP broker如何知道这个消息已经被C接收，是可以删除掉了？AMQP标准中给出了两个选择：</p>\n\n<ul>\n<li>在broker向C应用发送了一个消息后，消息可以被删除(使用basic.deliver or basic.get-ok AMQP方法)</li>\n<li>在C应用返回了一个确认ACK消息以后，消息可以被删除(使用basic.ack AMQP方法)</li>\n</ul>\n\n<p>前一种被叫做自动确认模型(automatic acknowledgement model)，后一种被叫做严格确认模型?(explicit acknowledgement model),在严格模式下C可以选择何时返回这个ACK信息。可以在接收消息的时候就返回，或者处理完消息携带的任务信息以后再返回。</p>\n\n<p>如果C挂掉，并且没有返回ACK信息，那么AMQP broker就会把消息传递给其他的C，如果当前没有可用的C存在，broker就等待，知道有新的C加入进来。</p>\n\n<h3>6.2 Rejecting Messages拒绝消息</h3>\n\n<p>当C取得了消息，但是处理过程中可能不成功，此时C就需要通过拒绝消息机制告诉broker这个消息处理失败，当拒绝消息的时候，C可以要求broker忽略或者从新把消息入队。</p>\n\n<h3>6.3 Negative acknowledgements</h3>\n\n<p>通过<code>basic.reject AMQP</code>方法消息就会被拒绝，但是这个方法有个限制：没办法拒绝一连串的多个消息，但是在RabbitMQ中，有一个解决方案，RabbitMQ提出了一种negative acknowledgements(nacks)机制，更多请参考RabbitMQ手册。</p>\n\n<h3>6.4 Prefetching Messages</h3>\n\n<p>在多个C存在的时候，最好有一种机制指定每个C在返回ACK之前最多能接收多少个消息，这个就有点像负载均衡的思想了。</p>\n\n<h3>6.5 Message Attributes and Payload</h3>\n\n<p>在AMQP中的消息时可以附带属性值(attributes)的，一些常见的属性有：</p>\n\n<ul>\n<li>Content type</li>\n<li>Content encoding</li>\n<li>Routing key</li>\n<li>Delivery mode (persistent or not)</li>\n<li>Message priority</li>\n<li>Message publishing timestamp</li>\n<li>Expiration period</li>\n<li>Producer application id</li>\n</ul>\n\n<p>一些属性可以被选作是消息的头信息。类似HTTP中的X-headers。AMQP消息也有一个负载段（playload），承载相应的数据。broker不会检测和修改负载，当消息被设置成persistent的时候，AMQP broker就会把消息存在磁盘中而不会丢失了。</p>\n\n<h3>6.6 Message acknowledgements</h3>\n\n<h2>7 AMQP 0-9-1 Methods</h2>\n\n<p>AMQP 0-9-1 被组织成各种各样的方法Methods,方法就是某些操作，类似HTTP Method但是和面向对象语言中的方法没有一点关系。AMQP方法被组织成各种类classes,类Class就是方法的集合。比如我们看看exchange class，就有一下操作：</p>\n\n<p>exchange.declare exchange.declare-ok exchange.delete exchange.delete-ok</p>\n\n<p>举例如下： 一个客户端请求broker申明一个新的交换机，使用exchange.declare方法，当然，申明中需要一些参数： 如果成功，broker就会使用exchange.declare-ok方法返回一个成功的标示。 <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e1.png\" alt=\"amqp-intro-4-e1\" width=\"566\" height=\"160\" class=\"alignnone size-full wp-image-63\" /></a> <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e2.png\" alt=\"amqp-intro-4-e2\" width=\"574\" height=\"161\" class=\"alignnone size-full wp-image-64\" /></a></p>\n\n<p>同样道理，对于队列类，也有这么一些方法： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e3.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e3.png\" alt=\"amqp-intro-4-e3\" width=\"571\" height=\"156\" class=\"alignnone size-full wp-image-65\" /></a> <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e4.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e4.png\" alt=\"amqp-intro-4-e4\" width=\"582\" height=\"161\" class=\"alignnone size-full wp-image-66\" /></a></p>\n\n<h3>7.1 Connections</h3>\n\n<p>AMQP的连接是长期的，AMQP是一个应用层，使用TCP来完成可靠的消息传递。AMQP的连接使用了认证并且可以使用TLS等加密协议。当一个应用不再需要与AMQP broker连接的时候，他需要友好的断开连接。</p>\n\n<h3>7.2 Channels</h3>\n\n<p>一些应用程序需要与AMQP broker建立多个连接，但是，同时保持多个TCP连接会消耗大量资源。AMQP 0-9-1提出了Channels的概念，Channels可以被认为是<code>在一个TCP连接中多个轻量级的连接</code>。</p>\n\n<p>对于多线程/进程应用，很常见的做法就是一个线程/进程打开一个channel，并且channel之间不共享。</p>\n\n<p>一个channel上的通信与另外一个channel间的通信时完全独立的，所以每个AMQP方法都会携带一个channel号，通过channel号，应用就知道这个方法是出于哪个channel上的。</p>\n\n<h2>7.3 Virtual Hosts</h2>\n\n<p>一个AMQP broler可以产生多个独立的\"环境\"，这就是vhost的概念。就类似于apache等的vhost一样，AMQP客户可以通过协商选择与哪个vhost进行连接。</p>\n\n<h2>参考资料:</h2>\n\n<p><a href=\"http://www.rabbitmq.com/tutorials/amqp-concepts.html\">http://www.rabbitmq.com/tutorials/amqp-concepts.html</a> <a href=\"http://langyu.iteye.com/blog/759663/\">http://langyu.iteye.com/blog/759663/</a> <a href=\"http://pythoner.net/wiki/110/\">http://pythoner.net/wiki/110/</a> <a href=\"http://blog.csdn.net/zhangxinrun/article/details/6546479\">http://blog.csdn.net/zhangxinrun/article/details/6546479</a> <a href=\"http://sunjun041640.blog.163.com/blog/static/25626832201032990829/\">http://sunjun041640.blog.163.com/blog/static/25626832201032990829/</a> <a href=\"http://www.oschina.net/question/12_9192\">http://www.oschina.net/question/12_9192</a> book:RabbitMQ in Action</p>\n','AMQP&RabbitMQ协议及模型入门介绍','','publish','open','open','','introduce-to-amqp-rabbitmq','','','2013-02-28 20:29:38','2013-02-28 12:29:38','','0','http://blog.wachang.net/?p=54','0','post','','0');");
E_D("replace into `wp_posts` values('55','1','2013-02-28 19:54:29','2013-02-28 11:54:29','','amqp-protocol','','inherit','open','open','','amqp-protocol','','','2013-02-28 19:54:29','2013-02-28 11:54:29','','54','http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('56','1','2013-02-28 19:57:42','2013-02-28 11:57:42','<blockquote>\n  <p>1本文主要是翻译加总结，通过资料的查询，对AMQP有一定了解; 2 RabbitMQ使用的就是AMQP 0-9-1模型，所以本文其实也是在讲RabbitMQ中的一些原理 3 文末会列出原文地址</p>\n</blockquote>\n\n<h2>1 What is AMQP?</h2>\n\n<p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，一个网络应用层协议的开放标准，为面向消息的中间件设计。</p>\n\n<p>说白了，这就是一个消费者生产者模型，生产者生产出一个消息，发送到一个队列Queue，消费者(也叫做worker)从队列里面取出这个消息。但是AMQP中，这个消息一般来说是一个任务，生产者消费者一般不在同一台机器上，所以，更好的解释就是，一个程序发送一个任务消息给一个队列，然后消费者程序从队列中拿出这个任务信息，进行执行，可能还需要返回结果。</p>\n\n<p>而RabbitMQ，就是实现了这么一个模型的软件，独立的开源实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、 Ruby、.NET、Java、JMS、C、PHP、 ActionScript、XMPP、STOMP等，支持AJAX。RabbitMQ就是一个服务器，实现了队列的管理，一个程序连接这个服务器，把任务发送给服务器（也即是进入了队列），消费者连接服务器，从队列中取出任务消息，然后执行。</p>\n\n<p>中英文对照：\nMessaging broker:消息协商器,它在TCP/IP等端口监听AMQ消息，其实就是AMQP的实现，比如RabbitMQ等。\nproducers：应用程序，产生消息，并publish到消息队列中，下文简称P。\nconsumers：应用程序，接收消息，然后进行处理，下文简称C。\nAMQP client：AMQP客户端，指与AMQP broker连接的P或者C。</p>\n\n<h2>2 AMQP协议</h2>\n\n<h3>2.1 协议概述</h3>\n\n<p>从整体来看，AMQP协议可划分为三层：\n<a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-256x300.png\" alt=\"amqp-protocol\" width=\"256\" height=\"300\" class=\"alignnone size-medium wp-image-55\" /></a>\nAMQP定义了合适的服务器端域模型，用于规范服务器的行为(AMQP服务器端可称为broker)。在这里Model层决定这些基本域模型所产生的行为，这种行为在AMQP中用”command”表示，在后文中会着重来分析这些域模型。Session层定义客户端与broker之间的通信(通信双方都是一个peer，可互称做partner)，为command的可靠传输提供保障。Transport层专注于数据传送，并与Session保持交互，接受上层的数据，组装成二进制流，传送到receiver后再解析数据，交付给Session层。Session层需要Transport层完成网络异常情况的汇报，顺序传送command等工作。</p>\n\n<h3>2.2 协议模型</h3>\n\n<p>AMQP broker主要功能是消息的路由(Routing)和缓存(Buffering)，如下图：\nExchange接收消息生产者(Producer)发送的消息根据不同的路由算法将消息发送往Message queue。Message queue会在消息不能被正常消费时缓存这些消息，具体的缓存策略由实现者决定，当message queue与消息消费者(Message consumer)之间的连接通畅时，Message queue有将消息转发到consumer的责任。</p>\n\n<p>Message是当前模型中所操纵的基本单位,基本结构有两部分: Header和Body(playload),Header是由Producer添加上的各种属性的集合，这些属性有控制Message是否可被缓存，接收的queue是哪个，优先级是多少等。Body是真正需要传送的数据，它是对Broker不可见的二进制数据流，在传输过程中不应该受到影响。</p>\n\n<p>一个broker中会存在多个Message queue，Exchange通过binding知道要把消息发送到哪个Message queue,在创建Message queue后需要确定它来接收并保存哪个Exchange路由的结果。Binding是用来关联Exchange与Message queue的域模型,通过关键字bindinds&#95;key。</p>\n\n<p>在与多个Message queue关联后，Exchange中就会存在一个路由表，这个表中存储着每个Message queue所需要消息的限制条件。Exchange就会检查它接受到的每个Message的Header及Body信息，来决定将Message路由到哪个queue中去。Message的Header中应该有个属性叫Routing Key，它由Message发送者产生，提供给Exchange路由这条Message的标准。Exchange根据不同路由算法有不同有Exchange Type。比如有Direct类似，需要Binding key 等于Routing key；也有Binding key与Routing key符合一个模式关系；也有根据Message包含的某些属性来判断。一些基础的路由算法由AMQP所提供，client application也可以自定义各种自己的扩展路由算法。</p>\n\n<p>对于，上图，有一些具体的概念，下面会详细讨论。</p>\n\n<h3>2.3 AMQP 0-9-1 Model流程</h3>\n\n<p>AMQP 0-9-1 Model可以简单的总结如下:P产生消息，然后publish(发布)到exchange(交换机，类比成邮政的邮筒吧)，exchange根据一个规则(bindinds)把消息发送到队列(queue)中，消息协商器要么把消息传递给等待(订阅subdcribe)在某一队列上的的消费者(consumers)，要么消费者就从队列中根据自己的需要取消息。如下图：</p>\n\n<p>图1</p>\n\n<p>当publish消息的时候，P可能还会指定消息的属性（meta-data），可能一些meta会被broker使用，而其余的都是由C来使用的。</p>\n\n<p>因为网络不可靠，应用可能处理消息的时候就挂掉了，所以就有一个<code>消息确认机制message acknowledgements</code>:当消息传递给C的时候需要通知broker。当使用消息确认机制的时候，一个broker只有在收到C对于此消息已经被接收的通知后才会删除消息。</p>\n\n<p>某些场景，消息发不到合适的C的时候，消息可能会被返回给P，丢弃，或者说放进一个“死亡队列”，由P来决定如何操作。</p>\n\n<p>队列，交换机，绑定作为AMQP中协作的三个元素。（Queues, exchanges and bindings are collectively referred to as AMQP entities.）</p>\n\n<h2>3 Exchanges and Exchange Types交换机和交换类型</h2>\n\n<p>交换机可以理解成具有路由表的路由程序，仅此而已。每个消息都有一个称为路由键（routing key）的属性，就是一个简单的字符串。交换机当中有一系列的绑定（binding），即路由规则（routes），例如，指明具有路由键 “X” 的消息要到名为timbuku的队列当中去。</p>\n\n<p>交换机从P中接收到一个消息，然后路由(route)发送到一个或者多个队列，AMQP 0-9-1 brokers提供了四种交换类型。</p>\n\n<pre><code>交换类型                默认名字\nDirect exchange      空字符串或者amq.direct\nFanout exchange      amq.Fanout\nTopic exchange       amq.Topic\nHeaders exchange     amq.match (and amq.headers in RabbitMQ)\n</code></pre>\n\n<p>除了交换类型以后，定义交换机的时候还有其他的属性，最重要的几个是：</p>\n\n<ul>\n<li>Name</li>\n<li>Durability（当broker重启后交换机是否能继续工作）</li>\n<li>Auto-delete（所有队列都适用完以后，交换机就被删除）</li>\n<li>Arguments（根据broker的选择而定）</li>\n</ul>\n\n<p>exchanges交换机有两种模式(交换模式与交换类型概念不一样)，Durability表示在broker重启的时候能够恢复之前的工作，而transient模式下则会丢失之前的数据。</p>\n\n<h3>3.1 默认交换exchange</h3>\n\n<p>默认的交换机是一个已经预定义了的没有名字的Direct交换模式，他有一个简单的特性：每创建一个队列，都会通过一个routing_key与exchange绑定，而这个routing_key是和队列名字一样的。</p>\n\n<h3>3.2 直接交换Direct exchange</h3>\n\n<p>处理路由键。需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。这是一个完整的匹配。如果一个队列绑定到该交换机上要求路由键 “dog”，则只有被标记为“dog”的消息才被转发，不会转发dog.puppy，也不会转发dog.guard，只会转发dog。</p>\n\n<ul>\n<li>一个队列通过routing_key K与一个exchange绑定。</li>\n<li>当一个携带routing_key K的消息到达exchange的时候，exchange将消息路由给队列。</li>\n</ul>\n\n<p>直接交换主要用来在多个C，或者说worker（相同的程序实例）之间通过轮训方式分发任务，但是要记住，在AMQP 0-9-1中，消息时在C之间进行负载均衡而不是队列之间进行的。直接交换可以看看下图：</p>\n\n<h3>3.3 fanout Exchange</h3>\n\n<p>fanout模式将消息发送给所有与之绑定的队列，不处理路由键。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout交换机转发消息是最快的。如下图：</p>\n\n<h3>3.4 Topic exchange</h3>\n\n<p>根据消息的routing_key以及队列和交换机绑定的类型，Topic Exchange把消息传递给一个或者多个队列。这就是一个多播的概念。当场景中需要多个C，并且C是有根据的获得消息的时候，Topic Exchange就应该被考虑。具体来说，就是将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“<em>”匹配不多不少一个词。因此“audit.#”能够匹配到“audit.irs.corporate”，但是“audit.</em>” 只会匹配到“audit.irs”。</p>\n\n<h3>3.5 Headers Exchange</h3>\n\n<p>如果不适应routing_key，而是根据消息的多个属性（表现为消息头的形式）的交换就是Headers Exchange，Headers Exchange会忽略routing_key值，相反，用来路由的信息实行消息的头属性中获得的。</p>\n\n<h2>5 队列Queue</h2>\n\n<p>在AMQP中队列就是一个消息的管道，存储C需要的消息，队列知道exchange的一些属性，同时增加了一些自己的属性：</p>\n\n<ul>\n<li>名字</li>\n<li>持续性（Durability），队列在broker重启后恢复</li>\n<li>Exclusive，单个连接中使用，连接断掉后队列被删除</li>\n<li>auto-delete：当C不在获得消息的时候队列被删除</li>\n<li>Arguments：一些broker自己实现的附加功能</li>\n</ul>\n\n<p>在队列使用之前必须被申明（declare），当队列不存在的时候申明队列会创建一个队列，如果队列已经存在，申明队列就不会进行其他操作，但是可以完成对队列存在与否的确认。</p>\n\n<h3>5.1 Queue Names</h3>\n\n<p>应用需要提供队列名，这样broker才能产生一个相应的队列。UTF-8格式，最多255字节，提供一个空字符作为队列名的话，broker会产生一个唯一的队列，同样的方式在C端也可以保证C取得的是P端产生的对应序列，因为P,C都是在一个channel下，而channel是能够记住上一次服务器产生的队列名的。</p>\n\n<p>队列名以\"amq.\"开头的是用于broker内部使用的队列。</p>\n\n<h3>5.2 Queue Durability</h3>\n\n<p>持续当broker重启的时候队列能够恢复，不具有持续性的队列就叫做transient。但是，<code>这里队列的持续性只是当broker重启的时候会自动重新申明队列，而要保证消息不丢失，还需要设置消息为永久性的（消息就存于磁盘而不是内存中）。</code></p>\n\n<h3>5.3 Bindings</h3>\n\n<p>bindings就是一些规则，用来决定消息要路由到哪个队列中去，比如，需要一个交换机E路由一个消息到队列Q，则Q需要先和E进行绑定。Bindings可能需要一些可选的routing_key，routing_key的作用就是选择被publish的特定信息到相应绑定的队列，换句话说，routing_key有点像是一个过滤器。举个例子:</p>\n\n<ul>\n<li>你住在纽约，队列就相当于你的目的地</li>\n<li>交换机就相当于XXX航空</li>\n<li>bindinds就XXX航空到你的住址的线路，可能没得，也可能有多条</li>\n</ul>\n\n<p>如果消息无法送到相应的队列，那么就会丢弃或者返回给P,这些就看相应的机制是怎么样的了。</p>\n\n<h3>5.6 Consumers</h3>\n\n<p>在队列中存储的消息一定要被C所使用。在AMQP 0-9-1模型中，应用程序有两种处理消息的模式：</p>\n\n<ul>\n<li>队列主动把消息传递给C应用(push API)</li>\n<li>C从队列中抓取自己需要的消息(pull API)</li>\n</ul>\n\n<p>在push模式下，应用C需要指明对哪个序列的哪类消息感兴趣，我们称此时队列注册了一个C，或者C订阅了一个队列。一个队列可以有多个C。</p>\n\n<p>每个C都有一个标示符叫做consumer tag，可以用来取消(unsubscribe)对队列消息的订阅，这个tag是一个字符串。</p>\n\n<h2>6 Message消息</h2>\n\n<h3>6.1 Message Acknowledgements 消息确认机制</h3>\n\n<p>Consumer applications-取得消息并且处理消息的应用，有时候可能会因为各种问题挂掉，于是乎就有，AMQP broker如何知道这个消息已经被C接收，是可以删除掉了？AMQP标准中给出了两个选择：</p>\n\n<ul>\n<li>在broker向C应用发送了一个消息后，消息可以被删除(使用basic.deliver or basic.get-ok AMQP方法)</li>\n<li>在C应用返回了一个确认ACK消息以后，消息可以被删除(使用basic.ack AMQP方法)</li>\n</ul>\n\n<p>前一种被叫做自动确认模型(automatic acknowledgement model)，后一种被叫做严格确认模型?(explicit acknowledgement model),在严格模式下C可以选择何时返回这个ACK信息。可以在接收消息的时候就返回，或者处理完消息携带的任务信息以后再返回。</p>\n\n<p>如果C挂掉，并且没有返回ACK信息，那么AMQP broker就会把消息传递给其他的C，如果当前没有可用的C存在，broker就等待，知道有新的C加入进来。</p>\n\n<h3>6.2 Rejecting Messages拒绝消息</h3>\n\n<p>当C取得了消息，但是处理过程中可能不成功，此时C就需要通过拒绝消息机制告诉broker这个消息处理失败，当拒绝消息的时候，C可以要求broker忽略或者从新把消息入队。</p>\n\n<h3>6.3 Negative acknowledgements</h3>\n\n<p>通过<code>basic.reject AMQP</code>方法消息就会被拒绝，但是这个方法有个限制：没办法拒绝一连串的多个消息，但是在RabbitMQ中，有一个解决方案，RabbitMQ提出了一种negative acknowledgements(nacks)机制，更多请参考RabbitMQ手册。</p>\n\n<h3>6.4 Prefetching Messages</h3>\n\n<p>在多个C存在的时候，最好有一种机制指定每个C在返回ACK之前最多能接收多少个消息，这个就有点像负载均衡的思想了。</p>\n\n<h3>6.5 Message Attributes and Payload</h3>\n\n<p>在AMQP中的消息时可以附带属性值(attributes)的，一些常见的属性有：</p>\n\n<ul>\n<li>Content type</li>\n<li>Content encoding</li>\n<li>Routing key</li>\n<li>Delivery mode (persistent or not)</li>\n<li>Message priority</li>\n<li>Message publishing timestamp</li>\n<li>Expiration period</li>\n<li>Producer application id</li>\n</ul>\n\n<p>一些属性可以被选作是消息的头信息。类似HTTP中的X-headers。AMQP消息也有一个负载段（playload），承载相应的数据。broker不会检测和修改负载，当消息被设置成persistent的时候，AMQP broker就会把消息存在磁盘中而不会丢失了。</p>\n\n<h3>6.6 Message acknowledgements</h3>\n\n<h2>7 AMQP 0-9-1 Methods</h2>\n\n<p>AMQP 0-9-1 被组织成各种各样的方法Methods,方法就是某些操作，类似HTTP Method但是和面向对象语言中的方法没有一点关系。AMQP方法被组织成各种类classes,类Class就是方法的集合。比如我们看看exchange class，就有一下操作：</p>\n\n<p>exchange.declare\nexchange.declare-ok\nexchange.delete\nexchange.delete-ok</p>\n\n<p>举例如下：\n一个客户端请求broker申明一个新的交换机，使用exchange.declare方法，当然，申明中需要一些参数：\n如果成功，broker就会使用exchange.declare-ok方法返回一个成功的标示。</p>\n\n<p>同样道理，对于队列类，也有这么一些方法：</p>\n\n<h3>7.1 Connections</h3>\n\n<p>AMQP的连接是长期的，AMQP是一个应用层，使用TCP来完成可靠的消息传递。AMQP的连接使用了认证并且可以使用TLS等加密协议。当一个应用不再需要与AMQP broker连接的时候，他需要友好的断开连接。</p>\n\n<h3>7.2 Channels</h3>\n\n<p>一些应用程序需要与AMQP broker建立多个连接，但是，同时保持多个TCP连接会消耗大量资源。AMQP 0-9-1提出了Channels的概念，Channels可以被认为是<code>在一个TCP连接中多个轻量级的连接</code>。</p>\n\n<p>对于多线程/进程应用，很常见的做法就是一个线程/进程打开一个channel，并且channel之间不共享。</p>\n\n<p>一个channel上的通信与另外一个channel间的通信时完全独立的，所以每个AMQP方法都会携带一个channel号，通过channel号，应用就知道这个方法是出于哪个channel上的。</p>\n\n<h2>7.3 Virtual Hosts</h2>\n\n<p>一个AMQP broler可以产生多个独立的\"环境\"，这就是vhost的概念。就类似于apache等的vhost一样，AMQP客户可以通过协商选择与哪个vhost进行连接。</p>\n\n<h2>参考资料:</h2>\n\n<p><a href=\"http://www.rabbitmq.com/tutorials/amqp-concepts.html\">http://www.rabbitmq.com/tutorials/amqp-concepts.html</a>\n<a href=\"http://langyu.iteye.com/blog/759663/\">http://langyu.iteye.com/blog/759663/</a>\n<a href=\"http://pythoner.net/wiki/110/\">http://pythoner.net/wiki/110/</a>\n<a href=\"http://blog.csdn.net/zhangxinrun/article/details/6546479\">http://blog.csdn.net/zhangxinrun/article/details/6546479</a>\n<a href=\"http://sunjun041640.blog.163.com/blog/static/25626832201032990829/\">http://sunjun041640.blog.163.com/blog/static/25626832201032990829/</a>\n<a href=\"http://www.oschina.net/question/12_9192\">http://www.oschina.net/question/12_9192</a>\n<book:RabbitMQ in Action></p>\n','AMQP&RabbitMQ协议及模型入门介绍','','inherit','open','open','','54-revision','','','2013-02-28 19:57:42','2013-02-28 11:57:42','','54','http://blog.wachang.net/2013/02/54-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('57','1','2013-02-28 20:05:50','2013-02-28 12:05:50','<blockquote>\n  <p>1本文主要是翻译加总结，通过资料的查询，对AMQP有一定了解; 2 RabbitMQ使用的就是AMQP 0-9-1模型，所以本文其实也是在讲RabbitMQ中的一些原理; 3 文末会列出原文地址</p>\n</blockquote>\n\n<h2>1 What is AMQP?</h2>\n\n<p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，一个网络应用层协议的开放标准，为面向消息的中间件设计。</p>\n\n<p>说白了，这就是一个消费者生产者模型，生产者生产出一个消息，发送到一个队列Queue，消费者(也叫做worker)从队列里面取出这个消息。但是AMQP中，这个消息一般来说是一个任务，生产者消费者一般不在同一台机器上，所以，更好的解释就是，一个程序发送一个任务消息给一个队列，然后消费者程序从队列中拿出这个任务信息，进行执行，可能还需要返回结果。</p>\n\n<p>而RabbitMQ，就是实现了这么一个模型的软件，独立的开源实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、 Ruby、.NET、Java、JMS、C、PHP、 ActionScript、XMPP、STOMP等，支持AJAX。RabbitMQ就是一个服务器，实现了队列的管理，一个程序连接这个服务器，把任务发送给服务器（也即是进入了队列），消费者连接服务器，从队列中取出任务消息，然后执行。</p>\n\n<p>中英文对照： Messaging broker:消息协商器,它在TCP/IP等端口监听AMQ消息，其实就是AMQP的实现，比如RabbitMQ等。 producers：应用程序，产生消息，并publish到消息队列中，下文简称P。 consumers：应用程序，接收消息，然后进行处理，下文简称C。 AMQP client：AMQP客户端，指与AMQP broker连接的P或者C。</p>\n\n<h2>2 AMQP协议</h2>\n\n<h3>2.1 协议概述</h3>\n\n<p>从整体来看，AMQP协议可划分为三层： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-256x300.png\" alt=\"amqp-protocol\" width=\"256\" height=\"300\" class=\"alignnone size-medium wp-image-55\" /></a> AMQP定义了合适的服务器端域模型，用于规范服务器的行为(AMQP服务器端可称为broker)。在这里Model层决定这些基本域模型所产生的行为，这种行为在AMQP中用”command”表示，在后文中会着重来分析这些域模型。Session层定义客户端与broker之间的通信(通信双方都是一个peer，可互称做partner)，为command的可靠传输提供保障。Transport层专注于数据传送，并与Session保持交互，接受上层的数据，组装成二进制流，传送到receiver后再解析数据，交付给Session层。Session层需要Transport层完成网络异常情况的汇报，顺序传送command等工作。</p>\n\n<h3>2.2 协议模型</h3>\n\n<p>AMQP broker主要功能是消息的路由(Routing)和缓存(Buffering)，如下图： \n<a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-2.png\" alt=\"amqp-protocol-2\" width=\"571\" height=\"239\" class=\"alignnone size-full wp-image-59\" /></a>\nExchange接收消息生产者(Producer)发送的消息根据不同的路由算法将消息发送往Message queue。Message queue会在消息不能被正常消费时缓存这些消息，具体的缓存策略由实现者决定，当message queue与消息消费者(Message consumer)之间的连接通畅时，Message queue有将消息转发到consumer的责任。</p>\n\n<p>Message是当前模型中所操纵的基本单位,基本结构有两部分: Header和Body(playload),Header是由Producer添加上的各种属性的集合，这些属性有控制Message是否可被缓存，接收的queue是哪个，优先级是多少等。Body是真正需要传送的数据，它是对Broker不可见的二进制数据流，在传输过程中不应该受到影响。</p>\n\n<p>一个broker中会存在多个Message queue，Exchange通过binding知道要把消息发送到哪个Message queue,在创建Message queue后需要确定它来接收并保存哪个Exchange路由的结果。Binding是用来关联Exchange与Message queue的域模型,通过关键字bindinds_key。</p>\n\n<p>在与多个Message queue关联后，Exchange中就会存在一个路由表，这个表中存储着每个Message queue所需要消息的限制条件。Exchange就会检查它接受到的每个Message的Header及Body信息，来决定将Message路由到哪个queue中去。Message的Header中应该有个属性叫Routing Key，它由Message发送者产生，提供给Exchange路由这条Message的标准。Exchange根据不同路由算法有不同有Exchange Type。比如有Direct类似，需要Binding key 等于Routing key；也有Binding key与Routing key符合一个模式关系；也有根据Message包含的某些属性来判断。一些基础的路由算法由AMQP所提供，client application也可以自定义各种自己的扩展路由算法。\n<a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-3.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-3.png\" alt=\"amqp-protocol-3\" width=\"714\" height=\"117\" class=\"alignnone size-full wp-image-58\" /></a>\n对于，上图，有一些具体的概念，下面会详细讨论。</p>\n\n<h3>2.3 AMQP 0-9-1 Model流程</h3>\n\n<p>AMQP 0-9-1 Model可以简单的总结如下:P产生消息，然后publish(发布)到exchange(交换机，类比成邮政的邮筒吧)，exchange根据一个规则(bindinds)把消息发送到队列(queue)中，消息协商器要么把消息传递给等待(订阅subdcribe)在某一队列上的的消费者(consumers)，要么消费者就从队列中根据自己的需要取消息。如下图：\n<a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-11.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-11.png\" alt=\"amqp-intro-1\" width=\"712\" height=\"319\" class=\"alignnone size-full wp-image-60\" /></a></p>\n\n<p>当publish消息的时候，P可能还会指定消息的属性（meta-data），可能一些meta会被broker使用，而其余的都是由C来使用的。</p>\n\n<p>因为网络不可靠，应用可能处理消息的时候就挂掉了，所以就有一个<code>消息确认机制message acknowledgements</code>:当消息传递给C的时候需要通知broker。当使用消息确认机制的时候，一个broker只有在收到C对于此消息已经被接收的通知后才会删除消息。</p>\n\n<p>某些场景，消息发不到合适的C的时候，消息可能会被返回给P，丢弃，或者说放进一个“死亡队列”，由P来决定如何操作。</p>\n\n<p>队列，交换机，绑定作为AMQP中协作的三个元素。（Queues, exchanges and bindings are collectively referred to as AMQP entities.）</p>\n\n<h2>3 Exchanges and Exchange Types交换机和交换类型</h2>\n\n<p>交换机可以理解成具有路由表的路由程序，仅此而已。每个消息都有一个称为路由键（routing key）的属性，就是一个简单的字符串。交换机当中有一系列的绑定（binding），即路由规则（routes），例如，指明具有路由键 “X” 的消息要到名为timbuku的队列当中去。</p>\n\n<p>交换机从P中接收到一个消息，然后路由(route)发送到一个或者多个队列，AMQP 0-9-1 brokers提供了四种交换类型。</p>\n\n<pre><code>交换类型                默认名字\nDirect exchange      空字符串或者amq.direct\nFanout exchange      amq.Fanout\nTopic exchange       amq.Topic\nHeaders exchange     amq.match (and amq.headers in RabbitMQ)\n</code></pre>\n\n<p>除了交换类型以后，定义交换机的时候还有其他的属性，最重要的几个是：</p>\n\n<ul>\n<li>Name</li>\n<li>Durability（当broker重启后交换机是否能继续工作）</li>\n<li>Auto-delete（所有队列都适用完以后，交换机就被删除）</li>\n<li>Arguments（根据broker的选择而定）</li>\n</ul>\n\n<p>exchanges交换机有两种模式(交换模式与交换类型概念不一样)，Durability表示在broker重启的时候能够恢复之前的工作，而transient模式下则会丢失之前的数据。</p>\n\n<h3>3.1 默认交换exchange</h3>\n\n<p>默认的交换机是一个已经预定义了的没有名字的Direct交换模式，他有一个简单的特性：每创建一个队列，都会通过一个routing&#95;key与exchange绑定，而这个routing&#95;key是和队列名字一样的。</p>\n\n<h3>3.2 直接交换Direct exchange</h3>\n\n<p>处理路由键。需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。这是一个完整的匹配。如果一个队列绑定到该交换机上要求路由键 “dog”，则只有被标记为“dog”的消息才被转发，不会转发dog.puppy，也不会转发dog.guard，只会转发dog。</p>\n\n<ul>\n<li>一个队列通过routing_key K与一个exchange绑定。</li>\n<li>当一个携带routing_key K的消息到达exchange的时候，exchange将消息路由给队列。</li>\n</ul>\n\n<p>直接交换主要用来在多个C，或者说worker（相同的程序实例）之间通过轮训方式分发任务，但是要记住，在AMQP 0-9-1中，消息时在C之间进行负载均衡而不是队列之间进行的。直接交换可以看看下图：\n<a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-2.png\" alt=\"amqp-intro-2\" width=\"689\" height=\"511\" class=\"alignnone size-full wp-image-62\" /></a></p>\n\n<h3>3.3 fanout Exchange</h3>\n\n<p>fanout模式将消息发送给所有与之绑定的队列，不处理路由键。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout交换机转发消息是最快的。如下图：\n<a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-3-fanout.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-3-fanout.png\" alt=\"amqp-intro-3-fanout\" width=\"713\" height=\"447\" class=\"alignnone size-full wp-image-61\" /></a></p>\n\n<h3>3.4 Topic exchange</h3>\n\n<p>根据消息的routing_key以及队列和交换机绑定的类型，Topic Exchange把消息传递给一个或者多个队列。这就是一个多播的概念。当场景中需要多个C，并且C是有根据的获得消息的时候，Topic Exchange就应该被考虑。具体来说，就是将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“<em>”匹配不多不少一个词。因此“audit.#”能够匹配到“audit.irs.corporate”，但是“audit.</em>” 只会匹配到“audit.irs”。</p>\n\n<h3>3.5 Headers Exchange</h3>\n\n<p>如果不适应routing&#95;key，而是根据消息的多个属性（表现为消息头的形式）的交换就是Headers Exchange，Headers Exchange会忽略routing&#95;key值，相反，用来路由的信息实行消息的头属性中获得的。</p>\n\n<h2>5 队列Queue</h2>\n\n<p>在AMQP中队列就是一个消息的管道，存储C需要的消息，队列知道exchange的一些属性，同时增加了一些自己的属性：</p>\n\n<ul>\n<li>名字</li>\n<li>持续性（Durability），队列在broker重启后恢复</li>\n<li>Exclusive，单个连接中使用，连接断掉后队列被删除</li>\n<li>auto-delete：当C不在获得消息的时候队列被删除</li>\n<li>Arguments：一些broker自己实现的附加功能</li>\n</ul>\n\n<p>在队列使用之前必须被申明（declare），当队列不存在的时候申明队列会创建一个队列，如果队列已经存在，申明队列就不会进行其他操作，但是可以完成对队列存在与否的确认。</p>\n\n<h3>5.1 Queue Names</h3>\n\n<p>应用需要提供队列名，这样broker才能产生一个相应的队列。UTF-8格式，最多255字节，提供一个空字符作为队列名的话，broker会产生一个唯一的队列，同样的方式在C端也可以保证C取得的是P端产生的对应序列，因为P,C都是在一个channel下，而channel是能够记住上一次服务器产生的队列名的。</p>\n\n<p>队列名以\"amq.\"开头的是用于broker内部使用的队列。</p>\n\n<h3>5.2 Queue Durability</h3>\n\n<p>持续当broker重启的时候队列能够恢复，不具有持续性的队列就叫做transient。但是，<code>这里队列的持续性只是当broker重启的时候会自动重新申明队列，而要保证消息不丢失，还需要设置消息为永久性的（消息就存于磁盘而不是内存中）。</code></p>\n\n<h3>5.3 Bindings</h3>\n\n<p>bindings就是一些规则，用来决定消息要路由到哪个队列中去，比如，需要一个交换机E路由一个消息到队列Q，则Q需要先和E进行绑定。Bindings可能需要一些可选的routing&#95;key，routing&#95;key的作用就是选择被publish的特定信息到相应绑定的队列，换句话说，routing_key有点像是一个过滤器。举个例子:</p>\n\n<ul>\n<li>你住在纽约，队列就相当于你的目的地</li>\n<li>交换机就相当于XXX航空</li>\n<li>bindinds就XXX航空到你的住址的线路，可能没得，也可能有多条</li>\n</ul>\n\n<p>如果消息无法送到相应的队列，那么就会丢弃或者返回给P,这些就看相应的机制是怎么样的了。</p>\n\n<h3>5.6 Consumers</h3>\n\n<p>在队列中存储的消息一定要被C所使用。在AMQP 0-9-1模型中，应用程序有两种处理消息的模式：</p>\n\n<ul>\n<li>队列主动把消息传递给C应用(push API)</li>\n<li>C从队列中抓取自己需要的消息(pull API)</li>\n</ul>\n\n<p>在push模式下，应用C需要指明对哪个序列的哪类消息感兴趣，我们称此时队列注册了一个C，或者C订阅了一个队列。一个队列可以有多个C。</p>\n\n<p>每个C都有一个标示符叫做consumer tag，可以用来取消(unsubscribe)对队列消息的订阅，这个tag是一个字符串。</p>\n\n<h2>6 Message消息</h2>\n\n<h3>6.1 Message Acknowledgements 消息确认机制</h3>\n\n<p>Consumer applications-取得消息并且处理消息的应用，有时候可能会因为各种问题挂掉，于是乎就有，AMQP broker如何知道这个消息已经被C接收，是可以删除掉了？AMQP标准中给出了两个选择：</p>\n\n<ul>\n<li>在broker向C应用发送了一个消息后，消息可以被删除(使用basic.deliver or basic.get-ok AMQP方法)</li>\n<li>在C应用返回了一个确认ACK消息以后，消息可以被删除(使用basic.ack AMQP方法)</li>\n</ul>\n\n<p>前一种被叫做自动确认模型(automatic acknowledgement model)，后一种被叫做严格确认模型?(explicit acknowledgement model),在严格模式下C可以选择何时返回这个ACK信息。可以在接收消息的时候就返回，或者处理完消息携带的任务信息以后再返回。</p>\n\n<p>如果C挂掉，并且没有返回ACK信息，那么AMQP broker就会把消息传递给其他的C，如果当前没有可用的C存在，broker就等待，知道有新的C加入进来。</p>\n\n<h3>6.2 Rejecting Messages拒绝消息</h3>\n\n<p>当C取得了消息，但是处理过程中可能不成功，此时C就需要通过拒绝消息机制告诉broker这个消息处理失败，当拒绝消息的时候，C可以要求broker忽略或者从新把消息入队。</p>\n\n<h3>6.3 Negative acknowledgements</h3>\n\n<p>通过<code>basic.reject AMQP</code>方法消息就会被拒绝，但是这个方法有个限制：没办法拒绝一连串的多个消息，但是在RabbitMQ中，有一个解决方案，RabbitMQ提出了一种negative acknowledgements(nacks)机制，更多请参考RabbitMQ手册。</p>\n\n<h3>6.4 Prefetching Messages</h3>\n\n<p>在多个C存在的时候，最好有一种机制指定每个C在返回ACK之前最多能接收多少个消息，这个就有点像负载均衡的思想了。</p>\n\n<h3>6.5 Message Attributes and Payload</h3>\n\n<p>在AMQP中的消息时可以附带属性值(attributes)的，一些常见的属性有：</p>\n\n<ul>\n<li>Content type</li>\n<li>Content encoding</li>\n<li>Routing key</li>\n<li>Delivery mode (persistent or not)</li>\n<li>Message priority</li>\n<li>Message publishing timestamp</li>\n<li>Expiration period</li>\n<li>Producer application id</li>\n</ul>\n\n<p>一些属性可以被选作是消息的头信息。类似HTTP中的X-headers。AMQP消息也有一个负载段（playload），承载相应的数据。broker不会检测和修改负载，当消息被设置成persistent的时候，AMQP broker就会把消息存在磁盘中而不会丢失了。</p>\n\n<h3>6.6 Message acknowledgements</h3>\n\n<h2>7 AMQP 0-9-1 Methods</h2>\n\n<p>AMQP 0-9-1 被组织成各种各样的方法Methods,方法就是某些操作，类似HTTP Method但是和面向对象语言中的方法没有一点关系。AMQP方法被组织成各种类classes,类Class就是方法的集合。比如我们看看exchange class，就有一下操作：</p>\n\n<p>exchange.declare exchange.declare-ok exchange.delete exchange.delete-ok</p>\n\n<p>举例如下： 一个客户端请求broker申明一个新的交换机，使用exchange.declare方法，当然，申明中需要一些参数： 如果成功，broker就会使用exchange.declare-ok方法返回一个成功的标示。\n<a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e1.png\" alt=\"amqp-intro-4-e1\" width=\"566\" height=\"160\" class=\"alignnone size-full wp-image-63\" /></a>\n<a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e2.png\" alt=\"amqp-intro-4-e2\" width=\"574\" height=\"161\" class=\"alignnone size-full wp-image-64\" /></a></p>\n\n<p>同样道理，对于队列类，也有这么一些方法：\n<a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e3.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e3.png\" alt=\"amqp-intro-4-e3\" width=\"571\" height=\"156\" class=\"alignnone size-full wp-image-65\" /></a>\n<a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e4.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e4.png\" alt=\"amqp-intro-4-e4\" width=\"582\" height=\"161\" class=\"alignnone size-full wp-image-66\" /></a></p>\n\n<h3>7.1 Connections</h3>\n\n<p>AMQP的连接是长期的，AMQP是一个应用层，使用TCP来完成可靠的消息传递。AMQP的连接使用了认证并且可以使用TLS等加密协议。当一个应用不再需要与AMQP broker连接的时候，他需要友好的断开连接。</p>\n\n<h3>7.2 Channels</h3>\n\n<p>一些应用程序需要与AMQP broker建立多个连接，但是，同时保持多个TCP连接会消耗大量资源。AMQP 0-9-1提出了Channels的概念，Channels可以被认为是<code>在一个TCP连接中多个轻量级的连接</code>。</p>\n\n<p>对于多线程/进程应用，很常见的做法就是一个线程/进程打开一个channel，并且channel之间不共享。</p>\n\n<p>一个channel上的通信与另外一个channel间的通信时完全独立的，所以每个AMQP方法都会携带一个channel号，通过channel号，应用就知道这个方法是出于哪个channel上的。</p>\n\n<h2>7.3 Virtual Hosts</h2>\n\n<p>一个AMQP broler可以产生多个独立的\"环境\"，这就是vhost的概念。就类似于apache等的vhost一样，AMQP客户可以通过协商选择与哪个vhost进行连接。</p>\n\n<h2>参考资料:</h2>\n\n<p><a href=\"http://www.rabbitmq.com/tutorials/amqp-concepts.html\">http://www.rabbitmq.com/tutorials/amqp-concepts.html</a> <a href=\"http://langyu.iteye.com/blog/759663/\">http://langyu.iteye.com/blog/759663/</a> <a href=\"http://pythoner.net/wiki/110/\">http://pythoner.net/wiki/110/</a> <a href=\"http://blog.csdn.net/zhangxinrun/article/details/6546479\">http://blog.csdn.net/zhangxinrun/article/details/6546479</a> <a href=\"http://sunjun041640.blog.163.com/blog/static/25626832201032990829/\">http://sunjun041640.blog.163.com/blog/static/25626832201032990829/</a> <a href=\"http://www.oschina.net/question/12_9192\">http://www.oschina.net/question/12_9192</a> <book:RabbitMQ in Action></p>\n','AMQP&RabbitMQ协议及模型入门介绍','','inherit','open','open','','54-autosave','','','2013-02-28 20:05:50','2013-02-28 12:05:50','','54','http://blog.wachang.net/2013/02/54-autosave/','0','revision','','0');");
E_D("replace into `wp_posts` values('58','1','2013-02-28 20:00:30','2013-02-28 12:00:30','','amqp-protocol-3','','inherit','open','open','','amqp-protocol-3','','','2013-02-28 20:00:30','2013-02-28 12:00:30','','54','http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-3.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('59','1','2013-02-28 20:01:26','2013-02-28 12:01:26','','amqp-protocol-2','','inherit','open','open','','amqp-protocol-2','','','2013-02-28 20:01:26','2013-02-28 12:01:26','','54','http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-2.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('60','1','2013-02-28 20:02:25','2013-02-28 12:02:25','','amqp-intro-1','','inherit','open','open','','amqp-intro-1-2','','','2013-02-28 20:02:25','2013-02-28 12:02:25','','54','http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-11.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('61','1','2013-02-28 20:03:02','2013-02-28 12:03:02','','amqp-intro-3-fanout','','inherit','open','open','','amqp-intro-3-fanout','','','2013-02-28 20:03:02','2013-02-28 12:03:02','','54','http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-3-fanout.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('62','1','2013-02-28 20:03:29','2013-02-28 12:03:29','','amqp-intro-2','','inherit','open','open','','amqp-intro-2','','','2013-02-28 20:03:29','2013-02-28 12:03:29','','54','http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-2.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('63','1','2013-02-28 20:04:46','2013-02-28 12:04:46','','amqp-intro-4-e1','','inherit','open','open','','amqp-intro-4-e1','','','2013-02-28 20:04:46','2013-02-28 12:04:46','','54','http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e1.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('64','1','2013-02-28 20:05:20','2013-02-28 12:05:20','','amqp-intro-4-e2','','inherit','open','open','','amqp-intro-4-e2','','','2013-02-28 20:05:20','2013-02-28 12:05:20','','54','http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e2.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('65','1','2013-02-28 20:05:35','2013-02-28 12:05:35','','amqp-intro-4-e3','','inherit','open','open','','amqp-intro-4-e3','','','2013-02-28 20:05:35','2013-02-28 12:05:35','','54','http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e3.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('66','1','2013-02-28 20:05:44','2013-02-28 12:05:44','','amqp-intro-4-e4','','inherit','open','open','','amqp-intro-4-e4','','','2013-02-28 20:05:44','2013-02-28 12:05:44','','54','http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e4.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('67','1','2013-02-28 19:58:38','2013-02-28 11:58:38','<blockquote>\n  <p>1本文主要是翻译加总结，通过资料的查询，对AMQP有一定了解; 2 RabbitMQ使用的就是AMQP 0-9-1模型，所以本文其实也是在讲RabbitMQ中的一些原理; 3 文末会列出原文地址</p>\n</blockquote>\n\n<h2>1 What is AMQP?</h2>\n\n<p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，一个网络应用层协议的开放标准，为面向消息的中间件设计。</p>\n\n<p>说白了，这就是一个消费者生产者模型，生产者生产出一个消息，发送到一个队列Queue，消费者(也叫做worker)从队列里面取出这个消息。但是AMQP中，这个消息一般来说是一个任务，生产者消费者一般不在同一台机器上，所以，更好的解释就是，一个程序发送一个任务消息给一个队列，然后消费者程序从队列中拿出这个任务信息，进行执行，可能还需要返回结果。</p>\n\n<p>而RabbitMQ，就是实现了这么一个模型的软件，独立的开源实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、 Ruby、.NET、Java、JMS、C、PHP、 ActionScript、XMPP、STOMP等，支持AJAX。RabbitMQ就是一个服务器，实现了队列的管理，一个程序连接这个服务器，把任务发送给服务器（也即是进入了队列），消费者连接服务器，从队列中取出任务消息，然后执行。</p>\n\n<p>中英文对照：\nMessaging broker:消息协商器,它在TCP/IP等端口监听AMQ消息，其实就是AMQP的实现，比如RabbitMQ等。\nproducers：应用程序，产生消息，并publish到消息队列中，下文简称P。\nconsumers：应用程序，接收消息，然后进行处理，下文简称C。\nAMQP client：AMQP客户端，指与AMQP broker连接的P或者C。</p>\n\n<h2>2 AMQP协议</h2>\n\n<h3>2.1 协议概述</h3>\n\n<p>从整体来看，AMQP协议可划分为三层：\n<a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-256x300.png\" alt=\"amqp-protocol\" width=\"256\" height=\"300\" class=\"alignnone size-medium wp-image-55\" /></a>\nAMQP定义了合适的服务器端域模型，用于规范服务器的行为(AMQP服务器端可称为broker)。在这里Model层决定这些基本域模型所产生的行为，这种行为在AMQP中用”command”表示，在后文中会着重来分析这些域模型。Session层定义客户端与broker之间的通信(通信双方都是一个peer，可互称做partner)，为command的可靠传输提供保障。Transport层专注于数据传送，并与Session保持交互，接受上层的数据，组装成二进制流，传送到receiver后再解析数据，交付给Session层。Session层需要Transport层完成网络异常情况的汇报，顺序传送command等工作。</p>\n\n<h3>2.2 协议模型</h3>\n\n<p>AMQP broker主要功能是消息的路由(Routing)和缓存(Buffering)，如下图：\nExchange接收消息生产者(Producer)发送的消息根据不同的路由算法将消息发送往Message queue。Message queue会在消息不能被正常消费时缓存这些消息，具体的缓存策略由实现者决定，当message queue与消息消费者(Message consumer)之间的连接通畅时，Message queue有将消息转发到consumer的责任。</p>\n\n<p>Message是当前模型中所操纵的基本单位,基本结构有两部分: Header和Body(playload),Header是由Producer添加上的各种属性的集合，这些属性有控制Message是否可被缓存，接收的queue是哪个，优先级是多少等。Body是真正需要传送的数据，它是对Broker不可见的二进制数据流，在传输过程中不应该受到影响。</p>\n\n<p>一个broker中会存在多个Message queue，Exchange通过binding知道要把消息发送到哪个Message queue,在创建Message queue后需要确定它来接收并保存哪个Exchange路由的结果。Binding是用来关联Exchange与Message queue的域模型,通过关键字bindinds&#95;key。</p>\n\n<p>在与多个Message queue关联后，Exchange中就会存在一个路由表，这个表中存储着每个Message queue所需要消息的限制条件。Exchange就会检查它接受到的每个Message的Header及Body信息，来决定将Message路由到哪个queue中去。Message的Header中应该有个属性叫Routing Key，它由Message发送者产生，提供给Exchange路由这条Message的标准。Exchange根据不同路由算法有不同有Exchange Type。比如有Direct类似，需要Binding key 等于Routing key；也有Binding key与Routing key符合一个模式关系；也有根据Message包含的某些属性来判断。一些基础的路由算法由AMQP所提供，client application也可以自定义各种自己的扩展路由算法。</p>\n\n<p>对于，上图，有一些具体的概念，下面会详细讨论。</p>\n\n<h3>2.3 AMQP 0-9-1 Model流程</h3>\n\n<p>AMQP 0-9-1 Model可以简单的总结如下:P产生消息，然后publish(发布)到exchange(交换机，类比成邮政的邮筒吧)，exchange根据一个规则(bindinds)把消息发送到队列(queue)中，消息协商器要么把消息传递给等待(订阅subdcribe)在某一队列上的的消费者(consumers)，要么消费者就从队列中根据自己的需要取消息。如下图：</p>\n\n<p>图1</p>\n\n<p>当publish消息的时候，P可能还会指定消息的属性（meta-data），可能一些meta会被broker使用，而其余的都是由C来使用的。</p>\n\n<p>因为网络不可靠，应用可能处理消息的时候就挂掉了，所以就有一个<code>消息确认机制message acknowledgements</code>:当消息传递给C的时候需要通知broker。当使用消息确认机制的时候，一个broker只有在收到C对于此消息已经被接收的通知后才会删除消息。</p>\n\n<p>某些场景，消息发不到合适的C的时候，消息可能会被返回给P，丢弃，或者说放进一个“死亡队列”，由P来决定如何操作。</p>\n\n<p>队列，交换机，绑定作为AMQP中协作的三个元素。（Queues, exchanges and bindings are collectively referred to as AMQP entities.）</p>\n\n<h2>3 Exchanges and Exchange Types交换机和交换类型</h2>\n\n<p>交换机可以理解成具有路由表的路由程序，仅此而已。每个消息都有一个称为路由键（routing key）的属性，就是一个简单的字符串。交换机当中有一系列的绑定（binding），即路由规则（routes），例如，指明具有路由键 “X” 的消息要到名为timbuku的队列当中去。</p>\n\n<p>交换机从P中接收到一个消息，然后路由(route)发送到一个或者多个队列，AMQP 0-9-1 brokers提供了四种交换类型。</p>\n\n<pre><code>交换类型                默认名字\nDirect exchange      空字符串或者amq.direct\nFanout exchange      amq.Fanout\nTopic exchange       amq.Topic\nHeaders exchange     amq.match (and amq.headers in RabbitMQ)\n</code></pre>\n\n<p>除了交换类型以后，定义交换机的时候还有其他的属性，最重要的几个是：</p>\n\n<ul>\n<li>Name</li>\n<li>Durability（当broker重启后交换机是否能继续工作）</li>\n<li>Auto-delete（所有队列都适用完以后，交换机就被删除）</li>\n<li>Arguments（根据broker的选择而定）</li>\n</ul>\n\n<p>exchanges交换机有两种模式(交换模式与交换类型概念不一样)，Durability表示在broker重启的时候能够恢复之前的工作，而transient模式下则会丢失之前的数据。</p>\n\n<h3>3.1 默认交换exchange</h3>\n\n<p>默认的交换机是一个已经预定义了的没有名字的Direct交换模式，他有一个简单的特性：每创建一个队列，都会通过一个routing_key与exchange绑定，而这个routing_key是和队列名字一样的。</p>\n\n<h3>3.2 直接交换Direct exchange</h3>\n\n<p>处理路由键。需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。这是一个完整的匹配。如果一个队列绑定到该交换机上要求路由键 “dog”，则只有被标记为“dog”的消息才被转发，不会转发dog.puppy，也不会转发dog.guard，只会转发dog。</p>\n\n<ul>\n<li>一个队列通过routing_key K与一个exchange绑定。</li>\n<li>当一个携带routing_key K的消息到达exchange的时候，exchange将消息路由给队列。</li>\n</ul>\n\n<p>直接交换主要用来在多个C，或者说worker（相同的程序实例）之间通过轮训方式分发任务，但是要记住，在AMQP 0-9-1中，消息时在C之间进行负载均衡而不是队列之间进行的。直接交换可以看看下图：</p>\n\n<h3>3.3 fanout Exchange</h3>\n\n<p>fanout模式将消息发送给所有与之绑定的队列，不处理路由键。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout交换机转发消息是最快的。如下图：</p>\n\n<h3>3.4 Topic exchange</h3>\n\n<p>根据消息的routing_key以及队列和交换机绑定的类型，Topic Exchange把消息传递给一个或者多个队列。这就是一个多播的概念。当场景中需要多个C，并且C是有根据的获得消息的时候，Topic Exchange就应该被考虑。具体来说，就是将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“<em>”匹配不多不少一个词。因此“audit.#”能够匹配到“audit.irs.corporate”，但是“audit.</em>” 只会匹配到“audit.irs”。</p>\n\n<h3>3.5 Headers Exchange</h3>\n\n<p>如果不适应routing_key，而是根据消息的多个属性（表现为消息头的形式）的交换就是Headers Exchange，Headers Exchange会忽略routing_key值，相反，用来路由的信息实行消息的头属性中获得的。</p>\n\n<h2>5 队列Queue</h2>\n\n<p>在AMQP中队列就是一个消息的管道，存储C需要的消息，队列知道exchange的一些属性，同时增加了一些自己的属性：</p>\n\n<ul>\n<li>名字</li>\n<li>持续性（Durability），队列在broker重启后恢复</li>\n<li>Exclusive，单个连接中使用，连接断掉后队列被删除</li>\n<li>auto-delete：当C不在获得消息的时候队列被删除</li>\n<li>Arguments：一些broker自己实现的附加功能</li>\n</ul>\n\n<p>在队列使用之前必须被申明（declare），当队列不存在的时候申明队列会创建一个队列，如果队列已经存在，申明队列就不会进行其他操作，但是可以完成对队列存在与否的确认。</p>\n\n<h3>5.1 Queue Names</h3>\n\n<p>应用需要提供队列名，这样broker才能产生一个相应的队列。UTF-8格式，最多255字节，提供一个空字符作为队列名的话，broker会产生一个唯一的队列，同样的方式在C端也可以保证C取得的是P端产生的对应序列，因为P,C都是在一个channel下，而channel是能够记住上一次服务器产生的队列名的。</p>\n\n<p>队列名以\"amq.\"开头的是用于broker内部使用的队列。</p>\n\n<h3>5.2 Queue Durability</h3>\n\n<p>持续当broker重启的时候队列能够恢复，不具有持续性的队列就叫做transient。但是，<code>这里队列的持续性只是当broker重启的时候会自动重新申明队列，而要保证消息不丢失，还需要设置消息为永久性的（消息就存于磁盘而不是内存中）。</code></p>\n\n<h3>5.3 Bindings</h3>\n\n<p>bindings就是一些规则，用来决定消息要路由到哪个队列中去，比如，需要一个交换机E路由一个消息到队列Q，则Q需要先和E进行绑定。Bindings可能需要一些可选的routing_key，routing_key的作用就是选择被publish的特定信息到相应绑定的队列，换句话说，routing_key有点像是一个过滤器。举个例子:</p>\n\n<ul>\n<li>你住在纽约，队列就相当于你的目的地</li>\n<li>交换机就相当于XXX航空</li>\n<li>bindinds就XXX航空到你的住址的线路，可能没得，也可能有多条</li>\n</ul>\n\n<p>如果消息无法送到相应的队列，那么就会丢弃或者返回给P,这些就看相应的机制是怎么样的了。</p>\n\n<h3>5.6 Consumers</h3>\n\n<p>在队列中存储的消息一定要被C所使用。在AMQP 0-9-1模型中，应用程序有两种处理消息的模式：</p>\n\n<ul>\n<li>队列主动把消息传递给C应用(push API)</li>\n<li>C从队列中抓取自己需要的消息(pull API)</li>\n</ul>\n\n<p>在push模式下，应用C需要指明对哪个序列的哪类消息感兴趣，我们称此时队列注册了一个C，或者C订阅了一个队列。一个队列可以有多个C。</p>\n\n<p>每个C都有一个标示符叫做consumer tag，可以用来取消(unsubscribe)对队列消息的订阅，这个tag是一个字符串。</p>\n\n<h2>6 Message消息</h2>\n\n<h3>6.1 Message Acknowledgements 消息确认机制</h3>\n\n<p>Consumer applications-取得消息并且处理消息的应用，有时候可能会因为各种问题挂掉，于是乎就有，AMQP broker如何知道这个消息已经被C接收，是可以删除掉了？AMQP标准中给出了两个选择：</p>\n\n<ul>\n<li>在broker向C应用发送了一个消息后，消息可以被删除(使用basic.deliver or basic.get-ok AMQP方法)</li>\n<li>在C应用返回了一个确认ACK消息以后，消息可以被删除(使用basic.ack AMQP方法)</li>\n</ul>\n\n<p>前一种被叫做自动确认模型(automatic acknowledgement model)，后一种被叫做严格确认模型?(explicit acknowledgement model),在严格模式下C可以选择何时返回这个ACK信息。可以在接收消息的时候就返回，或者处理完消息携带的任务信息以后再返回。</p>\n\n<p>如果C挂掉，并且没有返回ACK信息，那么AMQP broker就会把消息传递给其他的C，如果当前没有可用的C存在，broker就等待，知道有新的C加入进来。</p>\n\n<h3>6.2 Rejecting Messages拒绝消息</h3>\n\n<p>当C取得了消息，但是处理过程中可能不成功，此时C就需要通过拒绝消息机制告诉broker这个消息处理失败，当拒绝消息的时候，C可以要求broker忽略或者从新把消息入队。</p>\n\n<h3>6.3 Negative acknowledgements</h3>\n\n<p>通过<code>basic.reject AMQP</code>方法消息就会被拒绝，但是这个方法有个限制：没办法拒绝一连串的多个消息，但是在RabbitMQ中，有一个解决方案，RabbitMQ提出了一种negative acknowledgements(nacks)机制，更多请参考RabbitMQ手册。</p>\n\n<h3>6.4 Prefetching Messages</h3>\n\n<p>在多个C存在的时候，最好有一种机制指定每个C在返回ACK之前最多能接收多少个消息，这个就有点像负载均衡的思想了。</p>\n\n<h3>6.5 Message Attributes and Payload</h3>\n\n<p>在AMQP中的消息时可以附带属性值(attributes)的，一些常见的属性有：</p>\n\n<ul>\n<li>Content type</li>\n<li>Content encoding</li>\n<li>Routing key</li>\n<li>Delivery mode (persistent or not)</li>\n<li>Message priority</li>\n<li>Message publishing timestamp</li>\n<li>Expiration period</li>\n<li>Producer application id</li>\n</ul>\n\n<p>一些属性可以被选作是消息的头信息。类似HTTP中的X-headers。AMQP消息也有一个负载段（playload），承载相应的数据。broker不会检测和修改负载，当消息被设置成persistent的时候，AMQP broker就会把消息存在磁盘中而不会丢失了。</p>\n\n<h3>6.6 Message acknowledgements</h3>\n\n<h2>7 AMQP 0-9-1 Methods</h2>\n\n<p>AMQP 0-9-1 被组织成各种各样的方法Methods,方法就是某些操作，类似HTTP Method但是和面向对象语言中的方法没有一点关系。AMQP方法被组织成各种类classes,类Class就是方法的集合。比如我们看看exchange class，就有一下操作：</p>\n\n<p>exchange.declare\nexchange.declare-ok\nexchange.delete\nexchange.delete-ok</p>\n\n<p>举例如下：\n一个客户端请求broker申明一个新的交换机，使用exchange.declare方法，当然，申明中需要一些参数：\n如果成功，broker就会使用exchange.declare-ok方法返回一个成功的标示。</p>\n\n<p>同样道理，对于队列类，也有这么一些方法：</p>\n\n<h3>7.1 Connections</h3>\n\n<p>AMQP的连接是长期的，AMQP是一个应用层，使用TCP来完成可靠的消息传递。AMQP的连接使用了认证并且可以使用TLS等加密协议。当一个应用不再需要与AMQP broker连接的时候，他需要友好的断开连接。</p>\n\n<h3>7.2 Channels</h3>\n\n<p>一些应用程序需要与AMQP broker建立多个连接，但是，同时保持多个TCP连接会消耗大量资源。AMQP 0-9-1提出了Channels的概念，Channels可以被认为是<code>在一个TCP连接中多个轻量级的连接</code>。</p>\n\n<p>对于多线程/进程应用，很常见的做法就是一个线程/进程打开一个channel，并且channel之间不共享。</p>\n\n<p>一个channel上的通信与另外一个channel间的通信时完全独立的，所以每个AMQP方法都会携带一个channel号，通过channel号，应用就知道这个方法是出于哪个channel上的。</p>\n\n<h2>7.3 Virtual Hosts</h2>\n\n<p>一个AMQP broler可以产生多个独立的\"环境\"，这就是vhost的概念。就类似于apache等的vhost一样，AMQP客户可以通过协商选择与哪个vhost进行连接。</p>\n\n<h2>参考资料:</h2>\n\n<p><a href=\"http://www.rabbitmq.com/tutorials/amqp-concepts.html\">http://www.rabbitmq.com/tutorials/amqp-concepts.html</a>\n<a href=\"http://langyu.iteye.com/blog/759663/\">http://langyu.iteye.com/blog/759663/</a>\n<a href=\"http://pythoner.net/wiki/110/\">http://pythoner.net/wiki/110/</a>\n<a href=\"http://blog.csdn.net/zhangxinrun/article/details/6546479\">http://blog.csdn.net/zhangxinrun/article/details/6546479</a>\n<a href=\"http://sunjun041640.blog.163.com/blog/static/25626832201032990829/\">http://sunjun041640.blog.163.com/blog/static/25626832201032990829/</a>\n<a href=\"http://www.oschina.net/question/12_9192\">http://www.oschina.net/question/12_9192</a>\n<book:RabbitMQ in Action></p>\n','AMQP&RabbitMQ协议及模型入门介绍','','inherit','open','open','','54-revision-2','','','2013-02-28 19:58:38','2013-02-28 11:58:38','','54','http://blog.wachang.net/2013/02/54-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('68','1','2013-02-27 21:36:56','2013-02-27 13:36:56','<blockquote>\n  <p>本文主要是翻译加总结，通过资料的查询，对AMQP有一定了解</p>\n  \n  <p>RabbitMQ使用的就是AMQP 0-9-1模型，所以本文其实也是在讲RabbitMQ中的一些原理</p>\n  \n  <p>文末会列出原文地址</p>\n</blockquote>\n\n<h2>What is AMQP?</h2>\n\n<p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，一个网络应用层协议的开放标准，为面向消息的中间件设计。</p>\n\n<p>说白了，这就是一个消费者生产者模型，模型就是生产者生产出一个消息，发送到一个队列Queue，消费者(也叫做worker)从队列里面取出这个消息。但是AMQP中，这个消息一般来说是一个任务，生产者消费者一般不在同一台机器上，所以，更好的解释就是，一个程序发送一个任务消息给一个队列，然后消费者程序从队列中拿出这个任务信息，进行执行，可能还需要返回结果。</p>\n\n<p>而RabbitMQ，就是实现了这么一个模型的软件，独立的开源实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、 Ruby、.NET、Java、JMS、C、PHP、 ActionScript、XMPP、STOMP等，支持AJAX。RabbitMQ就是一个服务器，实现了队列的管理，一个程序连接这个服务器，把任务发送给服务器（也即是进入了队列），消费者连接服务器，从队列中取出任务消息，然后执行。</p>\n\n<p>中英文对照： Messaging broker:消息协商器,它在TCP/IP等端口监听AMQ消息。 producers：应用程序，产生消息，并publish到消息队列中 consumers：应用程序，接收消息，然后进行处理。</p>\n\n<h2>AMQP 0-9-1 Model流程</h2>\n\n<p>AMQP 0-9-1 Model可以简单的总结如下:P产生消息，然后publish(发布)到exchange(交换机，类比成邮政的邮筒吧)，exchange根据一个规则(bindinds)把消息发送到队列(queue)中，消息协商器要么把消息传递给等待(订阅subdcribe)在某一队列上的的消费者(consumers)，要么消费者就从队列中根据自己的需要取消息。如下图： <img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-1.png\" alt=\"AMQP 0-9-1 Model in Brief\" /> 当publish消息的时候，P可能还会指定消息的属性（meta-data），可能一些meta会被broker使用，而其余的都是由C来使用的。</p>\n\n<p>因为网络不可靠，应用可能处理消息的时候就挂掉了，所以就有一个<code>消息确认机制message acknowledgements</code>:当消息传递给C的时候X需要通知broker。当使用消息确认机制的时候，一个broker只有在收到C对于此消息已经被接收的通知后才会删除消息。</p>\n\n<p>某些场景，消息发不到合适的C的时候，消息可能会被返回给P，丢弃，或者说放进一个“死亡队列”，由P来决定如何操作。</p>\n\n<p>队列，交换机，绑定作为AMQP中协作的三个元素。（Queues, exchanges and bindings are collectively referred to as AMQP entities.）</p>\n\n<h2>AMQP is a Programmable Protocol</h2>\n\n<h2>Exchanges and Exchange Types</h2>\n\n<p>交换机从P中接收到一个消息，然后路由?(route)发送到一个或者多个队列。交换机的类型和路由的规则和起来就叫做bindins，AMQP 0-9-1 brokers提供了四种交换类型。</p>\n\n<pre><code>交换类型                默认名字\nDirect exchange      空字符串或者amq.direct\nFanout exchange      amq.Fanout\nTopic exchange       amq.Topic\nHeaders exchange     amq.match (and amq.headers in RabbitMQ)\n</code></pre>\n','RabbitMQ/AMQP 0-9-1 模型入门介绍','','inherit','open','open','','42-revision-3','','','2013-02-27 21:36:56','2013-02-27 13:36:56','','42','http://blog.wachang.net/2013/02/42-revision-3/','0','revision','','0');");
E_D("replace into `wp_posts` values('70','1','2013-02-28 20:08:57','2013-02-28 12:08:57','<blockquote>\n  <p>1本文主要是翻译加总结，通过资料的查询，对AMQP有一定了解; 2 RabbitMQ使用的就是AMQP 0-9-1模型，所以本文其实也是在讲RabbitMQ中的一些原理; 3 文末会列出原文地址</p>\n</blockquote>\n\n<h2>1 What is AMQP?</h2>\n\n<p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，一个网络应用层协议的开放标准，为面向消息的中间件设计。</p>\n\n<p>说白了，这就是一个消费者生产者模型，生产者生产出一个消息，发送到一个队列Queue，消费者(也叫做worker)从队列里面取出这个消息。但是AMQP中，这个消息一般来说是一个任务，生产者消费者一般不在同一台机器上，所以，更好的解释就是，一个程序发送一个任务消息给一个队列，然后消费者程序从队列中拿出这个任务信息，进行执行，可能还需要返回结果。</p>\n\n<p>而RabbitMQ，就是实现了这么一个模型的软件，独立的开源实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、 Ruby、.NET、Java、JMS、C、PHP、 ActionScript、XMPP、STOMP等，支持AJAX。RabbitMQ就是一个服务器，实现了队列的管理，一个程序连接这个服务器，把任务发送给服务器（也即是进入了队列），消费者连接服务器，从队列中取出任务消息，然后执行。</p>\n\n<p>中英文对照： Messaging broker:消息协商器,它在TCP/IP等端口监听AMQ消息，其实就是AMQP的实现，比如RabbitMQ等。 producers：应用程序，产生消息，并publish到消息队列中，下文简称P。 consumers：应用程序，接收消息，然后进行处理，下文简称C。 AMQP client：AMQP客户端，指与AMQP broker连接的P或者C。</p>\n\n<h2>2 AMQP协议</h2>\n\n<h3>2.1 协议概述</h3>\n\n<p>从整体来看，AMQP协议可划分为三层： [<img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-256x300.png\" alt=\"amqp-protocol\" width=\"256\" height=\"300\" class=\"alignnone size-medium wp-image-55\" />][1] AMQP定义了合适的服务器端域模型，用于规范服务器的行为(AMQP服务器端可称为broker)。在这里Model层决定这些基本域模型所产生的行为，这种行为在AMQP中用”command”表示，在后文中会着重来分析这些域模型。Session层定义客户端与broker之间的通信(通信双方都是一个peer，可互称做partner)，为command的可靠传输提供保障。Transport层专注于数据传送，并与Session保持交互，接受上层的数据，组装成二进制流，传送到receiver后再解析数据，交付给Session层。Session层需要Transport层完成网络异常情况的汇报，顺序传送command等工作。</p>\n\n<h3>2.2 协议模型</h3>\n\n<p>AMQP broker主要功能是消息的路由(Routing)和缓存(Buffering)，如下图： \n<a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-2.png\" alt=\"amqp-protocol-2\" width=\"571\" height=\"239\" class=\"alignnone size-full wp-image-59\" /></a>\nExchange接收消息生产者(Producer)发送的消息根据不同的路由算法将消息发送往Message queue。Message queue会在消息不能被正常消费时缓存这些消息，具体的缓存策略由实现者决定，当message queue与消息消费者(Message consumer)之间的连接通畅时，Message queue有将消息转发到consumer的责任。</p>\n\n<p>Message是当前模型中所操纵的基本单位,基本结构有两部分: Header和Body(playload),Header是由Producer添加上的各种属性的集合，这些属性有控制Message是否可被缓存，接收的queue是哪个，优先级是多少等。Body是真正需要传送的数据，它是对Broker不可见的二进制数据流，在传输过程中不应该受到影响。</p>\n\n<p>一个broker中会存在多个Message queue，Exchange通过binding知道要把消息发送到哪个Message queue,在创建Message queue后需要确定它来接收并保存哪个Exchange路由的结果。Binding是用来关联Exchange与Message queue的域模型,通过关键字bindinds_key。</p>\n\n<p>在与多个Message queue关联后，Exchange中就会存在一个路由表，这个表中存储着每个Message queue所需要消息的限制条件。Exchange就会检查它接受到的每个Message的Header及Body信息，来决定将Message路由到哪个queue中去。Message的Header中应该有个属性叫Routing Key，它由Message发送者产生，提供给Exchange路由这条Message的标准。Exchange根据不同路由算法有不同有Exchange Type。比如有Direct类似，需要Binding key 等于Routing key；也有Binding key与Routing key符合一个模式关系；也有根据Message包含的某些属性来判断。一些基础的路由算法由AMQP所提供，client application也可以自定义各种自己的扩展路由算法。\n<a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-3.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-3.png\" alt=\"amqp-protocol-3\" width=\"714\" height=\"117\" class=\"alignnone size-full wp-image-58\" /></a>\n对于，上图，有一些具体的概念，下面会详细讨论。</p>\n\n<h3>2.3 AMQP 0-9-1 Model流程</h3>\n\n<p>AMQP 0-9-1 Model可以简单的总结如下:P产生消息，然后publish(发布)到exchange(交换机，类比成邮政的邮筒吧)，exchange根据一个规则(bindinds)把消息发送到队列(queue)中，消息协商器要么把消息传递给等待(订阅subdcribe)在某一队列上的的消费者(consumers)，要么消费者就从队列中根据自己的需要取消息。如下图：\n<a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-11.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-11.png\" alt=\"amqp-intro-1\" width=\"712\" height=\"319\" class=\"alignnone size-full wp-image-60\" /></a></p>\n\n<p>当publish消息的时候，P可能还会指定消息的属性（meta-data），可能一些meta会被broker使用，而其余的都是由C来使用的。</p>\n\n<p>因为网络不可靠，应用可能处理消息的时候就挂掉了，所以就有一个<code>消息确认机制message acknowledgements</code>:当消息传递给C的时候需要通知broker。当使用消息确认机制的时候，一个broker只有在收到C对于此消息已经被接收的通知后才会删除消息。</p>\n\n<p>某些场景，消息发不到合适的C的时候，消息可能会被返回给P，丢弃，或者说放进一个“死亡队列”，由P来决定如何操作。</p>\n\n<p>队列，交换机，绑定作为AMQP中协作的三个元素。（Queues, exchanges and bindings are collectively referred to as AMQP entities.）</p>\n\n<h2>3 Exchanges and Exchange Types交换机和交换类型</h2>\n\n<p>交换机可以理解成具有路由表的路由程序，仅此而已。每个消息都有一个称为路由键（routing key）的属性，就是一个简单的字符串。交换机当中有一系列的绑定（binding），即路由规则（routes），例如，指明具有路由键 “X” 的消息要到名为timbuku的队列当中去。</p>\n\n<p>交换机从P中接收到一个消息，然后路由(route)发送到一个或者多个队列，AMQP 0-9-1 brokers提供了四种交换类型。</p>\n\n<pre><code>交换类型                默认名字\nDirect exchange      空字符串或者amq.direct\nFanout exchange      amq.Fanout\nTopic exchange       amq.Topic\nHeaders exchange     amq.match (and amq.headers in RabbitMQ)\n</code></pre>\n\n<p>除了交换类型以后，定义交换机的时候还有其他的属性，最重要的几个是：</p>\n\n<ul>\n<li>Name</li>\n<li>Durability（当broker重启后交换机是否能继续工作）</li>\n<li>Auto-delete（所有队列都适用完以后，交换机就被删除）</li>\n<li>Arguments（根据broker的选择而定）</li>\n</ul>\n\n<p>exchanges交换机有两种模式(交换模式与交换类型概念不一样)，Durability表示在broker重启的时候能够恢复之前的工作，而transient模式下则会丢失之前的数据。</p>\n\n<h3>3.1 默认交换exchange</h3>\n\n<p>默认的交换机是一个已经预定义了的没有名字的Direct交换模式，他有一个简单的特性：每创建一个队列，都会通过一个routing&#95;key与exchange绑定，而这个routing&#95;key是和队列名字一样的。</p>\n\n<h3>3.2 直接交换Direct exchange</h3>\n\n<p>处理路由键。需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。这是一个完整的匹配。如果一个队列绑定到该交换机上要求路由键 “dog”，则只有被标记为“dog”的消息才被转发，不会转发dog.puppy，也不会转发dog.guard，只会转发dog。</p>\n\n<ul>\n<li>一个队列通过routing_key K与一个exchange绑定。</li>\n<li>当一个携带routing_key K的消息到达exchange的时候，exchange将消息路由给队列。</li>\n</ul>\n\n<p>直接交换主要用来在多个C，或者说worker（相同的程序实例）之间通过轮训方式分发任务，但是要记住，在AMQP 0-9-1中，消息时在C之间进行负载均衡而不是队列之间进行的。直接交换可以看看下图：\n<a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-2.png\" alt=\"amqp-intro-2\" width=\"689\" height=\"511\" class=\"alignnone size-full wp-image-62\" /></a></p>\n\n<h3>3.3 fanout Exchange</h3>\n\n<p>fanout模式将消息发送给所有与之绑定的队列，不处理路由键。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout交换机转发消息是最快的。如下图：\n<a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-3-fanout.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-3-fanout.png\" alt=\"amqp-intro-3-fanout\" width=\"713\" height=\"447\" class=\"alignnone size-full wp-image-61\" /></a></p>\n\n<h3>3.4 Topic exchange</h3>\n\n<p>根据消息的routing_key以及队列和交换机绑定的类型，Topic Exchange把消息传递给一个或者多个队列。这就是一个多播的概念。当场景中需要多个C，并且C是有根据的获得消息的时候，Topic Exchange就应该被考虑。具体来说，就是将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“<em>”匹配不多不少一个词。因此“audit.#”能够匹配到“audit.irs.corporate”，但是“audit.</em>” 只会匹配到“audit.irs”。</p>\n\n<h3>3.5 Headers Exchange</h3>\n\n<p>如果不适应routing&#95;key，而是根据消息的多个属性（表现为消息头的形式）的交换就是Headers Exchange，Headers Exchange会忽略routing&#95;key值，相反，用来路由的信息实行消息的头属性中获得的。</p>\n\n<h2>5 队列Queue</h2>\n\n<p>在AMQP中队列就是一个消息的管道，存储C需要的消息，队列知道exchange的一些属性，同时增加了一些自己的属性：</p>\n\n<ul>\n<li>名字</li>\n<li>持续性（Durability），队列在broker重启后恢复</li>\n<li>Exclusive，单个连接中使用，连接断掉后队列被删除</li>\n<li>auto-delete：当C不在获得消息的时候队列被删除</li>\n<li>Arguments：一些broker自己实现的附加功能</li>\n</ul>\n\n<p>在队列使用之前必须被申明（declare），当队列不存在的时候申明队列会创建一个队列，如果队列已经存在，申明队列就不会进行其他操作，但是可以完成对队列存在与否的确认。</p>\n\n<h3>5.1 Queue Names</h3>\n\n<p>应用需要提供队列名，这样broker才能产生一个相应的队列。UTF-8格式，最多255字节，提供一个空字符作为队列名的话，broker会产生一个唯一的队列，同样的方式在C端也可以保证C取得的是P端产生的对应序列，因为P,C都是在一个channel下，而channel是能够记住上一次服务器产生的队列名的。</p>\n\n<p>队列名以\"amq.\"开头的是用于broker内部使用的队列。</p>\n\n<h3>5.2 Queue Durability</h3>\n\n<p>持续当broker重启的时候队列能够恢复，不具有持续性的队列就叫做transient。但是，<code>这里队列的持续性只是当broker重启的时候会自动重新申明队列，而要保证消息不丢失，还需要设置消息为永久性的（消息就存于磁盘而不是内存中）。</code></p>\n\n<h3>5.3 Bindings</h3>\n\n<p>bindings就是一些规则，用来决定消息要路由到哪个队列中去，比如，需要一个交换机E路由一个消息到队列Q，则Q需要先和E进行绑定。Bindings可能需要一些可选的routing&#95;key，routing&#95;key的作用就是选择被publish的特定信息到相应绑定的队列，换句话说，routing_key有点像是一个过滤器。举个例子:</p>\n\n<ul>\n<li>你住在纽约，队列就相当于你的目的地</li>\n<li>交换机就相当于XXX航空</li>\n<li>bindinds就XXX航空到你的住址的线路，可能没得，也可能有多条</li>\n</ul>\n\n<p>如果消息无法送到相应的队列，那么就会丢弃或者返回给P,这些就看相应的机制是怎么样的了。</p>\n\n<h3>5.6 Consumers</h3>\n\n<p>在队列中存储的消息一定要被C所使用。在AMQP 0-9-1模型中，应用程序有两种处理消息的模式：</p>\n\n<ul>\n<li>队列主动把消息传递给C应用(push API)</li>\n<li>C从队列中抓取自己需要的消息(pull API)</li>\n</ul>\n\n<p>在push模式下，应用C需要指明对哪个序列的哪类消息感兴趣，我们称此时队列注册了一个C，或者C订阅了一个队列。一个队列可以有多个C。</p>\n\n<p>每个C都有一个标示符叫做consumer tag，可以用来取消(unsubscribe)对队列消息的订阅，这个tag是一个字符串。</p>\n\n<h2>6 Message消息</h2>\n\n<h3>6.1 Message Acknowledgements 消息确认机制</h3>\n\n<p>Consumer applications-取得消息并且处理消息的应用，有时候可能会因为各种问题挂掉，于是乎就有，AMQP broker如何知道这个消息已经被C接收，是可以删除掉了？AMQP标准中给出了两个选择：</p>\n\n<ul>\n<li>在broker向C应用发送了一个消息后，消息可以被删除(使用basic.deliver or basic.get-ok AMQP方法)</li>\n<li>在C应用返回了一个确认ACK消息以后，消息可以被删除(使用basic.ack AMQP方法)</li>\n</ul>\n\n<p>前一种被叫做自动确认模型(automatic acknowledgement model)，后一种被叫做严格确认模型?(explicit acknowledgement model),在严格模式下C可以选择何时返回这个ACK信息。可以在接收消息的时候就返回，或者处理完消息携带的任务信息以后再返回。</p>\n\n<p>如果C挂掉，并且没有返回ACK信息，那么AMQP broker就会把消息传递给其他的C，如果当前没有可用的C存在，broker就等待，知道有新的C加入进来。</p>\n\n<h3>6.2 Rejecting Messages拒绝消息</h3>\n\n<p>当C取得了消息，但是处理过程中可能不成功，此时C就需要通过拒绝消息机制告诉broker这个消息处理失败，当拒绝消息的时候，C可以要求broker忽略或者从新把消息入队。</p>\n\n<h3>6.3 Negative acknowledgements</h3>\n\n<p>通过<code>basic.reject AMQP</code>方法消息就会被拒绝，但是这个方法有个限制：没办法拒绝一连串的多个消息，但是在RabbitMQ中，有一个解决方案，RabbitMQ提出了一种negative acknowledgements(nacks)机制，更多请参考RabbitMQ手册。</p>\n\n<h3>6.4 Prefetching Messages</h3>\n\n<p>在多个C存在的时候，最好有一种机制指定每个C在返回ACK之前最多能接收多少个消息，这个就有点像负载均衡的思想了。</p>\n\n<h3>6.5 Message Attributes and Payload</h3>\n\n<p>在AMQP中的消息时可以附带属性值(attributes)的，一些常见的属性有：</p>\n\n<ul>\n<li>Content type</li>\n<li>Content encoding</li>\n<li>Routing key</li>\n<li>Delivery mode (persistent or not)</li>\n<li>Message priority</li>\n<li>Message publishing timestamp</li>\n<li>Expiration period</li>\n<li>Producer application id</li>\n</ul>\n\n<p>一些属性可以被选作是消息的头信息。类似HTTP中的X-headers。AMQP消息也有一个负载段（playload），承载相应的数据。broker不会检测和修改负载，当消息被设置成persistent的时候，AMQP broker就会把消息存在磁盘中而不会丢失了。</p>\n\n<h3>6.6 Message acknowledgements</h3>\n\n<h2>7 AMQP 0-9-1 Methods</h2>\n\n<p>AMQP 0-9-1 被组织成各种各样的方法Methods,方法就是某些操作，类似HTTP Method但是和面向对象语言中的方法没有一点关系。AMQP方法被组织成各种类classes,类Class就是方法的集合。比如我们看看exchange class，就有一下操作：</p>\n\n<p>exchange.declare exchange.declare-ok exchange.delete exchange.delete-ok</p>\n\n<p>举例如下： 一个客户端请求broker申明一个新的交换机，使用exchange.declare方法，当然，申明中需要一些参数： 如果成功，broker就会使用exchange.declare-ok方法返回一个成功的标示。\n<a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e1.png\" alt=\"amqp-intro-4-e1\" width=\"566\" height=\"160\" class=\"alignnone size-full wp-image-63\" /></a>\n<a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e2.png\" alt=\"amqp-intro-4-e2\" width=\"574\" height=\"161\" class=\"alignnone size-full wp-image-64\" /></a></p>\n\n<p>同样道理，对于队列类，也有这么一些方法：\n<a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e3.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e3.png\" alt=\"amqp-intro-4-e3\" width=\"571\" height=\"156\" class=\"alignnone size-full wp-image-65\" /></a>\n<a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e4.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e4.png\" alt=\"amqp-intro-4-e4\" width=\"582\" height=\"161\" class=\"alignnone size-full wp-image-66\" /></a></p>\n\n<h3>7.1 Connections</h3>\n\n<p>AMQP的连接是长期的，AMQP是一个应用层，使用TCP来完成可靠的消息传递。AMQP的连接使用了认证并且可以使用TLS等加密协议。当一个应用不再需要与AMQP broker连接的时候，他需要友好的断开连接。</p>\n\n<h3>7.2 Channels</h3>\n\n<p>一些应用程序需要与AMQP broker建立多个连接，但是，同时保持多个TCP连接会消耗大量资源。AMQP 0-9-1提出了Channels的概念，Channels可以被认为是<code>在一个TCP连接中多个轻量级的连接</code>。</p>\n\n<p>对于多线程/进程应用，很常见的做法就是一个线程/进程打开一个channel，并且channel之间不共享。</p>\n\n<p>一个channel上的通信与另外一个channel间的通信时完全独立的，所以每个AMQP方法都会携带一个channel号，通过channel号，应用就知道这个方法是出于哪个channel上的。</p>\n\n<h2>7.3 Virtual Hosts</h2>\n\n<p>一个AMQP broler可以产生多个独立的\"环境\"，这就是vhost的概念。就类似于apache等的vhost一样，AMQP客户可以通过协商选择与哪个vhost进行连接。</p>\n\n<h2>参考资料:</h2>\n\n<p><a href=\"http://www.rabbitmq.com/tutorials/amqp-concepts.html\">http://www.rabbitmq.com/tutorials/amqp-concepts.html</a> <a href=\"http://langyu.iteye.com/blog/759663/\">http://langyu.iteye.com/blog/759663/</a> <a href=\"http://pythoner.net/wiki/110/\">http://pythoner.net/wiki/110/</a> <a href=\"http://blog.csdn.net/zhangxinrun/article/details/6546479\">http://blog.csdn.net/zhangxinrun/article/details/6546479</a> <a href=\"http://sunjun041640.blog.163.com/blog/static/25626832201032990829/\">http://sunjun041640.blog.163.com/blog/static/25626832201032990829/</a> <a href=\"http://www.oschina.net/question/12_9192\">http://www.oschina.net/question/12_9192</a> \nbook:RabbitMQ in Action</p>\n','AMQP&RabbitMQ协议及模型入门介绍','','inherit','open','open','','54-revision-3','','','2013-02-28 20:08:57','2013-02-28 12:08:57','','54','http://blog.wachang.net/2013/02/54-revision-3/','0','revision','','0');");
E_D("replace into `wp_posts` values('71','1','2013-02-28 20:16:07','2013-02-28 12:16:07','<blockquote>\n  <p>1本文主要是翻译加总结，通过资料的查询，对AMQP有一定了解; 2 RabbitMQ使用的就是AMQP 0-9-1模型，所以本文其实也是在讲RabbitMQ中的一些原理; 3 文末会列出原文地址</p>\n</blockquote>\n\n<h2>1 What is AMQP?</h2>\n\n<p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，一个网络应用层协议的开放标准，为面向消息的中间件设计。</p>\n\n<p>说白了，这就是一个消费者生产者模型，生产者生产出一个消息，发送到一个队列Queue，消费者(也叫做worker)从队列里面取出这个消息。但是AMQP中，这个消息一般来说是一个任务，生产者消费者一般不在同一台机器上，所以，更好的解释就是，一个程序发送一个任务消息给一个队列，然后消费者程序从队列中拿出这个任务信息，进行执行，可能还需要返回结果。</p>\n\n<p>而RabbitMQ，就是实现了这么一个模型的软件，独立的开源实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、 Ruby、.NET、Java、JMS、C、PHP、 ActionScript、XMPP、STOMP等，支持AJAX。RabbitMQ就是一个服务器，实现了队列的管理，一个程序连接这个服务器，把任务发送给服务器（也即是进入了队列），消费者连接服务器，从队列中取出任务消息，然后执行。</p>\n\n<p>中英文对照： Messaging broker:消息协商器,它在TCP/IP等端口监听AMQ消息，其实就是AMQP的实现，比如RabbitMQ等。 producers：应用程序，产生消息，并publish到消息队列中，下文简称P。 consumers：应用程序，接收消息，然后进行处理，下文简称C。 AMQP client：AMQP客户端，指与AMQP broker连接的P或者C。</p>\n\n<h2>2 AMQP协议</h2>\n\n<h3>2.1 协议概述</h3>\n\n<p>从整体来看，AMQP协议可划分为三层： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-256x300.png\" alt=\"amqp-protocol\" width=\"256\" height=\"300\" class=\"alignnone size-medium wp-image-55\" /></a> AMQP定义了合适的服务器端域模型，用于规范服务器的行为(AMQP服务器端可称为broker)。在这里Model层决定这些基本域模型所产生的行为，这种行为在AMQP中用”command”表示，在后文中会着重来分析这些域模型。Session层定义客户端与broker之间的通信(通信双方都是一个peer，可互称做partner)，为command的可靠传输提供保障。Transport层专注于数据传送，并与Session保持交互，接受上层的数据，组装成二进制流，传送到receiver后再解析数据，交付给Session层。Session层需要Transport层完成网络异常情况的汇报，顺序传送command等工作。</p>\n\n<h3>2.2 协议模型</h3>\n\n<p>AMQP broker主要功能是消息的路由(Routing)和缓存(Buffering)，如下图： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-2.png\" alt=\"amqp-protocol-2\" width=\"571\" height=\"239\" class=\"alignnone size-full wp-image-59\" /></a> Exchange接收消息生产者(Producer)发送的消息根据不同的路由算法将消息发送往Message queue。Message queue会在消息不能被正常消费时缓存这些消息，具体的缓存策略由实现者决定，当message queue与消息消费者(Message consumer)之间的连接通畅时，Message queue有将消息转发到consumer的责任。</p>\n\n<p>Message是当前模型中所操纵的基本单位,基本结构有两部分: Header和Body(playload),Header是由Producer添加上的各种属性的集合，这些属性有控制Message是否可被缓存，接收的queue是哪个，优先级是多少等。Body是真正需要传送的数据，它是对Broker不可见的二进制数据流，在传输过程中不应该受到影响。</p>\n\n<p>一个broker中会存在多个Message queue，Exchange通过binding知道要把消息发送到哪个Message queue,在创建Message queue后需要确定它来接收并保存哪个Exchange路由的结果。Binding是用来关联Exchange与Message queue的域模型,通过关键字bindinds_key。</p>\n\n<p>在与多个Message queue关联后，Exchange中就会存在一个路由表，这个表中存储着每个Message queue所需要消息的限制条件。Exchange就会检查它接受到的每个Message的Header及Body信息，来决定将Message路由到哪个queue中去。Message的Header中应该有个属性叫Routing Key，它由Message发送者产生，提供给Exchange路由这条Message的标准。Exchange根据不同路由算法有不同有Exchange Type。比如有Direct类似，需要Binding key 等于Routing key；也有Binding key与Routing key符合一个模式关系；也有根据Message包含的某些属性来判断。一些基础的路由算法由AMQP所提供，client application也可以自定义各种自己的扩展路由算法。 <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-3.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-3.png\" alt=\"amqp-protocol-3\" width=\"714\" height=\"117\" class=\"alignnone size-full wp-image-58\" /></a> 对于，上图，有一些具体的概念，下面会详细讨论。</p>\n\n<h3>2.3 AMQP 0-9-1 Model流程</h3>\n\n<p>AMQP 0-9-1 Model可以简单的总结如下:P产生消息，然后publish(发布)到exchange(交换机，类比成邮政的邮筒吧)，exchange根据一个规则(bindinds)把消息发送到队列(queue)中，消息协商器要么把消息传递给等待(订阅subdcribe)在某一队列上的的消费者(consumers)，要么消费者就从队列中根据自己的需要取消息。如下图： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-11.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-11.png\" alt=\"amqp-intro-1\" width=\"712\" height=\"319\" class=\"alignnone size-full wp-image-60\" /></a></p>\n\n<p>当publish消息的时候，P可能还会指定消息的属性（meta-data），可能一些meta会被broker使用，而其余的都是由C来使用的。</p>\n\n<p>因为网络不可靠，应用可能处理消息的时候就挂掉了，所以就有一个<code>消息确认机制message acknowledgements</code>:当消息传递给C的时候需要通知broker。当使用消息确认机制的时候，一个broker只有在收到C对于此消息已经被接收的通知后才会删除消息。</p>\n\n<p>某些场景，消息发不到合适的C的时候，消息可能会被返回给P，丢弃，或者说放进一个“死亡队列”，由P来决定如何操作。</p>\n\n<p>队列，交换机，绑定作为AMQP中协作的三个元素。（Queues, exchanges and bindings are collectively referred to as AMQP entities.）</p>\n\n<h2>3 Exchanges and Exchange Types交换机和交换类型</h2>\n\n<p>交换机可以理解成具有路由表的路由程序，仅此而已。每个消息都有一个称为路由键（routing key）的属性，就是一个简单的字符串。交换机当中有一系列的绑定（binding），即路由规则（routes），例如，指明具有路由键 “X” 的消息要到名为timbuku的队列当中去。</p>\n\n<p>交换机从P中接收到一个消息，然后路由(route)发送到一个或者多个队列，AMQP 0-9-1 brokers提供了四种交换类型。</p>\n\n<pre><code>交换类型                默认名字\nDirect exchange      空字符串或者amq.direct\nFanout exchange      amq.Fanout\nTopic exchange       amq.Topic\nHeaders exchange     amq.match (and amq.headers in RabbitMQ)\n</code></pre>\n\n<p>除了交换类型以后，定义交换机的时候还有其他的属性，最重要的几个是：</p>\n\n<ul>\n<li>Name</li>\n<li>Durability（当broker重启后交换机是否能继续工作）</li>\n<li>Auto-delete（所有队列都适用完以后，交换机就被删除）</li>\n<li>Arguments（根据broker的选择而定）</li>\n</ul>\n\n<p>exchanges交换机有两种模式(交换模式与交换类型概念不一样)，Durability表示在broker重启的时候能够恢复之前的工作，而transient模式下则会丢失之前的数据。</p>\n\n<h3>3.1 默认交换exchange</h3>\n\n<p>默认的交换机是一个已经预定义了的没有名字的Direct交换模式，他有一个简单的特性：每创建一个队列，都会通过一个routing&#95;key与exchange绑定，而这个routing&#95;key是和队列名字一样的。</p>\n\n<h3>3.2 直接交换Direct exchange</h3>\n\n<p>处理路由键。需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。这是一个完整的匹配。如果一个队列绑定到该交换机上要求路由键 “dog”，则只有被标记为“dog”的消息才被转发，不会转发dog.puppy，也不会转发dog.guard，只会转发dog。</p>\n\n<ul>\n<li>一个队列通过routing_key K与一个exchange绑定。</li>\n<li>当一个携带routing_key K的消息到达exchange的时候，exchange将消息路由给队列。</li>\n</ul>\n\n<p>直接交换主要用来在多个C，或者说worker（相同的程序实例）之间通过轮训方式分发任务，但是要记住，在AMQP 0-9-1中，消息时在C之间进行负载均衡而不是队列之间进行的。直接交换可以看看下图： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-2.png\" alt=\"amqp-intro-2\" width=\"689\" height=\"511\" class=\"alignnone size-full wp-image-62\" /></a></p>\n\n<h3>3.3 fanout Exchange</h3>\n\n<p>fanout模式将消息发送给所有与之绑定的队列，不处理路由键。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout交换机转发消息是最快的。如下图： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-3-fanout.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-3-fanout.png\" alt=\"amqp-intro-3-fanout\" width=\"713\" height=\"447\" class=\"alignnone size-full wp-image-61\" /></a></p>\n\n<h3>3.4 Topic exchange</h3>\n\n<p>根据消息的routing_key以及队列和交换机绑定的类型，Topic Exchange把消息传递给一个或者多个队列。这就是一个多播的概念。当场景中需要多个C，并且C是有根据的获得消息的时候，Topic Exchange就应该被考虑。具体来说，就是将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“<em>”匹配不多不少一个词。因此“audit.#”能够匹配到“audit.irs.corporate”，但是“audit.</em>” 只会匹配到“audit.irs”。</p>\n\n<h3>3.5 Headers Exchange</h3>\n\n<p>如果不适应routing&#95;key，而是根据消息的多个属性（表现为消息头的形式）的交换就是Headers Exchange，Headers Exchange会忽略routing&#95;key值，相反，用来路由的信息实行消息的头属性中获得的。</p>\n\n<h2>5 队列Queue</h2>\n\n<p>在AMQP中队列就是一个消息的管道，存储C需要的消息，队列知道exchange的一些属性，同时增加了一些自己的属性：</p>\n\n<ul>\n<li>名字</li>\n<li>持续性（Durability），队列在broker重启后恢复</li>\n<li>Exclusive，单个连接中使用，连接断掉后队列被删除</li>\n<li>auto-delete：当C不在获得消息的时候队列被删除</li>\n<li>Arguments：一些broker自己实现的附加功能</li>\n</ul>\n\n<p>在队列使用之前必须被申明（declare），当队列不存在的时候申明队列会创建一个队列，如果队列已经存在，申明队列就不会进行其他操作，但是可以完成对队列存在与否的确认。</p>\n\n<h3>5.1 Queue Names</h3>\n\n<p>应用需要提供队列名，这样broker才能产生一个相应的队列。UTF-8格式，最多255字节，提供一个空字符作为队列名的话，broker会产生一个唯一的队列，同样的方式在C端也可以保证C取得的是P端产生的对应序列，因为P,C都是在一个channel下，而channel是能够记住上一次服务器产生的队列名的。</p>\n\n<p>队列名以\"amq.\"开头的是用于broker内部使用的队列。</p>\n\n<h3>5.2 Queue Durability</h3>\n\n<p>持续当broker重启的时候队列能够恢复，不具有持续性的队列就叫做transient。但是，<code>这里队列的持续性只是当broker重启的时候会自动重新申明队列，而要保证消息不丢失，还需要设置消息为永久性的（消息就存于磁盘而不是内存中）。</code></p>\n\n<h3>5.3 Bindings</h3>\n\n<p>bindings就是一些规则，用来决定消息要路由到哪个队列中去，比如，需要一个交换机E路由一个消息到队列Q，则Q需要先和E进行绑定。Bindings可能需要一些可选的routing&#95;key，routing&#95;key的作用就是选择被publish的特定信息到相应绑定的队列，换句话说，routing_key有点像是一个过滤器。举个例子:</p>\n\n<ul>\n<li>你住在纽约，队列就相当于你的目的地</li>\n<li>交换机就相当于XXX航空</li>\n<li>bindinds就XXX航空到你的住址的线路，可能没得，也可能有多条</li>\n</ul>\n\n<p>如果消息无法送到相应的队列，那么就会丢弃或者返回给P,这些就看相应的机制是怎么样的了。</p>\n\n<h3>5.6 Consumers</h3>\n\n<p>在队列中存储的消息一定要被C所使用。在AMQP 0-9-1模型中，应用程序有两种处理消息的模式：</p>\n\n<ul>\n<li>队列主动把消息传递给C应用(push API)</li>\n<li>C从队列中抓取自己需要的消息(pull API)</li>\n</ul>\n\n<p>在push模式下，应用C需要指明对哪个序列的哪类消息感兴趣，我们称此时队列注册了一个C，或者C订阅了一个队列。一个队列可以有多个C。</p>\n\n<p>每个C都有一个标示符叫做consumer tag，可以用来取消(unsubscribe)对队列消息的订阅，这个tag是一个字符串。</p>\n\n<h2>6 Message消息</h2>\n\n<h3>6.1 Message Acknowledgements 消息确认机制</h3>\n\n<p>Consumer applications-取得消息并且处理消息的应用，有时候可能会因为各种问题挂掉，于是乎就有，AMQP broker如何知道这个消息已经被C接收，是可以删除掉了？AMQP标准中给出了两个选择：</p>\n\n<ul>\n<li>在broker向C应用发送了一个消息后，消息可以被删除(使用basic.deliver or basic.get-ok AMQP方法)</li>\n<li>在C应用返回了一个确认ACK消息以后，消息可以被删除(使用basic.ack AMQP方法)</li>\n</ul>\n\n<p>前一种被叫做自动确认模型(automatic acknowledgement model)，后一种被叫做严格确认模型?(explicit acknowledgement model),在严格模式下C可以选择何时返回这个ACK信息。可以在接收消息的时候就返回，或者处理完消息携带的任务信息以后再返回。</p>\n\n<p>如果C挂掉，并且没有返回ACK信息，那么AMQP broker就会把消息传递给其他的C，如果当前没有可用的C存在，broker就等待，知道有新的C加入进来。</p>\n\n<h3>6.2 Rejecting Messages拒绝消息</h3>\n\n<p>当C取得了消息，但是处理过程中可能不成功，此时C就需要通过拒绝消息机制告诉broker这个消息处理失败，当拒绝消息的时候，C可以要求broker忽略或者从新把消息入队。</p>\n\n<h3>6.3 Negative acknowledgements</h3>\n\n<p>通过<code>basic.reject AMQP</code>方法消息就会被拒绝，但是这个方法有个限制：没办法拒绝一连串的多个消息，但是在RabbitMQ中，有一个解决方案，RabbitMQ提出了一种negative acknowledgements(nacks)机制，更多请参考RabbitMQ手册。</p>\n\n<h3>6.4 Prefetching Messages</h3>\n\n<p>在多个C存在的时候，最好有一种机制指定每个C在返回ACK之前最多能接收多少个消息，这个就有点像负载均衡的思想了。</p>\n\n<h3>6.5 Message Attributes and Payload</h3>\n\n<p>在AMQP中的消息时可以附带属性值(attributes)的，一些常见的属性有：</p>\n\n<ul>\n<li>Content type</li>\n<li>Content encoding</li>\n<li>Routing key</li>\n<li>Delivery mode (persistent or not)</li>\n<li>Message priority</li>\n<li>Message publishing timestamp</li>\n<li>Expiration period</li>\n<li>Producer application id</li>\n</ul>\n\n<p>一些属性可以被选作是消息的头信息。类似HTTP中的X-headers。AMQP消息也有一个负载段（playload），承载相应的数据。broker不会检测和修改负载，当消息被设置成persistent的时候，AMQP broker就会把消息存在磁盘中而不会丢失了。</p>\n\n<h3>6.6 Message acknowledgements</h3>\n\n<h2>7 AMQP 0-9-1 Methods</h2>\n\n<p>AMQP 0-9-1 被组织成各种各样的方法Methods,方法就是某些操作，类似HTTP Method但是和面向对象语言中的方法没有一点关系。AMQP方法被组织成各种类classes,类Class就是方法的集合。比如我们看看exchange class，就有一下操作：</p>\n\n<p>exchange.declare exchange.declare-ok exchange.delete exchange.delete-ok</p>\n\n<p>举例如下： 一个客户端请求broker申明一个新的交换机，使用exchange.declare方法，当然，申明中需要一些参数： 如果成功，broker就会使用exchange.declare-ok方法返回一个成功的标示。 <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e1.png\" alt=\"amqp-intro-4-e1\" width=\"566\" height=\"160\" class=\"alignnone size-full wp-image-63\" /></a> <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e2.png\" alt=\"amqp-intro-4-e2\" width=\"574\" height=\"161\" class=\"alignnone size-full wp-image-64\" /></a></p>\n\n<p>同样道理，对于队列类，也有这么一些方法： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e3.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e3.png\" alt=\"amqp-intro-4-e3\" width=\"571\" height=\"156\" class=\"alignnone size-full wp-image-65\" /></a> <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e4.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e4.png\" alt=\"amqp-intro-4-e4\" width=\"582\" height=\"161\" class=\"alignnone size-full wp-image-66\" /></a></p>\n\n<h3>7.1 Connections</h3>\n\n<p>AMQP的连接是长期的，AMQP是一个应用层，使用TCP来完成可靠的消息传递。AMQP的连接使用了认证并且可以使用TLS等加密协议。当一个应用不再需要与AMQP broker连接的时候，他需要友好的断开连接。</p>\n\n<h3>7.2 Channels</h3>\n\n<p>一些应用程序需要与AMQP broker建立多个连接，但是，同时保持多个TCP连接会消耗大量资源。AMQP 0-9-1提出了Channels的概念，Channels可以被认为是<code>在一个TCP连接中多个轻量级的连接</code>。</p>\n\n<p>对于多线程/进程应用，很常见的做法就是一个线程/进程打开一个channel，并且channel之间不共享。</p>\n\n<p>一个channel上的通信与另外一个channel间的通信时完全独立的，所以每个AMQP方法都会携带一个channel号，通过channel号，应用就知道这个方法是出于哪个channel上的。</p>\n\n<h2>7.3 Virtual Hosts</h2>\n\n<p>一个AMQP broler可以产生多个独立的\"环境\"，这就是vhost的概念。就类似于apache等的vhost一样，AMQP客户可以通过协商选择与哪个vhost进行连接。</p>\n\n<h2>参考资料:</h2>\n\n<p><a href=\"http://www.rabbitmq.com/tutorials/amqp-concepts.html\">http://www.rabbitmq.com/tutorials/amqp-concepts.html</a> <a href=\"http://langyu.iteye.com/blog/759663/\">http://langyu.iteye.com/blog/759663/</a> <a href=\"http://pythoner.net/wiki/110/\">http://pythoner.net/wiki/110/</a> <a href=\"http://blog.csdn.net/zhangxinrun/article/details/6546479\">http://blog.csdn.net/zhangxinrun/article/details/6546479</a> <a href=\"http://sunjun041640.blog.163.com/blog/static/25626832201032990829/\">http://sunjun041640.blog.163.com/blog/static/25626832201032990829/</a> <a href=\"http://www.oschina.net/question/12_9192\">http://www.oschina.net/question/12_9192</a> book:RabbitMQ in Action</p>\n','AMQP&RabbitMQ协议及模型入门介绍','','inherit','open','open','','54-revision-4','','','2013-02-28 20:16:07','2013-02-28 12:16:07','','54','http://blog.wachang.net/2013/02/54-revision-4/','0','revision','','0');");
E_D("replace into `wp_posts` values('72','1','2013-02-28 20:16:47','2013-02-28 12:16:47','<blockquote>\n  <p>1本文主要是翻译加总结，通过资料的查询，对AMQP有一定了解; 2 RabbitMQ使用的就是AMQP 0-9-1模型，所以本文其实也是在讲RabbitMQ中的一些原理; 3 文末会列出原文地址</p>\n</blockquote>\n\n<h2>1 What is AMQP?</h2>\n\n<p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，一个网络应用层协议的开放标准，为面向消息的中间件设计。</p>\n\n<p>说白了，这就是一个消费者生产者模型，生产者生产出一个消息，发送到一个队列Queue，消费者(也叫做worker)从队列里面取出这个消息。但是AMQP中，这个消息一般来说是一个任务，生产者消费者一般不在同一台机器上，所以，更好的解释就是，一个程序发送一个任务消息给一个队列，然后消费者程序从队列中拿出这个任务信息，进行执行，可能还需要返回结果。</p>\n\n<p>而RabbitMQ，就是实现了这么一个模型的软件，独立的开源实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、 Ruby、.NET、Java、JMS、C、PHP、 ActionScript、XMPP、STOMP等，支持AJAX。RabbitMQ就是一个服务器，实现了队列的管理，一个程序连接这个服务器，把任务发送给服务器（也即是进入了队列），消费者连接服务器，从队列中取出任务消息，然后执行。</p>\n\n<p>中英文对照： Messaging broker:消息协商器,它在TCP/IP等端口监听AMQ消息，其实就是AMQP的实现，比如RabbitMQ等。 producers：应用程序，产生消息，并publish到消息队列中，下文简称P。 consumers：应用程序，接收消息，然后进行处理，下文简称C。 AMQP client：AMQP客户端，指与AMQP broker连接的P或者C。</p>\n\n<h2>2 AMQP协议</h2>\n\n<h3>2.1 协议概述</h3>\n\n<p>从整体来看，AMQP协议可划分为三层： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-256x300.png\" alt=\"amqp-protocol\" width=\"256\" height=\"300\" class=\"alignnone size-medium wp-image-55\" /></a> AMQP定义了合适的服务器端域模型，用于规范服务器的行为(AMQP服务器端可称为broker)。在这里Model层决定这些基本域模型所产生的行为，这种行为在AMQP中用”command”表示，在后文中会着重来分析这些域模型。Session层定义客户端与broker之间的通信(通信双方都是一个peer，可互称做partner)，为command的可靠传输提供保障。Transport层专注于数据传送，并与Session保持交互，接受上层的数据，组装成二进制流，传送到receiver后再解析数据，交付给Session层。Session层需要Transport层完成网络异常情况的汇报，顺序传送command等工作。</p>\n\n<h3>2.2 协议模型</h3>\n\n<p>AMQP broker主要功能是消息的路由(Routing)和缓存(Buffering)，如下图： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-2.png\" alt=\"amqp-protocol-2\" width=\"571\" height=\"239\" class=\"alignnone size-full wp-image-59\" /></a> Exchange接收消息生产者(Producer)发送的消息根据不同的路由算法将消息发送往Message queue。Message queue会在消息不能被正常消费时缓存这些消息，具体的缓存策略由实现者决定，当message queue与消息消费者(Message consumer)之间的连接通畅时，Message queue有将消息转发到consumer的责任。</p>\n\n<p>Message是当前模型中所操纵的基本单位,基本结构有两部分: Header和Body(playload),Header是由Producer添加上的各种属性的集合，这些属性有控制Message是否可被缓存，接收的queue是哪个，优先级是多少等。Body是真正需要传送的数据，它是对Broker不可见的二进制数据流，在传输过程中不应该受到影响。</p>\n\n<p>一个broker中会存在多个Message queue，Exchange通过binding知道要把消息发送到哪个Message queue,在创建Message queue后需要确定它来接收并保存哪个Exchange路由的结果。Binding是用来关联Exchange与Message queue的域模型,通过关键字bindinds_key。</p>\n\n<p>在与多个Message queue关联后，Exchange中就会存在一个路由表，这个表中存储着每个Message queue所需要消息的限制条件。Exchange就会检查它接受到的每个Message的Header及Body信息，来决定将Message路由到哪个queue中去。Message的Header中应该有个属性叫Routing Key，它由Message发送者产生，提供给Exchange路由这条Message的标准。Exchange根据不同路由算法有不同有Exchange Type。比如有Direct类似，需要Binding key 等于Routing key；也有Binding key与Routing key符合一个模式关系；也有根据Message包含的某些属性来判断。一些基础的路由算法由AMQP所提供，client application也可以自定义各种自己的扩展路由算法。 <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-3.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-3.png\" alt=\"amqp-protocol-3\" width=\"714\" height=\"117\" class=\"alignnone size-full wp-image-58\" /></a> 对于，上图，有一些具体的概念，下面会详细讨论。</p>\n\n<h3>2.3 AMQP 0-9-1 Model流程</h3>\n\n<p>AMQP 0-9-1 Model可以简单的总结如下:P产生消息，然后publish(发布)到exchange(交换机，类比成邮政的邮筒吧)，exchange根据一个规则(bindinds)把消息发送到队列(queue)中，消息协商器要么把消息传递给等待(订阅subdcribe)在某一队列上的的消费者(consumers)，要么消费者就从队列中根据自己的需要取消息。如下图： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-11.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-11.png\" alt=\"amqp-intro-1\" width=\"712\" height=\"319\" class=\"alignnone size-full wp-image-60\" /></a></p>\n\n<p>当publish消息的时候，P可能还会指定消息的属性（meta-data），可能一些meta会被broker使用，而其余的都是由C来使用的。</p>\n\n<p>因为网络不可靠，应用可能处理消息的时候就挂掉了，所以就有一个<code>消息确认机制message acknowledgements</code>:当消息传递给C的时候需要通知broker。当使用消息确认机制的时候，一个broker只有在收到C对于此消息已经被接收的通知后才会删除消息。</p>\n\n<p>某些场景，消息发不到合适的C的时候，消息可能会被返回给P，丢弃，或者说放进一个“死亡队列”，由P来决定如何操作。</p>\n\n<p>队列，交换机，绑定作为AMQP中协作的三个元素。（Queues, exchanges and bindings are collectively referred to as AMQP entities.）</p>\n\n<h2>3 Exchanges and Exchange Types交换机和交换类型</h2>\n\n<p>交换机可以理解成具有路由表的路由程序，仅此而已。每个消息都有一个称为路由键（routing key）的属性，就是一个简单的字符串。交换机当中有一系列的绑定（binding），即路由规则（routes），例如，指明具有路由键 “X” 的消息要到名为timbuku的队列当中去。</p>\n\n<p>交换机从P中接收到一个消息，然后路由(route)发送到一个或者多个队列，AMQP 0-9-1 brokers提供了四种交换类型。</p>\n\n<pre><code>交换类型                默认名字\nDirect exchange      空字符串或者amq.direct\nFanout exchange      amq.Fanout\nTopic exchange       amq.Topic\nHeaders exchange     amq.match (and amq.headers in RabbitMQ)\n</code></pre>\n\n<p>除了交换类型以后，定义交换机的时候还有其他的属性，最重要的几个是：</p>\n\n<ul>\n<li>Name</li>\n<li>Durability（当broker重启后交换机是否能继续工作）</li>\n<li>Auto-delete（所有队列都适用完以后，交换机就被删除）</li>\n<li>Arguments（根据broker的选择而定）</li>\n</ul>\n\n<p>exchanges交换机有两种模式(交换模式与交换类型概念不一样)，Durability表示在broker重启的时候能够恢复之前的工作，而transient模式下则会丢失之前的数据。</p>\n\n<h3>3.1 默认交换exchange</h3>\n\n<p>默认的交换机是一个已经预定义了的没有名字的Direct交换模式，他有一个简单的特性：每创建一个队列，都会通过一个routing&#95;key与exchange绑定，而这个routing&#95;key是和队列名字一样的。</p>\n\n<h3>3.2 直接交换Direct exchange</h3>\n\n<p>处理路由键。需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。这是一个完整的匹配。如果一个队列绑定到该交换机上要求路由键 “dog”，则只有被标记为“dog”的消息才被转发，不会转发dog.puppy，也不会转发dog.guard，只会转发dog。</p>\n\n<ul>\n<li>一个队列通过routing_key K与一个exchange绑定。</li>\n<li>当一个携带routing_key K的消息到达exchange的时候，exchange将消息路由给队列。</li>\n</ul>\n\n<p>直接交换主要用来在多个C，或者说worker（相同的程序实例）之间通过轮训方式分发任务，但是要记住，在AMQP 0-9-1中，消息时在C之间进行负载均衡而不是队列之间进行的。直接交换可以看看下图： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-2.png\" alt=\"amqp-intro-2\" width=\"689\" height=\"511\" class=\"alignnone size-full wp-image-62\" /></a></p>\n\n<h3>3.3 fanout Exchange</h3>\n\n<p>fanout模式将消息发送给所有与之绑定的队列，不处理路由键。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout交换机转发消息是最快的。如下图： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-3-fanout.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-3-fanout.png\" alt=\"amqp-intro-3-fanout\" width=\"713\" height=\"447\" class=\"alignnone size-full wp-image-61\" /></a></p>\n\n<h3>3.4 Topic exchange</h3>\n\n<p>根据消息的routing_key以及队列和交换机绑定的类型，Topic Exchange把消息传递给一个或者多个队列。这就是一个多播的概念。当场景中需要多个C，并且C是有根据的获得消息的时候，Topic Exchange就应该被考虑。具体来说，就是将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“<em>”匹配不多不少一个词。因此“audit.#”能够匹配到“audit.irs.corporate”，但是“audit.</em>” 只会匹配到“audit.irs”。</p>\n\n<h3>3.5 Headers Exchange</h3>\n\n<p>如果不适应routing&#95;key，而是根据消息的多个属性（表现为消息头的形式）的交换就是Headers Exchange，Headers Exchange会忽略routing&#95;key值，相反，用来路由的信息实行消息的头属性中获得的。</p>\n\n<h2>5 队列Queue</h2>\n\n<p>在AMQP中队列就是一个消息的管道，存储C需要的消息，队列知道exchange的一些属性，同时增加了一些自己的属性：</p>\n\n<ul>\n<li>名字</li>\n<li>持续性（Durability），队列在broker重启后恢复</li>\n<li>Exclusive，单个连接中使用，连接断掉后队列被删除</li>\n<li>auto-delete：当C不在获得消息的时候队列被删除</li>\n<li>Arguments：一些broker自己实现的附加功能</li>\n</ul>\n\n<p>在队列使用之前必须被申明（declare），当队列不存在的时候申明队列会创建一个队列，如果队列已经存在，申明队列就不会进行其他操作，但是可以完成对队列存在与否的确认。</p>\n\n<h3>5.1 Queue Names</h3>\n\n<p>应用需要提供队列名，这样broker才能产生一个相应的队列。UTF-8格式，最多255字节，提供一个空字符作为队列名的话，broker会产生一个唯一的队列，同样的方式在C端也可以保证C取得的是P端产生的对应序列，因为P,C都是在一个channel下，而channel是能够记住上一次服务器产生的队列名的。</p>\n\n<p>队列名以\"amq.\"开头的是用于broker内部使用的队列。</p>\n\n<h3>5.2 Queue Durability</h3>\n\n<p>持续当broker重启的时候队列能够恢复，不具有持续性的队列就叫做transient。但是，<code>这里队列的持续性只是当broker重启的时候会自动重新申明队列，而要保证消息不丢失，还需要设置消息为永久性的（消息就存于磁盘而不是内存中）。</code></p>\n\n<h3>5.3 Bindings</h3>\n\n<p>bindings就是一些规则，用来决定消息要路由到哪个队列中去，比如，需要一个交换机E路由一个消息到队列Q，则Q需要先和E进行绑定。Bindings可能需要一些可选的routing&#95;key，routing&#95;key的作用就是选择被publish的特定信息到相应绑定的队列，换句话说，routing_key有点像是一个过滤器。举个例子:</p>\n\n<ul>\n<li>你住在纽约，队列就相当于你的目的地</li>\n<li>交换机就相当于XXX航空</li>\n<li>bindinds就XXX航空到你的住址的线路，可能没得，也可能有多条</li>\n</ul>\n\n<p>如果消息无法送到相应的队列，那么就会丢弃或者返回给P,这些就看相应的机制是怎么样的了。</p>\n\n<h3>5.6 Consumers</h3>\n\n<p>在队列中存储的消息一定要被C所使用。在AMQP 0-9-1模型中，应用程序有两种处理消息的模式：</p>\n\n<ul>\n<li>队列主动把消息传递给C应用(push API)</li>\n<li>C从队列中抓取自己需要的消息(pull API)</li>\n</ul>\n\n<p>在push模式下，应用C需要指明对哪个序列的哪类消息感兴趣，我们称此时队列注册了一个C，或者C订阅了一个队列。一个队列可以有多个C。</p>\n\n<p>每个C都有一个标示符叫做consumer tag，可以用来取消(unsubscribe)对队列消息的订阅，这个tag是一个字符串。</p>\n\n<h2>6 Message消息</h2>\n\n<h3>6.1 Message Acknowledgements 消息确认机制</h3>\n\n<p>Consumer applications-取得消息并且处理消息的应用，有时候可能会因为各种问题挂掉，于是乎就有，AMQP broker如何知道这个消息已经被C接收，是可以删除掉了？AMQP标准中给出了两个选择：</p>\n\n<ul>\n<li>在broker向C应用发送了一个消息后，消息可以被删除(使用basic.deliver or basic.get-ok AMQP方法)</li>\n<li>在C应用返回了一个确认ACK消息以后，消息可以被删除(使用basic.ack AMQP方法)</li>\n</ul>\n\n<p>前一种被叫做自动确认模型(automatic acknowledgement model)，后一种被叫做严格确认模型?(explicit acknowledgement model),在严格模式下C可以选择何时返回这个ACK信息。可以在接收消息的时候就返回，或者处理完消息携带的任务信息以后再返回。</p>\n\n<p>如果C挂掉，并且没有返回ACK信息，那么AMQP broker就会把消息传递给其他的C，如果当前没有可用的C存在，broker就等待，知道有新的C加入进来。</p>\n\n<h3>6.2 Rejecting Messages拒绝消息</h3>\n\n<p>当C取得了消息，但是处理过程中可能不成功，此时C就需要通过拒绝消息机制告诉broker这个消息处理失败，当拒绝消息的时候，C可以要求broker忽略或者从新把消息入队。</p>\n\n<h3>6.3 Negative acknowledgements</h3>\n\n<p>通过<code>basic.reject AMQP</code>方法消息就会被拒绝，但是这个方法有个限制：没办法拒绝一连串的多个消息，但是在RabbitMQ中，有一个解决方案，RabbitMQ提出了一种negative acknowledgements(nacks)机制，更多请参考RabbitMQ手册。</p>\n\n<h3>6.4 Prefetching Messages</h3>\n\n<p>在多个C存在的时候，最好有一种机制指定每个C在返回ACK之前最多能接收多少个消息，这个就有点像负载均衡的思想了。</p>\n\n<h3>6.5 Message Attributes and Payload</h3>\n\n<p>在AMQP中的消息时可以附带属性值(attributes)的，一些常见的属性有：</p>\n\n<ul>\n<li>Content type</li>\n<li>Content encoding</li>\n<li>Routing key</li>\n<li>Delivery mode (persistent or not)</li>\n<li>Message priority</li>\n<li>Message publishing timestamp</li>\n<li>Expiration period</li>\n<li>Producer application id</li>\n</ul>\n\n<p>一些属性可以被选作是消息的头信息。类似HTTP中的X-headers。AMQP消息也有一个负载段（playload），承载相应的数据。broker不会检测和修改负载，当消息被设置成persistent的时候，AMQP broker就会把消息存在磁盘中而不会丢失了。</p>\n\n<h3>6.6 Message acknowledgements</h3>\n\n<h2>7 AMQP 0-9-1 Methods</h2>\n\n<p>AMQP 0-9-1 被组织成各种各样的方法Methods,方法就是某些操作，类似HTTP Method但是和面向对象语言中的方法没有一点关系。AMQP方法被组织成各种类classes,类Class就是方法的集合。比如我们看看exchange class，就有一下操作：</p>\n\n<p>exchange.declare exchange.declare-ok exchange.delete exchange.delete-ok</p>\n\n<p>举例如下： 一个客户端请求broker申明一个新的交换机，使用exchange.declare方法，当然，申明中需要一些参数： 如果成功，broker就会使用exchange.declare-ok方法返回一个成功的标示。 <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e1.png\" alt=\"amqp-intro-4-e1\" width=\"566\" height=\"160\" class=\"alignnone size-full wp-image-63\" /></a> <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e2.png\" alt=\"amqp-intro-4-e2\" width=\"574\" height=\"161\" class=\"alignnone size-full wp-image-64\" /></a></p>\n\n<p>同样道理，对于队列类，也有这么一些方法： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e3.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e3.png\" alt=\"amqp-intro-4-e3\" width=\"571\" height=\"156\" class=\"alignnone size-full wp-image-65\" /></a> <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e4.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e4.png\" alt=\"amqp-intro-4-e4\" width=\"582\" height=\"161\" class=\"alignnone size-full wp-image-66\" /></a></p>\n\n<h3>7.1 Connections</h3>\n\n<p>AMQP的连接是长期的，AMQP是一个应用层，使用TCP来完成可靠的消息传递。AMQP的连接使用了认证并且可以使用TLS等加密协议。当一个应用不再需要与AMQP broker连接的时候，他需要友好的断开连接。</p>\n\n<h3>7.2 Channels</h3>\n\n<p>一些应用程序需要与AMQP broker建立多个连接，但是，同时保持多个TCP连接会消耗大量资源。AMQP 0-9-1提出了Channels的概念，Channels可以被认为是<code>在一个TCP连接中多个轻量级的连接</code>。</p>\n\n<p>对于多线程/进程应用，很常见的做法就是一个线程/进程打开一个channel，并且channel之间不共享。</p>\n\n<p>一个channel上的通信与另外一个channel间的通信时完全独立的，所以每个AMQP方法都会携带一个channel号，通过channel号，应用就知道这个方法是出于哪个channel上的。</p>\n\n<h2>7.3 Virtual Hosts</h2>\n\n<p>一个AMQP broler可以产生多个独立的\"环境\"，这就是vhost的概念。就类似于apache等的vhost一样，AMQP客户可以通过协商选择与哪个vhost进行连接。</p>\n\n<h2>参考资料:</h2>\n\n<p><a href=\"http://www.rabbitmq.com/tutorials/amqp-concepts.html\">http://www.rabbitmq.com/tutorials/amqp-concepts.html</a> <a href=\"http://langyu.iteye.com/blog/759663/\">http://langyu.iteye.com/blog/759663/</a> <a href=\"http://pythoner.net/wiki/110/\">http://pythoner.net/wiki/110/</a> <a href=\"http://blog.csdn.net/zhangxinrun/article/details/6546479\">http://blog.csdn.net/zhangxinrun/article/details/6546479</a> <a href=\"http://sunjun041640.blog.163.com/blog/static/25626832201032990829/\">http://sunjun041640.blog.163.com/blog/static/25626832201032990829/</a> <a href=\"http://www.oschina.net/question/12_9192\">http://www.oschina.net/question/12_9192</a> book:RabbitMQ in Action</p>\n','AMQP&RabbitMQ协议及模型入门介绍','','inherit','open','open','','54-revision-5','','','2013-02-28 20:16:47','2013-02-28 12:16:47','','54','http://blog.wachang.net/2013/02/54-revision-5/','0','revision','','0');");
E_D("replace into `wp_posts` values('73','1','2013-02-28 20:20:54','2013-02-28 12:20:54','<blockquote>\n  <p>1本文主要是翻译加总结，通过资料的查询，对AMQP有一定了解; 2 RabbitMQ使用的就是AMQP 0-9-1模型，所以本文其实也是在讲RabbitMQ中的一些原理; 3 文末会列出原文地址</p>\n</blockquote>\n\n<h2>1 What is AMQP?</h2>\n\n<p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，一个网络应用层协议的开放标准，为面向消息的中间件设计。</p>\n\n<p>说白了，这就是一个消费者生产者模型，生产者生产出一个消息，发送到一个队列Queue，消费者(也叫做worker)从队列里面取出这个消息。但是AMQP中，这个消息一般来说是一个任务，生产者消费者一般不在同一台机器上，所以，更好的解释就是，一个程序发送一个任务消息给一个队列，然后消费者程序从队列中拿出这个任务信息，进行执行，可能还需要返回结果。</p>\n\n<p>而RabbitMQ，就是实现了这么一个模型的软件，独立的开源实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、 Ruby、.NET、Java、JMS、C、PHP、 ActionScript、XMPP、STOMP等，支持AJAX。RabbitMQ就是一个服务器，实现了队列的管理，一个程序连接这个服务器，把任务发送给服务器（也即是进入了队列），消费者连接服务器，从队列中取出任务消息，然后执行。</p>\n\n<p>中英文对照： Messaging broker:消息协商器,它在TCP/IP等端口监听AMQ消息，其实就是AMQP的实现，比如RabbitMQ等。 producers：应用程序，产生消息，并publish到消息队列中，下文简称P。 consumers：应用程序，接收消息，然后进行处理，下文简称C。 AMQP client：AMQP客户端，指与AMQP broker连接的P或者C。</p>\n\n<h2>2 AMQP协议</h2>\n\n<h3>2.1 协议概述</h3>\n\n<p>从整体来看，AMQP协议可划分为三层： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-256x300.png\" alt=\"amqp-protocol\" width=\"256\" height=\"300\" class=\"alignnone size-medium wp-image-55\" /></a> AMQP定义了合适的服务器端域模型，用于规范服务器的行为(AMQP服务器端可称为broker)。在这里Model层决定这些基本域模型所产生的行为，这种行为在AMQP中用”command”表示，在后文中会着重来分析这些域模型。Session层定义客户端与broker之间的通信(通信双方都是一个peer，可互称做partner)，为command的可靠传输提供保障。Transport层专注于数据传送，并与Session保持交互，接受上层的数据，组装成二进制流，传送到receiver后再解析数据，交付给Session层。Session层需要Transport层完成网络异常情况的汇报，顺序传送command等工作。</p>\n\n<h3>2.2 协议模型</h3>\n\n<p>AMQP broker主要功能是消息的路由(Routing)和缓存(Buffering)，如下图： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-2.png\" alt=\"amqp-protocol-2\" width=\"571\" height=\"239\" class=\"alignnone size-full wp-image-59\" /></a> Exchange接收消息生产者(Producer)发送的消息根据不同的路由算法将消息发送往Message queue。Message queue会在消息不能被正常消费时缓存这些消息，具体的缓存策略由实现者决定，当message queue与消息消费者(Message consumer)之间的连接通畅时，Message queue有将消息转发到consumer的责任。</p>\n\n<p>Message是当前模型中所操纵的基本单位,基本结构有两部分: Header和Body(playload),Header是由Producer添加上的各种属性的集合，这些属性有控制Message是否可被缓存，接收的queue是哪个，优先级是多少等。Body是真正需要传送的数据，它是对Broker不可见的二进制数据流，在传输过程中不应该受到影响。</p>\n\n<p>一个broker中会存在多个Message queue，Exchange通过binding知道要把消息发送到哪个Message queue,在创建Message queue后需要确定它来接收并保存哪个Exchange路由的结果。Binding是用来关联Exchange与Message queue的域模型,通过关键字bindinds_key。</p>\n\n<p>在与多个Message queue关联后，Exchange中就会存在一个路由表，这个表中存储着每个Message queue所需要消息的限制条件。Exchange就会检查它接受到的每个Message的Header及Body信息，来决定将Message路由到哪个queue中去。Message的Header中应该有个属性叫Routing Key，它由Message发送者产生，提供给Exchange路由这条Message的标准。Exchange根据不同路由算法有不同有Exchange Type。比如有Direct类似，需要Binding key 等于Routing key；也有Binding key与Routing key符合一个模式关系；也有根据Message包含的某些属性来判断。一些基础的路由算法由AMQP所提供，client application也可以自定义各种自己的扩展路由算法。 <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-3.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-3.png\" alt=\"amqp-protocol-3\" width=\"714\" height=\"117\" class=\"alignnone size-full wp-image-58\" /></a> 对于，上图，有一些具体的概念，下面会详细讨论。</p>\n\n<h3>2.3 AMQP 0-9-1 Model流程</h3>\n\n<p>AMQP 0-9-1 Model可以简单的总结如下:P产生消息，然后publish(发布)到exchange(交换机，类比成邮政的邮筒吧)，exchange根据一个规则(bindinds)把消息发送到队列(queue)中，消息协商器要么把消息传递给等待(订阅subdcribe)在某一队列上的的消费者(consumers)，要么消费者就从队列中根据自己的需要取消息。如下图： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-11.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-11.png\" alt=\"amqp-intro-1\" width=\"712\" height=\"319\" class=\"alignnone size-full wp-image-60\" /></a></p>\n\n<p>当publish消息的时候，P可能还会指定消息的属性（meta-data），可能一些meta会被broker使用，而其余的都是由C来使用的。</p>\n\n<p>因为网络不可靠，应用可能处理消息的时候就挂掉了，所以就有一个<code>消息确认机制message acknowledgements</code>:当消息传递给C的时候需要通知broker。当使用消息确认机制的时候，一个broker只有在收到C对于此消息已经被接收的通知后才会删除消息。</p>\n\n<p>某些场景，消息发不到合适的C的时候，消息可能会被返回给P，丢弃，或者说放进一个“死亡队列”，由P来决定如何操作。</p>\n\n<p>队列，交换机，绑定作为AMQP中协作的三个元素。（Queues, exchanges and bindings are collectively referred to as AMQP entities.）</p>\n\n<h2>3 Exchanges and Exchange Types交换机和交换类型</h2>\n\n<p>交换机可以理解成具有路由表的路由程序，仅此而已。每个消息都有一个称为路由键（routing key）的属性，就是一个简单的字符串。交换机当中有一系列的绑定（binding），即路由规则（routes），例如，指明具有路由键 “X” 的消息要到名为timbuku的队列当中去。</p>\n\n<p>交换机从P中接收到一个消息，然后路由(route)发送到一个或者多个队列，AMQP 0-9-1 brokers提供了四种交换类型。</p>\n\n<pre><code>交换类型                默认名字\nDirect exchange      空字符串或者amq.direct\nFanout exchange      amq.Fanout\nTopic exchange       amq.Topic\nHeaders exchange     amq.match (and amq.headers in RabbitMQ)\n</code></pre>\n\n<p>除了交换类型以后，定义交换机的时候还有其他的属性，最重要的几个是：</p>\n\n<ul>\n<li>Name</li>\n<li>Durability（当broker重启后交换机是否能继续工作）</li>\n<li>Auto-delete（所有队列都适用完以后，交换机就被删除）</li>\n<li>Arguments（根据broker的选择而定）</li>\n</ul>\n\n<p>exchanges交换机有两种模式(交换模式与交换类型概念不一样)，Durability表示在broker重启的时候能够恢复之前的工作，而transient模式下则会丢失之前的数据。</p>\n\n<h3>3.1 默认交换exchange</h3>\n\n<p>默认的交换机是一个已经预定义了的没有名字的Direct交换模式，他有一个简单的特性：每创建一个队列，都会通过一个routing&#95;key与exchange绑定，而这个routing&#95;key是和队列名字一样的。</p>\n\n<h3>3.2 直接交换Direct exchange</h3>\n\n<p>处理路由键。需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。这是一个完整的匹配。如果一个队列绑定到该交换机上要求路由键 “dog”，则只有被标记为“dog”的消息才被转发，不会转发dog.puppy，也不会转发dog.guard，只会转发dog。</p>\n\n<ul>\n<li>一个队列通过routing_key K与一个exchange绑定。</li>\n<li>当一个携带routing_key K的消息到达exchange的时候，exchange将消息路由给队列。</li>\n</ul>\n\n<p>直接交换主要用来在多个C，或者说worker（相同的程序实例）之间通过轮训方式分发任务，但是要记住，在AMQP 0-9-1中，消息时在C之间进行负载均衡而不是队列之间进行的。直接交换可以看看下图： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-2.png\" alt=\"amqp-intro-2\" width=\"689\" height=\"511\" class=\"alignnone size-full wp-image-62\" /></a></p>\n\n<h3>3.3 fanout Exchange</h3>\n\n<p>fanout模式将消息发送给所有与之绑定的队列，不处理路由键。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout交换机转发消息是最快的。如下图： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-3-fanout.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-3-fanout.png\" alt=\"amqp-intro-3-fanout\" width=\"713\" height=\"447\" class=\"alignnone size-full wp-image-61\" /></a></p>\n\n<h3>3.4 Topic exchange</h3>\n\n<p>根据消息的routing_key以及队列和交换机绑定的类型，Topic Exchange把消息传递给一个或者多个队列。这就是一个多播的概念。当场景中需要多个C，并且C是有根据的获得消息的时候，Topic Exchange就应该被考虑。具体来说，就是将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“<em>”匹配不多不少一个词。因此“audit.#”能够匹配到“audit.irs.corporate”，但是“audit.</em>” 只会匹配到“audit.irs”。</p>\n\n<h3>3.5 Headers Exchange</h3>\n\n<p>如果不适应routing&#95;key，而是根据消息的多个属性（表现为消息头的形式）的交换就是Headers Exchange，Headers Exchange会忽略routing&#95;key值，相反，用来路由的信息实行消息的头属性中获得的。</p>\n\n<h2>5 队列Queue</h2>\n\n<p>在AMQP中队列就是一个消息的管道，存储C需要的消息，队列知道exchange的一些属性，同时增加了一些自己的属性：</p>\n\n<ul>\n<li>名字</li>\n<li>持续性（Durability），队列在broker重启后恢复</li>\n<li>Exclusive，单个连接中使用，连接断掉后队列被删除</li>\n<li>auto-delete：当C不在获得消息的时候队列被删除</li>\n<li>Arguments：一些broker自己实现的附加功能</li>\n</ul>\n\n<p>在队列使用之前必须被申明（declare），当队列不存在的时候申明队列会创建一个队列，如果队列已经存在，申明队列就不会进行其他操作，但是可以完成对队列存在与否的确认。</p>\n\n<h3>5.1 Queue Names</h3>\n\n<p>应用需要提供队列名，这样broker才能产生一个相应的队列。UTF-8格式，最多255字节，提供一个空字符作为队列名的话，broker会产生一个唯一的队列，同样的方式在C端也可以保证C取得的是P端产生的对应序列，因为P,C都是在一个channel下，而channel是能够记住上一次服务器产生的队列名的。</p>\n\n<p>队列名以\"amq.\"开头的是用于broker内部使用的队列。</p>\n\n<h3>5.2 Queue Durability</h3>\n\n<p>持续当broker重启的时候队列能够恢复，不具有持续性的队列就叫做transient。但是，<code>这里队列的持续性只是当broker重启的时候会自动重新申明队列，而要保证消息不丢失，还需要设置消息为永久性的（消息就存于磁盘而不是内存中）。</code></p>\n\n<h3>5.3 Bindings</h3>\n\n<p>bindings就是一些规则，用来决定消息要路由到哪个队列中去，比如，需要一个交换机E路由一个消息到队列Q，则Q需要先和E进行绑定。Bindings可能需要一些可选的routing&#95;key，routing&#95;key的作用就是选择被publish的特定信息到相应绑定的队列，换句话说，routing_key有点像是一个过滤器。举个例子:</p>\n\n<ul>\n<li>你住在纽约，队列就相当于你的目的地</li>\n<li>交换机就相当于XXX航空</li>\n<li>bindinds就XXX航空到你的住址的线路，可能没得，也可能有多条</li>\n</ul>\n\n<p>如果消息无法送到相应的队列，那么就会丢弃或者返回给P,这些就看相应的机制是怎么样的了。</p>\n\n<h3>5.6 Consumers</h3>\n\n<p>在队列中存储的消息一定要被C所使用。在AMQP 0-9-1模型中，应用程序有两种处理消息的模式：</p>\n\n<ul>\n<li>队列主动把消息传递给C应用(push API)</li>\n<li>C从队列中抓取自己需要的消息(pull API)</li>\n</ul>\n\n<p>在push模式下，应用C需要指明对哪个序列的哪类消息感兴趣，我们称此时队列注册了一个C，或者C订阅了一个队列。一个队列可以有多个C。</p>\n\n<p>每个C都有一个标示符叫做consumer tag，可以用来取消(unsubscribe)对队列消息的订阅，这个tag是一个字符串。</p>\n\n<h2>6 Message消息</h2>\n\n<h3>6.1 Message Acknowledgements 消息确认机制</h3>\n\n<p>Consumer applications-取得消息并且处理消息的应用，有时候可能会因为各种问题挂掉，于是乎就有，AMQP broker如何知道这个消息已经被C接收，是可以删除掉了？AMQP标准中给出了两个选择：</p>\n\n<ul>\n<li>在broker向C应用发送了一个消息后，消息可以被删除(使用basic.deliver or basic.get-ok AMQP方法)</li>\n<li>在C应用返回了一个确认ACK消息以后，消息可以被删除(使用basic.ack AMQP方法)</li>\n</ul>\n\n<p>前一种被叫做自动确认模型(automatic acknowledgement model)，后一种被叫做严格确认模型?(explicit acknowledgement model),在严格模式下C可以选择何时返回这个ACK信息。可以在接收消息的时候就返回，或者处理完消息携带的任务信息以后再返回。</p>\n\n<p>如果C挂掉，并且没有返回ACK信息，那么AMQP broker就会把消息传递给其他的C，如果当前没有可用的C存在，broker就等待，知道有新的C加入进来。</p>\n\n<h3>6.2 Rejecting Messages拒绝消息</h3>\n\n<p>当C取得了消息，但是处理过程中可能不成功，此时C就需要通过拒绝消息机制告诉broker这个消息处理失败，当拒绝消息的时候，C可以要求broker忽略或者从新把消息入队。</p>\n\n<h3>6.3 Negative acknowledgements</h3>\n\n<p>通过<code>basic.reject AMQP</code>方法消息就会被拒绝，但是这个方法有个限制：没办法拒绝一连串的多个消息，但是在RabbitMQ中，有一个解决方案，RabbitMQ提出了一种negative acknowledgements(nacks)机制，更多请参考RabbitMQ手册。</p>\n\n<h3>6.4 Prefetching Messages</h3>\n\n<p>在多个C存在的时候，最好有一种机制指定每个C在返回ACK之前最多能接收多少个消息，这个就有点像负载均衡的思想了。</p>\n\n<h3>6.5 Message Attributes and Payload</h3>\n\n<p>在AMQP中的消息时可以附带属性值(attributes)的，一些常见的属性有：</p>\n\n<ul>\n<li>Content type</li>\n<li>Content encoding</li>\n<li>Routing key</li>\n<li>Delivery mode (persistent or not)</li>\n<li>Message priority</li>\n<li>Message publishing timestamp</li>\n<li>Expiration period</li>\n<li>Producer application id</li>\n</ul>\n\n<p>一些属性可以被选作是消息的头信息。类似HTTP中的X-headers。AMQP消息也有一个负载段（playload），承载相应的数据。broker不会检测和修改负载，当消息被设置成persistent的时候，AMQP broker就会把消息存在磁盘中而不会丢失了。</p>\n\n<h3>6.6 Message acknowledgements</h3>\n\n<h2>7 AMQP 0-9-1 Methods</h2>\n\n<p>AMQP 0-9-1 被组织成各种各样的方法Methods,方法就是某些操作，类似HTTP Method但是和面向对象语言中的方法没有一点关系。AMQP方法被组织成各种类classes,类Class就是方法的集合。比如我们看看exchange class，就有一下操作：</p>\n\n<p>exchange.declare exchange.declare-ok exchange.delete exchange.delete-ok</p>\n\n<p>举例如下： 一个客户端请求broker申明一个新的交换机，使用exchange.declare方法，当然，申明中需要一些参数： 如果成功，broker就会使用exchange.declare-ok方法返回一个成功的标示。 <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e1.png\" alt=\"amqp-intro-4-e1\" width=\"566\" height=\"160\" class=\"alignnone size-full wp-image-63\" /></a> <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e2.png\" alt=\"amqp-intro-4-e2\" width=\"574\" height=\"161\" class=\"alignnone size-full wp-image-64\" /></a></p>\n\n<p>同样道理，对于队列类，也有这么一些方法： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e3.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e3.png\" alt=\"amqp-intro-4-e3\" width=\"571\" height=\"156\" class=\"alignnone size-full wp-image-65\" /></a> <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e4.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e4.png\" alt=\"amqp-intro-4-e4\" width=\"582\" height=\"161\" class=\"alignnone size-full wp-image-66\" /></a></p>\n\n<h3>7.1 Connections</h3>\n\n<p>AMQP的连接是长期的，AMQP是一个应用层，使用TCP来完成可靠的消息传递。AMQP的连接使用了认证并且可以使用TLS等加密协议。当一个应用不再需要与AMQP broker连接的时候，他需要友好的断开连接。</p>\n\n<h3>7.2 Channels</h3>\n\n<p>一些应用程序需要与AMQP broker建立多个连接，但是，同时保持多个TCP连接会消耗大量资源。AMQP 0-9-1提出了Channels的概念，Channels可以被认为是<code>在一个TCP连接中多个轻量级的连接</code>。</p>\n\n<p>对于多线程/进程应用，很常见的做法就是一个线程/进程打开一个channel，并且channel之间不共享。</p>\n\n<p>一个channel上的通信与另外一个channel间的通信时完全独立的，所以每个AMQP方法都会携带一个channel号，通过channel号，应用就知道这个方法是出于哪个channel上的。</p>\n\n<h2>7.3 Virtual Hosts</h2>\n\n<p>一个AMQP broler可以产生多个独立的\"环境\"，这就是vhost的概念。就类似于apache等的vhost一样，AMQP客户可以通过协商选择与哪个vhost进行连接。</p>\n\n<h2>参考资料:</h2>\n\n<p><a href=\"http://www.rabbitmq.com/tutorials/amqp-concepts.html\">http://www.rabbitmq.com/tutorials/amqp-concepts.html</a> <a href=\"http://langyu.iteye.com/blog/759663/\">http://langyu.iteye.com/blog/759663/</a> <a href=\"http://pythoner.net/wiki/110/\">http://pythoner.net/wiki/110/</a> <a href=\"http://blog.csdn.net/zhangxinrun/article/details/6546479\">http://blog.csdn.net/zhangxinrun/article/details/6546479</a> <a href=\"http://sunjun041640.blog.163.com/blog/static/25626832201032990829/\">http://sunjun041640.blog.163.com/blog/static/25626832201032990829/</a> <a href=\"http://www.oschina.net/question/12_9192\">http://www.oschina.net/question/12_9192</a> book:RabbitMQ in Action</p>\n','AMQP&RabbitMQ协议及模型入门介绍','','inherit','open','open','','54-revision-6','','','2013-02-28 20:20:54','2013-02-28 12:20:54','','54','http://blog.wachang.net/2013/02/54-revision-6/','0','revision','','0');");
E_D("replace into `wp_posts` values('74','1','2013-02-28 20:29:23','2013-02-28 12:29:23','','amqp-logo','','inherit','open','open','','amqp-logo-2','','','2013-02-28 20:29:23','2013-02-28 12:29:23','','54','http://blog.wachang.net/wp-content/uploads/2013/02/amqp-logo1.png','0','attachment','image/png','0');");
E_D("replace into `wp_posts` values('75','1','2013-02-28 20:26:48','2013-02-28 12:26:48','<blockquote>\n  <p>1本文主要是翻译加总结，通过资料的查询，对AMQP有一定了解; 2 RabbitMQ使用的就是AMQP 0-9-1模型，所以本文其实也是在讲RabbitMQ中的一些原理; 3 文末会列出原文地址</p>\n</blockquote>\n\n<h2>1 What is AMQP?</h2>\n\n<p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，一个网络应用层协议的开放标准，为面向消息的中间件设计。</p>\n\n<p>说白了，这就是一个消费者生产者模型，生产者生产出一个消息，发送到一个队列Queue，消费者(也叫做worker)从队列里面取出这个消息。但是AMQP中，这个消息一般来说是一个任务，生产者消费者一般不在同一台机器上，所以，更好的解释就是，一个程序发送一个任务消息给一个队列，然后消费者程序从队列中拿出这个任务信息，进行执行，可能还需要返回结果。</p>\n\n<p>而RabbitMQ，就是实现了这么一个模型的软件，独立的开源实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、 Ruby、.NET、Java、JMS、C、PHP、 ActionScript、XMPP、STOMP等，支持AJAX。RabbitMQ就是一个服务器，实现了队列的管理，一个程序连接这个服务器，把任务发送给服务器（也即是进入了队列），消费者连接服务器，从队列中取出任务消息，然后执行。</p>\n\n<p>中英文对照： Messaging broker:消息协商器,它在TCP/IP等端口监听AMQ消息，其实就是AMQP的实现，比如RabbitMQ等。 producers：应用程序，产生消息，并publish到消息队列中，下文简称P。 consumers：应用程序，接收消息，然后进行处理，下文简称C。 AMQP client：AMQP客户端，指与AMQP broker连接的P或者C。</p>\n\n<h2>2 AMQP协议</h2>\n\n<h3>2.1 协议概述</h3>\n\n<p>从整体来看，AMQP协议可划分为三层： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-256x300.png\" alt=\"amqp-protocol\" width=\"256\" height=\"300\" class=\"alignnone size-medium wp-image-55\" /></a> AMQP定义了合适的服务器端域模型，用于规范服务器的行为(AMQP服务器端可称为broker)。在这里Model层决定这些基本域模型所产生的行为，这种行为在AMQP中用”command”表示，在后文中会着重来分析这些域模型。Session层定义客户端与broker之间的通信(通信双方都是一个peer，可互称做partner)，为command的可靠传输提供保障。Transport层专注于数据传送，并与Session保持交互，接受上层的数据，组装成二进制流，传送到receiver后再解析数据，交付给Session层。Session层需要Transport层完成网络异常情况的汇报，顺序传送command等工作。</p>\n\n<h3>2.2 协议模型</h3>\n\n<p>AMQP broker主要功能是消息的路由(Routing)和缓存(Buffering)，如下图： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-2.png\" alt=\"amqp-protocol-2\" width=\"571\" height=\"239\" class=\"alignnone size-full wp-image-59\" /></a> Exchange接收消息生产者(Producer)发送的消息根据不同的路由算法将消息发送往Message queue。Message queue会在消息不能被正常消费时缓存这些消息，具体的缓存策略由实现者决定，当message queue与消息消费者(Message consumer)之间的连接通畅时，Message queue有将消息转发到consumer的责任。</p>\n\n<p>Message是当前模型中所操纵的基本单位,基本结构有两部分: Header和Body(playload),Header是由Producer添加上的各种属性的集合，这些属性有控制Message是否可被缓存，接收的queue是哪个，优先级是多少等。Body是真正需要传送的数据，它是对Broker不可见的二进制数据流，在传输过程中不应该受到影响。</p>\n\n<p>一个broker中会存在多个Message queue，Exchange通过binding知道要把消息发送到哪个Message queue,在创建Message queue后需要确定它来接收并保存哪个Exchange路由的结果。Binding是用来关联Exchange与Message queue的域模型,通过关键字bindinds_key。</p>\n\n<p>在与多个Message queue关联后，Exchange中就会存在一个路由表，这个表中存储着每个Message queue所需要消息的限制条件。Exchange就会检查它接受到的每个Message的Header及Body信息，来决定将Message路由到哪个queue中去。Message的Header中应该有个属性叫Routing Key，它由Message发送者产生，提供给Exchange路由这条Message的标准。Exchange根据不同路由算法有不同有Exchange Type。比如有Direct类似，需要Binding key 等于Routing key；也有Binding key与Routing key符合一个模式关系；也有根据Message包含的某些属性来判断。一些基础的路由算法由AMQP所提供，client application也可以自定义各种自己的扩展路由算法。 <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-3.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-protocol-3.png\" alt=\"amqp-protocol-3\" width=\"714\" height=\"117\" class=\"alignnone size-full wp-image-58\" /></a> 对于，上图，有一些具体的概念，下面会详细讨论。</p>\n\n<h3>2.3 AMQP 0-9-1 Model流程</h3>\n\n<p>AMQP 0-9-1 Model可以简单的总结如下:P产生消息，然后publish(发布)到exchange(交换机，类比成邮政的邮筒吧)，exchange根据一个规则(bindinds)把消息发送到队列(queue)中，消息协商器要么把消息传递给等待(订阅subdcribe)在某一队列上的的消费者(consumers)，要么消费者就从队列中根据自己的需要取消息。如下图： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-11.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-11.png\" alt=\"amqp-intro-1\" width=\"712\" height=\"319\" class=\"alignnone size-full wp-image-60\" /></a></p>\n\n<p>当publish消息的时候，P可能还会指定消息的属性（meta-data），可能一些meta会被broker使用，而其余的都是由C来使用的。</p>\n\n<p>因为网络不可靠，应用可能处理消息的时候就挂掉了，所以就有一个<code>消息确认机制message acknowledgements</code>:当消息传递给C的时候需要通知broker。当使用消息确认机制的时候，一个broker只有在收到C对于此消息已经被接收的通知后才会删除消息。</p>\n\n<p>某些场景，消息发不到合适的C的时候，消息可能会被返回给P，丢弃，或者说放进一个“死亡队列”，由P来决定如何操作。</p>\n\n<p>队列，交换机，绑定作为AMQP中协作的三个元素。（Queues, exchanges and bindings are collectively referred to as AMQP entities.）</p>\n\n<h2>3 Exchanges and Exchange Types交换机和交换类型</h2>\n\n<p>交换机可以理解成具有路由表的路由程序，仅此而已。每个消息都有一个称为路由键（routing key）的属性，就是一个简单的字符串。交换机当中有一系列的绑定（binding），即路由规则（routes），例如，指明具有路由键 “X” 的消息要到名为timbuku的队列当中去。</p>\n\n<p>交换机从P中接收到一个消息，然后路由(route)发送到一个或者多个队列，AMQP 0-9-1 brokers提供了四种交换类型。</p>\n\n<pre><code>交换类型                默认名字\nDirect exchange      空字符串或者amq.direct\nFanout exchange      amq.Fanout\nTopic exchange       amq.Topic\nHeaders exchange     amq.match (and amq.headers in RabbitMQ)\n</code></pre>\n\n<p>除了交换类型以后，定义交换机的时候还有其他的属性，最重要的几个是：</p>\n\n<ul>\n<li>Name</li>\n<li>Durability（当broker重启后交换机是否能继续工作）</li>\n<li>Auto-delete（所有队列都适用完以后，交换机就被删除）</li>\n<li>Arguments（根据broker的选择而定）</li>\n</ul>\n\n<p>exchanges交换机有两种模式(交换模式与交换类型概念不一样)，Durability表示在broker重启的时候能够恢复之前的工作，而transient模式下则会丢失之前的数据。</p>\n\n<h3>3.1 默认交换exchange</h3>\n\n<p>默认的交换机是一个已经预定义了的没有名字的Direct交换模式，他有一个简单的特性：每创建一个队列，都会通过一个routing&#95;key与exchange绑定，而这个routing&#95;key是和队列名字一样的。</p>\n\n<h3>3.2 直接交换Direct exchange</h3>\n\n<p>处理路由键。需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。这是一个完整的匹配。如果一个队列绑定到该交换机上要求路由键 “dog”，则只有被标记为“dog”的消息才被转发，不会转发dog.puppy，也不会转发dog.guard，只会转发dog。</p>\n\n<ul>\n<li>一个队列通过routing_key K与一个exchange绑定。</li>\n<li>当一个携带routing_key K的消息到达exchange的时候，exchange将消息路由给队列。</li>\n</ul>\n\n<p>直接交换主要用来在多个C，或者说worker（相同的程序实例）之间通过轮训方式分发任务，但是要记住，在AMQP 0-9-1中，消息时在C之间进行负载均衡而不是队列之间进行的。直接交换可以看看下图： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-2.png\" alt=\"amqp-intro-2\" width=\"689\" height=\"511\" class=\"alignnone size-full wp-image-62\" /></a></p>\n\n<h3>3.3 fanout Exchange</h3>\n\n<p>fanout模式将消息发送给所有与之绑定的队列，不处理路由键。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout交换机转发消息是最快的。如下图： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-3-fanout.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-3-fanout.png\" alt=\"amqp-intro-3-fanout\" width=\"713\" height=\"447\" class=\"alignnone size-full wp-image-61\" /></a></p>\n\n<h3>3.4 Topic exchange</h3>\n\n<p>根据消息的routing_key以及队列和交换机绑定的类型，Topic Exchange把消息传递给一个或者多个队列。这就是一个多播的概念。当场景中需要多个C，并且C是有根据的获得消息的时候，Topic Exchange就应该被考虑。具体来说，就是将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“<em>”匹配不多不少一个词。因此“audit.#”能够匹配到“audit.irs.corporate”，但是“audit.</em>” 只会匹配到“audit.irs”。</p>\n\n<h3>3.5 Headers Exchange</h3>\n\n<p>如果不适应routing&#95;key，而是根据消息的多个属性（表现为消息头的形式）的交换就是Headers Exchange，Headers Exchange会忽略routing&#95;key值，相反，用来路由的信息实行消息的头属性中获得的。</p>\n\n<h2>5 队列Queue</h2>\n\n<p>在AMQP中队列就是一个消息的管道，存储C需要的消息，队列知道exchange的一些属性，同时增加了一些自己的属性：</p>\n\n<ul>\n<li>名字</li>\n<li>持续性（Durability），队列在broker重启后恢复</li>\n<li>Exclusive，单个连接中使用，连接断掉后队列被删除</li>\n<li>auto-delete：当C不在获得消息的时候队列被删除</li>\n<li>Arguments：一些broker自己实现的附加功能</li>\n</ul>\n\n<p>在队列使用之前必须被申明（declare），当队列不存在的时候申明队列会创建一个队列，如果队列已经存在，申明队列就不会进行其他操作，但是可以完成对队列存在与否的确认。</p>\n\n<h3>5.1 Queue Names</h3>\n\n<p>应用需要提供队列名，这样broker才能产生一个相应的队列。UTF-8格式，最多255字节，提供一个空字符作为队列名的话，broker会产生一个唯一的队列，同样的方式在C端也可以保证C取得的是P端产生的对应序列，因为P,C都是在一个channel下，而channel是能够记住上一次服务器产生的队列名的。</p>\n\n<p>队列名以\"amq.\"开头的是用于broker内部使用的队列。</p>\n\n<h3>5.2 Queue Durability</h3>\n\n<p>持续当broker重启的时候队列能够恢复，不具有持续性的队列就叫做transient。但是，<code>这里队列的持续性只是当broker重启的时候会自动重新申明队列，而要保证消息不丢失，还需要设置消息为永久性的（消息就存于磁盘而不是内存中）。</code></p>\n\n<h3>5.3 Bindings</h3>\n\n<p>bindings就是一些规则，用来决定消息要路由到哪个队列中去，比如，需要一个交换机E路由一个消息到队列Q，则Q需要先和E进行绑定。Bindings可能需要一些可选的routing&#95;key，routing&#95;key的作用就是选择被publish的特定信息到相应绑定的队列，换句话说，routing_key有点像是一个过滤器。举个例子:</p>\n\n<ul>\n<li>你住在纽约，队列就相当于你的目的地</li>\n<li>交换机就相当于XXX航空</li>\n<li>bindinds就XXX航空到你的住址的线路，可能没得，也可能有多条</li>\n</ul>\n\n<p>如果消息无法送到相应的队列，那么就会丢弃或者返回给P,这些就看相应的机制是怎么样的了。</p>\n\n<h3>5.6 Consumers</h3>\n\n<p>在队列中存储的消息一定要被C所使用。在AMQP 0-9-1模型中，应用程序有两种处理消息的模式：</p>\n\n<ul>\n<li>队列主动把消息传递给C应用(push API)</li>\n<li>C从队列中抓取自己需要的消息(pull API)</li>\n</ul>\n\n<p>在push模式下，应用C需要指明对哪个序列的哪类消息感兴趣，我们称此时队列注册了一个C，或者C订阅了一个队列。一个队列可以有多个C。</p>\n\n<p>每个C都有一个标示符叫做consumer tag，可以用来取消(unsubscribe)对队列消息的订阅，这个tag是一个字符串。</p>\n\n<h2>6 Message消息</h2>\n\n<h3>6.1 Message Acknowledgements 消息确认机制</h3>\n\n<p>Consumer applications-取得消息并且处理消息的应用，有时候可能会因为各种问题挂掉，于是乎就有，AMQP broker如何知道这个消息已经被C接收，是可以删除掉了？AMQP标准中给出了两个选择：</p>\n\n<ul>\n<li>在broker向C应用发送了一个消息后，消息可以被删除(使用basic.deliver or basic.get-ok AMQP方法)</li>\n<li>在C应用返回了一个确认ACK消息以后，消息可以被删除(使用basic.ack AMQP方法)</li>\n</ul>\n\n<p>前一种被叫做自动确认模型(automatic acknowledgement model)，后一种被叫做严格确认模型?(explicit acknowledgement model),在严格模式下C可以选择何时返回这个ACK信息。可以在接收消息的时候就返回，或者处理完消息携带的任务信息以后再返回。</p>\n\n<p>如果C挂掉，并且没有返回ACK信息，那么AMQP broker就会把消息传递给其他的C，如果当前没有可用的C存在，broker就等待，知道有新的C加入进来。</p>\n\n<h3>6.2 Rejecting Messages拒绝消息</h3>\n\n<p>当C取得了消息，但是处理过程中可能不成功，此时C就需要通过拒绝消息机制告诉broker这个消息处理失败，当拒绝消息的时候，C可以要求broker忽略或者从新把消息入队。</p>\n\n<h3>6.3 Negative acknowledgements</h3>\n\n<p>通过<code>basic.reject AMQP</code>方法消息就会被拒绝，但是这个方法有个限制：没办法拒绝一连串的多个消息，但是在RabbitMQ中，有一个解决方案，RabbitMQ提出了一种negative acknowledgements(nacks)机制，更多请参考RabbitMQ手册。</p>\n\n<h3>6.4 Prefetching Messages</h3>\n\n<p>在多个C存在的时候，最好有一种机制指定每个C在返回ACK之前最多能接收多少个消息，这个就有点像负载均衡的思想了。</p>\n\n<h3>6.5 Message Attributes and Payload</h3>\n\n<p>在AMQP中的消息时可以附带属性值(attributes)的，一些常见的属性有：</p>\n\n<ul>\n<li>Content type</li>\n<li>Content encoding</li>\n<li>Routing key</li>\n<li>Delivery mode (persistent or not)</li>\n<li>Message priority</li>\n<li>Message publishing timestamp</li>\n<li>Expiration period</li>\n<li>Producer application id</li>\n</ul>\n\n<p>一些属性可以被选作是消息的头信息。类似HTTP中的X-headers。AMQP消息也有一个负载段（playload），承载相应的数据。broker不会检测和修改负载，当消息被设置成persistent的时候，AMQP broker就会把消息存在磁盘中而不会丢失了。</p>\n\n<h3>6.6 Message acknowledgements</h3>\n\n<h2>7 AMQP 0-9-1 Methods</h2>\n\n<p>AMQP 0-9-1 被组织成各种各样的方法Methods,方法就是某些操作，类似HTTP Method但是和面向对象语言中的方法没有一点关系。AMQP方法被组织成各种类classes,类Class就是方法的集合。比如我们看看exchange class，就有一下操作：</p>\n\n<p>exchange.declare exchange.declare-ok exchange.delete exchange.delete-ok</p>\n\n<p>举例如下： 一个客户端请求broker申明一个新的交换机，使用exchange.declare方法，当然，申明中需要一些参数： 如果成功，broker就会使用exchange.declare-ok方法返回一个成功的标示。 <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e1.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e1.png\" alt=\"amqp-intro-4-e1\" width=\"566\" height=\"160\" class=\"alignnone size-full wp-image-63\" /></a> <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e2.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e2.png\" alt=\"amqp-intro-4-e2\" width=\"574\" height=\"161\" class=\"alignnone size-full wp-image-64\" /></a></p>\n\n<p>同样道理，对于队列类，也有这么一些方法： <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e3.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e3.png\" alt=\"amqp-intro-4-e3\" width=\"571\" height=\"156\" class=\"alignnone size-full wp-image-65\" /></a> <a href=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e4.png\"><img src=\"http://blog.wachang.net/wp-content/uploads/2013/02/amqp-intro-4-e4.png\" alt=\"amqp-intro-4-e4\" width=\"582\" height=\"161\" class=\"alignnone size-full wp-image-66\" /></a></p>\n\n<h3>7.1 Connections</h3>\n\n<p>AMQP的连接是长期的，AMQP是一个应用层，使用TCP来完成可靠的消息传递。AMQP的连接使用了认证并且可以使用TLS等加密协议。当一个应用不再需要与AMQP broker连接的时候，他需要友好的断开连接。</p>\n\n<h3>7.2 Channels</h3>\n\n<p>一些应用程序需要与AMQP broker建立多个连接，但是，同时保持多个TCP连接会消耗大量资源。AMQP 0-9-1提出了Channels的概念，Channels可以被认为是<code>在一个TCP连接中多个轻量级的连接</code>。</p>\n\n<p>对于多线程/进程应用，很常见的做法就是一个线程/进程打开一个channel，并且channel之间不共享。</p>\n\n<p>一个channel上的通信与另外一个channel间的通信时完全独立的，所以每个AMQP方法都会携带一个channel号，通过channel号，应用就知道这个方法是出于哪个channel上的。</p>\n\n<h2>7.3 Virtual Hosts</h2>\n\n<p>一个AMQP broler可以产生多个独立的\"环境\"，这就是vhost的概念。就类似于apache等的vhost一样，AMQP客户可以通过协商选择与哪个vhost进行连接。</p>\n\n<h2>参考资料:</h2>\n\n<p><a href=\"http://www.rabbitmq.com/tutorials/amqp-concepts.html\">http://www.rabbitmq.com/tutorials/amqp-concepts.html</a> <a href=\"http://langyu.iteye.com/blog/759663/\">http://langyu.iteye.com/blog/759663/</a> <a href=\"http://pythoner.net/wiki/110/\">http://pythoner.net/wiki/110/</a> <a href=\"http://blog.csdn.net/zhangxinrun/article/details/6546479\">http://blog.csdn.net/zhangxinrun/article/details/6546479</a> <a href=\"http://sunjun041640.blog.163.com/blog/static/25626832201032990829/\">http://sunjun041640.blog.163.com/blog/static/25626832201032990829/</a> <a href=\"http://www.oschina.net/question/12_9192\">http://www.oschina.net/question/12_9192</a> book:RabbitMQ in Action</p>\n','AMQP&RabbitMQ协议及模型入门介绍','','inherit','open','open','','54-revision-7','','','2013-02-28 20:26:48','2013-02-28 12:26:48','','54','http://blog.wachang.net/2013/02/54-revision-7/','0','revision','','0');");
E_D("replace into `wp_posts` values('76','1','2013-03-01 16:40:07','2013-03-01 08:40:07','<blockquote>\n  <p>本文主要罗列了CGI,FASTCGI,PHP-CGI,Spawn-FCGI,PHP-FPM的一些概念，后续做了一些相应的上机演示，主要是以php为例子说明，顺带提到了nginx中PHP环境的构建问题。</p>\n</blockquote>\n\n<h2>1 CGI</h2>\n\n<p>CGI全称是“公共网关接口”(Common Gateway Interface)，HTTP服务器与你的或其它机器上的程序进行“交谈”的一种工具，其程序须运行在网络服务器上。CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如php,perl,tcl等。<code>CGI是一种模型规范</code>，然后我们可以编写一个CGI程序来实现CGI模型中定义的功能。</p>\n\n<p>最常见的例子，服务器S上有一个Web服务W，这个服务W是用php写的，客户C请求服务W，S拿到请求以后就需要执行服务W中的代码，这个时候CGI程序就调用服务W的程序，得到结果后返回给服务器S，S再封装返回信息返回给客户C,或者说CGI直接把结果返回给客户C。</p>\n\n<p>所以CGI你可以认识是一个程序，得到一个请求以后就开启一个线程用来执行php/python/asp脚本用，得到结果后返回给服务器S的程序。</p>\n\n<p>传统CGI接口方式的主要缺点是性能很差，因为每次HTTP服务器遇到动态程序时都需要重新启动脚本解析器来执行解析，然后结果被返回给HTTP服务器。这在处理高并发访问时，几乎是不可用的。另外传统的CGI接口方式安全性也很差，现在已经很少被使用了。</p>\n\n<h2>2 FastCGI</h2>\n\n<p>FastCGI是从CGI发展改进而来的,FastCGI是一个可伸缩地、高速地在HTTP server和动态脚本语言间通信的接口。多数流行的HTTP server都支持FastCGI，包括Apache、Nginx和lighttpd等，同时，FastCGI也被许多脚本语言所支持。</p>\n\n<p>FastCGI接口方式采用C/S结构，可以将HTTP服务器和脚本解析服务器分开，同时在脚本解析服务器上启动一个或者多个脚本解析守护进程。当HTTP服务器每次遇到动态程序时，可以将其直接交付给FastCGI进程来执行，然后将得到的结果返回给浏览器。这种方式可以让HTTP服务器专一地处理静态请求或者将动态脚本服务器的结果返回给客户端，这在很大程度上提高了整个应用系统的性能。</p>\n\n<p>更具体来讲，之前的CGI是遇到动态语言就启动一下CGI进程，而FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次。所以说，<code>fasc-cgi也更像是一种模型规范</code>。</p>\n\n<h2>3 Cgi/Fast-cgi工作原理</h2>\n\n<p>我们以php文件举例，原理同样适合python,asp等。</p>\n\n<h3>3.1 CGI模式下php-cgi</h3>\n\n<p>当请求一个php页面，比如index.php以后，服务器得到请求，这是一个php脚本，服务器看不懂，于是他就启动一个程序php-cgi程序，这个程序就是一个php语言的解释器，类推就还有(python-cgi等等)，这个php-cgi就执行index.php中的代码，得到结构以后返回给客户或者先给服务器再由服务器传递给客户，然后这个php-cgi程序就退出。</p>\n\n<p>所以，php-cgi就是一个程序，用来解释php的。可以如下安装：</p>\n\n<pre><code>apt-get install php-cgi\n</code></pre>\n\n<h3>3.2 Fast-CGI模式</h3>\n\n<p>因为fast-cgi模式就是一个进程不退出，有请求到来时就产生或者调用一个新的进程处理，处理完了相应的处理程序就关闭，而fast-cgi程序又继续等待。<code>所以fast-cgi程序更像是一个管理器，用来管理cgi进程的。</code>结合3.1中所讲，更详细的解释是：</p>\n\n<ul>\n<li>fast-cgi管理进程初始化，启动多个cgi解释进程，比如php环境下就启动多个php-cgi进程。然后就等待服务器的连接。可以使用TCP或者socket方式连接（这是与服务器的连接）。</li>\n<li>当相应的请求到达web服务器的时候，服务器发送到fast-cgi管理程序，fast-cgi管理程序就激活一个cgi进程然后把相关的环境变量（CGI环境变量）和参数发送给这个cgi进程，php中就会发送到php-cgi。</li>\n<li>cgi进程一般都是一个动态语言解释器，所以他执行，php中php-cgi就执行代码，执行完成以后结果返回给fast-cgi，fast-cgi再递交给服务器或者直接给用户，而此时cgi进程就应该退出或者休眠了，在php中，php-cgi此时就关闭了。</li>\n</ul>\n\n<h2>4 总结</h2>\n\n<p>从上面可以总结如下：</p>\n\n<ul>\n<li>CGI就是一个解释动态语言的程序，解释php的一般是php-cgi</li>\n<li>fast-cgi就是一个管理CGI的程序，php中环境有php-fpm，spwan-fcgi等。</li>\n</ul>\n\n<p>但是，php-cgi虽然我们一般认为是一个cgi程序，其实他也是一个fast-cgi程序，通过一些配置也可以完成fast-cgi的功能。具体的实际，我们下一节中说明。</p>\n','CGI/FastCGI学习及实践-1-概念','','publish','open','open','','cgi-fastcgi-study-1','','','2013-03-03 14:58:28','2013-03-03 06:58:28','','0','http://blog.wachang.net/?p=76','0','post','','0');");
E_D("replace into `wp_posts` values('77','1','2013-03-01 16:38:46','2013-03-01 08:38:46','<blockquote>\n  <p>本文主要罗列了CGI,FASTCGI,PHP-CGI,Spawn-FCGI,PHP-FPM的一些概念，后续做了一些相应的上机演示，主要是以php为例子说明，顺带提到了nginx中PHP环境的构建问题。</p>\n</blockquote>\n\n<h2>1 CGI</h2>\n\n<p>CGI全称是“公共网关接口”(Common Gateway Interface)，HTTP服务器与你的或其它机器上的程序进行“交谈”的一种工具，其程序须运行在网络服务器上。CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如php,perl,tcl等。<code>CGI是一种模型规范</code>，然后我们可以编写一个CGI程序来实现CGI模型中定义的功能。</p>\n\n<p>最常见的例子，服务器S上有一个Web服务W，这个服务W是用php写的，客户C请求服务W，S拿到请求以后就需要执行服务W中的代码，这个时候CGI程序就调用服务W的程序，得到结果后返回给服务器S，S再封装返回信息返回给客户C,或者说CGI直接把结果返回给客户C。</p>\n\n<p>所以CGI你可以认识是一个程序，得到一个请求以后就开启一个线程用来执行php/python/asp脚本用，得到结果后返回给服务器S的程序。</p>\n\n<p>传统CGI接口方式的主要缺点是性能很差，因为每次HTTP服务器遇到动态程序时都需要重新启动脚本解析器来执行解析，然后结果被返回给HTTP服务器。这在处理高并发访问时，几乎是不可用的。另外传统的CGI接口方式安全性也很差，现在已经很少被使用了。</p>\n\n<h2>2 FastCGI</h2>\n\n<p>FastCGI是从CGI发展改进而来的,FastCGI是一个可伸缩地、高速地在HTTP server和动态脚本语言间通信的接口。多数流行的HTTP server都支持FastCGI，包括Apache、Nginx和lighttpd等，同时，FastCGI也被许多脚本语言所支持。</p>\n\n<p>FastCGI接口方式采用C/S结构，可以将HTTP服务器和脚本解析服务器分开，同时在脚本解析服务器上启动一个或者多个脚本解析守护进程。当HTTP服务器每次遇到动态程序时，可以将其直接交付给FastCGI进程来执行，然后将得到的结果返回给浏览器。这种方式可以让HTTP服务器专一地处理静态请求或者将动态脚本服务器的结果返回给客户端，这在很大程度上提高了整个应用系统的性能。</p>\n\n<p>更具体来讲，之前的CGI是遇到动态语言就启动一下CGI进程，而FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次。所以说，<code>fasc-cgi也更像是一种模型规范</code>。</p>\n\n<h2>3 Cgi/Fast-cgi工作原理</h2>\n\n<p>我们以php文件举例，原理同样适合python,asp等。</p>\n\n<h3>3.1 CGI模式下php-cgi</h3>\n\n<p>当请求一个php页面，比如index.php以后，服务器得到请求，这是一个php脚本，服务器看不懂，于是他就启动一个程序php-cgi程序，这个程序就是一个php语言的解释器，类推就还有(python-cgi等等)，这个php-cgi就执行index.php中的代码，得到结构以后返回给客户或者先给服务器再由服务器传递给客户，然后这个php-cgi程序就退出。</p>\n\n<p>所以，php-cgi就是一个程序，用来解释php的。可以如下安装：</p>\n\n<pre><code>apt-get install php-cgi\n</code></pre>\n\n<h3>3.2 Fast-CGI模式</h3>\n\n<p>因为fast-cgi模式就是一个进程不退出，有请求到来时就产生或者调用一个新的进程处理，处理完了相应的处理程序就关闭，而fast-cgi程序又继续等待。<code>所以fast-cgi程序更像是一个管理器，用来管理cgi进程的。</code>结合3.1中所讲，更详细的解释是：</p>\n\n<ul>\n<li>fast-cgi管理进程初始化，启动多个cgi解释进程，比如php环境下就启动多个php-cgi进程。然后就等待服务器的连接。可以使用TCP或者socket方式连接（这是与服务器的连接）。</li>\n<li>当相应的请求到达web服务器的时候，服务器发送到fast-cgi管理程序，fast-cgi管理程序就激活一个cgi进程然后把相关的环境变量（CGI环境变量）和参数发送给这个cgi进程，php中就会发送到php-cgi。</li>\n<li>cgi进程一般都是一个动态语言解释器，所以他执行，php中php-cgi就执行代码，执行完成以后结果返回给fast-cgi，fast-cgi再递交给服务器或者直接给用户，而此时cgi进程就应该退出或者休眠了，在php中，php-cgi此时就关闭了。</li>\n</ul>\n\n<h2>4 总结</h2>\n\n<p>从上面可以总结如下：</p>\n\n<ul>\n<li>CGI就是一个解释动态语言的程序，解释php的一般是php-cgi</li>\n<li>fast-cgi就是一个管理CGI的程序，php中环境有php-fpm，spwan-fcgi等。</li>\n</ul>\n\n<p>但是，php-cgi虽然我们一般认为是一个cgi程序，其实他也是一个fast-cgi程序，通过一些配置也可以完成fast-cgi的功能。具体的实际，我们下一节中说明。</p>\n','CGI/FastCGI学习及实践-(1)-概念','','inherit','open','open','','76-revision','','','2013-03-01 16:38:46','2013-03-01 08:38:46','','76','http://blog.wachang.net/2013/03/76-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('78','1','2013-03-01 17:07:21','2013-03-01 09:07:21','<p>因为实验室环境需要提高上传文件大小限制，做个记录，如何在Nginx+PHP环境中配置文件上传相关的内容。</p>\n\n<h2>PHP配置:</h2>\n\n<pre><code>root@kb310-node10:/etc/php5# ls\ncgi  cli  conf.d  fpm\n</code></pre>\n\n<p>根据使用的具体方式，更改相应文件夹下<code>php.ini</code>文件中的选项：</p>\n\n<pre><code>1 max_execution_time\n</code></pre>\n\n<p>变量max&#95;execution&#95;time设置了在强制终止脚本前PHP等待脚本执行完毕的时间，此时间以秒计算。当脚本进入了一个无限循环状态 时此变量非常有用。然而，当存在一个需要很长时间完成的合法活动时（例如上传大型文件），这项功能也会导致操作失败。在这样的情况下必须考虑将此变量值增 加，以避免PHP在脚本正在执行某些重要过程的时候将脚本关闭。允许大文件上传就设置大一点。</p>\n\n<pre><code>2 file_uploads = on\n</code></pre>\n\n<p>是否允许文件上传。</p>\n\n<pre><code>3 upload_max_filesize =2M\n</code></pre>\n\n<p>允许上传文件大小</p>\n\n<pre><code>4 post_max_size\n</code></pre>\n\n<p>同表单提交相关的一个变量是post&#95;max&#95;size，它将控制在采用POST方法进行一次表单提交中PHP所能够接收的最大数据量。需要将默认的8 MB改得更大。相反，应当适当将其降到更为实际的数值。但如果希望使用PHP文件上传功能，则需要将此值改为比upload&#95;max&#95;filesize还要大。</p>\n\n<pre><code>5 max_input_time\n</code></pre>\n\n<p>此变量可以以秒为单位对通过POST、GET以及PUT方式接收数据时间进行限制。如果应用程序所运行环境处在低速链路上，则需要增加此值以适应接收数据所需的更多时间.</p>\n\n<pre><code>6 memory_limit =10M\n</code></pre>\n\n<p>为了避免正在运行的脚本大量使用系统可用内存，PHP允许定义内存使用限额。通过memory&#95;limit变量来指定单个脚本程序可以使用的最大内存容量，变量memory&#95;limit的值(不要超出服务器内寸最大值)</p>\n\n<h2>Nginx配置</h2>\n\n<p>貌似不需要进行设置。</p>\n\n<h2>参考资料：</h2>\n\n<p><a href=\"http://bbs.php100.com/read-htm-tid-297084.html\">http://bbs.php100.com/read-htm-tid-297084.html</a></p>\n','Nginx+PHP环境上传文件配置 ','','publish','open','open','','nginx-php-configure-fileupload','','','2013-03-02 20:43:27','2013-03-02 12:43:27','','0','http://blog.wachang.net/?p=78','0','post','','0');");
E_D("replace into `wp_posts` values('79','1','2013-03-01 17:05:52','2013-03-01 09:05:52','<p>因为实验室环境需要提高上传文件大小限制，做个记录，如何在Nginx+PHP环境中配置文件上传相关的内容。</p>\n\n<h2>PHP配置文件:</h2>\n\n<pre><code>root@kb310-node10:/etc/php5# ls\ncgi  cli  conf.d  fpm\n</code></pre>\n\n<p>根据使用的具体方式，更改相应文件夹下<code>php.ini</code>文件中的选项：</p>\n\n<pre><code>1 max_execution_time\n</code></pre>\n\n<p>变量max_execution_time设置了在强制终止脚本前PHP等待脚本执行完毕的时间，此时间以秒计算。当脚本进入了一个无限循环状态 时此变量非常有用。然而，当存在一个需要很长时间完成的合法活动时（例如上传大型文件），这项功能也会导致操作失败。在这样的情况下必须考虑将此变量值增 加，以避免PHP在脚本正在执行某些重要过程的时候将脚本关闭。允许大文件上传就设置大一点。</p>\n\n<pre><code>2 file_uploads = on\n</code></pre>\n\n<p>是否允许文件上传。</p>\n\n<pre><code>3 upload_max_filesize =2M\n</code></pre>\n\n<p>允许上传文件大小</p>\n\n<pre><code>4 post_max_size\n</code></pre>\n\n<p>同表单提交相关的一个变量是post_max_size，它将控制在采用POST方法进行一次表单提交中PHP所能够接收的最大数据量。需要将默认的8 MB改得更大。相反，应当适当将其降到更为实际的数值。但如果希望使用PHP文件上传功能，则需要将此值改为比upload_max_filesize还要大。</p>\n\n<pre><code>5 max_input_time\n</code></pre>\n\n<p>此变量可以以秒为单位对通过POST、GET以及PUT方式接收数据时间进行限制。如果应用程序所运行环境处在低速链路上，则需要增加此值以适应接收数据所需的更多时间.</p>\n\n<pre><code>6 memory_limit =10M\n</code></pre>\n\n<p>为了避免正在运行的脚本大量使用系统可用内存，PHP允许定义内存使用限额。通过memory_limit变量来指定单个脚本程序可以使用的最大内存容量，变量memory_limit的值(不要超出服务器内寸最大值)</p>\n\n<h2>Nginx配置文件</h2>\n\n<p>貌似不需要进行设置。</p>\n\n<h2>参考资料：</h2>\n\n<p><a href=\"http://bbs.php100.com/read-htm-tid-297084.html\">http://bbs.php100.com/read-htm-tid-297084.html</a></p>\n','Nginx+PHP环境上传文件配置 ','','inherit','open','open','','78-revision','','','2013-03-01 17:05:52','2013-03-01 09:05:52','','78','http://blog.wachang.net/2013/03/78-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('80','1','2013-03-01 17:07:21','2013-03-01 09:07:21','<p>因为实验室环境需要提高上传文件大小限制，做个记录，如何在Nginx+PHP环境中配置文件上传相关的内容。</p>\n\n<h2>PHP配置文件:</h2>\n\n<pre><code>root@kb310-node10:/etc/php5# ls\ncgi  cli  conf.d  fpm\n</code></pre>\n\n<p>根据使用的具体方式，更改相应文件夹下<code>php.ini</code>文件中的选项：</p>\n\n<pre><code>1 max_execution_time\n</code></pre>\n\n<p>变量max_execution_time设置了在强制终止脚本前PHP等待脚本执行完毕的时间，此时间以秒计算。当脚本进入了一个无限循环状态 时此变量非常有用。然而，当存在一个需要很长时间完成的合法活动时（例如上传大型文件），这项功能也会导致操作失败。在这样的情况下必须考虑将此变量值增 加，以避免PHP在脚本正在执行某些重要过程的时候将脚本关闭。允许大文件上传就设置大一点。</p>\n\n<pre><code>2 file_uploads = on\n</code></pre>\n\n<p>是否允许文件上传。</p>\n\n<pre><code>3 upload_max_filesize =2M\n</code></pre>\n\n<p>允许上传文件大小</p>\n\n<pre><code>4 post_max_size\n</code></pre>\n\n<p>同表单提交相关的一个变量是post_max_size，它将控制在采用POST方法进行一次表单提交中PHP所能够接收的最大数据量。需要将默认的8 MB改得更大。相反，应当适当将其降到更为实际的数值。但如果希望使用PHP文件上传功能，则需要将此值改为比upload_max_filesize还要大。</p>\n\n<pre><code>5 max_input_time\n</code></pre>\n\n<p>此变量可以以秒为单位对通过POST、GET以及PUT方式接收数据时间进行限制。如果应用程序所运行环境处在低速链路上，则需要增加此值以适应接收数据所需的更多时间.</p>\n\n<pre><code>6 memory_limit =10M\n</code></pre>\n\n<p>为了避免正在运行的脚本大量使用系统可用内存，PHP允许定义内存使用限额。通过memory_limit变量来指定单个脚本程序可以使用的最大内存容量，变量memory_limit的值(不要超出服务器内寸最大值)</p>\n\n<h2>Nginx配置文件</h2>\n\n<p>貌似不需要进行设置。</p>\n\n<h2>参考资料：</h2>\n\n<p><a href=\"http://bbs.php100.com/read-htm-tid-297084.html\">http://bbs.php100.com/read-htm-tid-297084.html</a></p>\n','Nginx+PHP环境上传文件配置 ','','inherit','open','open','','78-revision-2','','','2013-03-01 17:07:21','2013-03-01 09:07:21','','78','http://blog.wachang.net/2013/03/78-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('81','1','2013-03-02 20:40:23','2013-03-02 12:40:23','<p>在上一节中，将到了Fastcgi中的一些概念，这一节就实例展示下。以php环境为例：</p>\n\n<p>从上节中，我们明白了，php-cgi就是一个php的解释器，当服务器接收到一个php文件的时候，就会连接Fastcgi管理程序，连接的方式可以通过TCP连接（fastcgi管理程序监听一个端口）或者unix sock（通过文件读写的方式交互）两种方式，这个管理程序会执行php-cgi这个php解释器，从而得到结果。而这个fastcgi管理程序，就有php-fpm以及spawn-fcgi两个。</p>\n\n<!--more-->\n\n<h2>Php-cgi</h2>\n\n<p>实际上，php-cgi也可以作为一个fast-cgi管理程序，有如下参数：</p>\n\n<pre><code> sudo -u www-data PHP_FCGI_CHILDREN=5 PHP_FCGI_MAX_REQUESTS=125 /usr/bin/php-cgi -q -b 127.0.0.1:9000 &amp;\n</code></pre>\n\n<p>以上就表示启动了5个php-cgi进程，监听地址127.0.0.1:9000，服务器需要把php请求发到这个地址上。此时可以查看进程：</p>\n\n<pre><code>root@kb310-node10:~# ps -e|grep php-cgi\n3527 ?        00:00:00 php-cgi\n3529 ?        00:00:00 php-cgi\n3530 ?        00:00:00 php-cgi\n3531 ?        00:00:00 php-cgi\n3532 ?        00:00:00 php-cgi\n3533 ?        00:00:00 php-cgi\n</code></pre>\n\n<p>而相应的nginx关于php的配置就为：</p>\n\n<pre><code>location ~ .php\$ \n    { \n      fastcgi_pass 127.0.0.1:9000; \n      fastcgi_index index.php; \n      fastcgi_param SCRIPT_FILENAME \$document_root\$fastcgi_script_name; \n      include fastcgi_params; \n    }\n</code></pre>\n\n<p>php-cgi的缺点：</p>\n\n<ul>\n<li>php-cgi变更php.ini配置后需重启php-cgi才能让新的php-ini生效，不可以平滑重启</li>\n<li>直接杀死php-cgi进程,php就不能运行了。(PHP-FPM和Spawn-FCGI就没有这个问题,守护进程会平滑从新生成新的子进程。）</li>\n</ul>\n\n<h2>Php-FPM http://php-fpm.org/</h2>\n\n<p>php-fpm作为一个fasc-cgi管理程序，在CPU和内存方面的控制都比较好,用他来管理php-cgi，有很高的稳定性，如下安装：</p>\n\n<pre><code>apt-get install php5-fpm\n</code></pre>\n\n<p>然后在<code>/etc/php5/fpm</code>中进行配置，php-fpm.conf配置php-fpm的基本信息，这里可以更改<code>采用TCP或者UNIX SOCK</code>以及监视进程数的多少，<code>php.ini</code>是更改php配置，<code>pool.d</code>里面的东西是更改FPM的线程管理机制，一般用epoll，性能好。我自己采用的是UNIX SOCK监听：</p>\n\n<pre><code>##in php-fpm.ini\n[global]\n; Pid file\n; Note: the default prefix is /var\n; Default Value: none\n;pid = run/php-fpm.pid\npid = /var/run/php5-fpm.pid\n</code></pre>\n\n<p>启动并查看服务：</p>\n\n<pre><code>service php5-fpm restart\nroot@kb310-node10:/etc/php5/fpm# ps -e|grep php\n1738 ?        00:00:01 php5-fpm\n1739 ?        00:00:28 php5-fpm\n1740 ?        00:00:31 php5-fpm\n1741 ?        00:00:32 php5-fpm\n</code></pre>\n\n<p>相应nginx中就需要把<code>fastcgi_pass</code>参数更改为：</p>\n\n<pre><code>fastcgi_pass    unix:/var/run/php5-fpm.sock;\n</code></pre>\n\n<p>更多使用说明：</p>\n\n<pre><code>service php5-fpm {start|stop|quit|restart|reload|logrotate}\n--start 启动php的fastcgi进程\n--stop 强制终止php的fastcgi进程\n--quit 平滑终止php的fastcgi进程\n--restart 重启php的fastcgi进程\n--reload 重新平滑加载php的php.ini\n--logrotate 重新启用log文件\n</code></pre>\n\n<h2>Spawn-fcgi http://redmine.lighttpd.net/projects/spawn-fcgi</h2>\n\n<p>和PHP-FPM功能一样，要问他和php-fpm有什么区别，请看<a href=\"http://php-fpm.org/about/\">http://php-fpm.org/about/</a>，使用上：</p>\n\n<pre><code>spawn-fcgi -a 127.0.0.1 -p 9000 -C 10 -u www-data -f /usr/bin/php-cgi\n-f 指定调用FastCGI的进程的执行程序位置，根据系统上所装的PHP的情况具体设置\n-a 绑定到地址addr\n-p 绑定到端口port\n-s 绑定到unix socket的路径path\n-C 指定产生的FastCGI的进程数，默认为5(仅用于PHP)\n-P 指定产生的进程的PID文件路径\n-u和-g FastCGI使用什么身份(-u 用户 -g 用户组)运行，Ubuntu下可以使用www-data，其他的根据情况配置，如nobody、apache等\n</code></pre>\n\n<h2>参考文章：</h2>\n\n<p><a href=\"http://www.fastcgi.com/drupal/node/2\">FAST-CGI主页</a></p>\n\n<p><a href=\"http://www.mike.org.cn/articles/what-is-cgi-fastcgi-php-fpm-spawn-fcgi/\">http://www.mike.org.cn/articles/what-is-cgi-fastcgi-php-fpm-spawn-fcgi/</a></p>\n\n<p><a href=\"http://www.myhack58.com/Article/sort099/sort0102/2012/33364.htm\">http://www.myhack58.com/Article/sort099/sort0102/2012/33364.htm</a></p>\n\n<p><a href=\"http://wenku.baidu.com/view/1215375e3b3567ec102d8a67.html\">http://wenku.baidu.com/view/1215375e3b3567ec102d8a67.html</a></p>\n\n<p><a href=\"http://www.ayuelee.cn/fastcgi-spawn-fcgi-init-script.html\">http://www.ayuelee.cn/fastcgi-spawn-fcgi-init-script.html</a></p>\n\n<p><a href=\"http://hi.baidu.com/winsyk/item/7958e1313dbccdbd633aff8e\">http://hi.baidu.com/winsyk/item/7958e1313dbccdbd633aff8e</a></p>\n','CGI/FastCGI学习及实践-2-实践','','publish','open','open','','cgi-fastcgi-study-2','','http://www.mike.org.cn/articles/what-is-cgi-fastcgi-php-fpm-spawn-fcgi/\nhttp://www.mike.org.cn/articles/what-is-cgi-fastcgi-php-fpm-spawn-fcgi/','2013-03-08 16:44:10','2013-03-08 08:44:10','','0','http://blog.wachang.net/?p=81','0','post','','0');");
E_D("replace into `wp_posts` values('82','1','2013-03-01 18:19:40','2013-03-01 10:19:40','<p>http://www.myhack58.com/Article/sort099/sort0102/2012/33364.htm\nhttp://wenku.baidu.com/view/1215375e3b3567ec102d8a67.html\nhttp://php-fpm.org/\nhttp://www.ayuelee.cn/fastcgi-spawn-fcgi-init-script.html\nhttp://www.fastcgi.com/drupal/\nhttp://hi.baidu.com/winsyk/item/7958e1313dbccdbd633aff8e</p>\n\n<p>wordpress：\nhttp://rtcamp.com/tutorials/installing-fresh-wordpress-on-nginx-server-minimal-configuration/\nhttp://rtcamp.com/series/wordpress-nginx-tutorials/\nhttp://rtcamp.com/tutorials/nginx-php-fpm-socket-tcp-ip-sysctl-tweaking/</p>\n','CGI/FastCGI学习及实践-(1)-实践','','inherit','open','open','','81-revision','','','2013-03-01 18:19:40','2013-03-01 10:19:40','','81','http://blog.wachang.net/2013/03/81-revision/','0','revision','','0');");
E_D("replace into `wp_posts` values('83','1','2013-03-02 20:38:34','2013-03-02 12:38:34','<p>在上一节中，将到了Fastcgi中的一些概念，这一节就实例展示下。以php环境为例：</p>\n\n<p>从上节中，我们明白了，php-cgi就是一个php的解释器，当服务器接收到一个php文件的时候，就会连接Fastcgi管理程序，连接的方式可以通过TCP连接（fastcgi管理程序监听一个端口）或者unix sock（通过文件读写的方式交互）两种方式，这个管理程序会执行php-cgi这个php解释器，从而得到结果。而这个fastcgi管理程序，就有php-fpm以及spawn-fcgi两个。</p>\n\n<h2>Php-cgi</h2>\n\n<p>实际上，php-cgi也可以作为一个fast-cgi管理程序，有如下参数：</p>\n\n<pre><code> sudo -u www-data PHP_FCGI_CHILDREN=5 PHP_FCGI_MAX_REQUESTS=125 /usr/bin/php-cgi -q -b 127.0.0.1:9000 &amp;\n</code></pre>\n\n<p>以上就表示启动了5个php-cgi进程，监听地址127.0.0.1:9000，服务器需要把php请求发到这个地址上。此时可以查看进程：</p>\n\n<pre><code>root@kb310-node10:~# ps -e|grep php-cgi\n3527 ?        00:00:00 php-cgi\n3529 ?        00:00:00 php-cgi\n3530 ?        00:00:00 php-cgi\n3531 ?        00:00:00 php-cgi\n3532 ?        00:00:00 php-cgi\n3533 ?        00:00:00 php-cgi\n</code></pre>\n\n<p>而相应的nginx关于php的配置就为：\n    location ~ &#46;php\$ {\n                fastcgi_pass    127.0.0.1:9000;\n                fastcgi_index   index.php;\n                fastcgi_param   SCRIPT_FILENAME \$document_root\$fastcgi_script_name;\n                include         fastcgi_params;\n        }</p>\n\n<p>php-cgi的缺点：</p>\n\n<ul>\n<li>php-cgi变更php.ini配置后需重启php-cgi才能让新的php-ini生效，不可以平滑重启</li>\n<li>直接杀死php-cgi进程,php就不能运行了。(PHP-FPM和Spawn-FCGI就没有这个问题,守护进程会平滑从新生成新的子进程。）</li>\n</ul>\n\n<h2>Php-FPM http://php-fpm.org/</h2>\n\n<p>php-fpm作为一个fasc-cgi管理程序，在CPU和内存方面的控制都比较好,用他来管理php-cgi，有很高的稳定性，如下安装：</p>\n\n<pre><code>apt-get install php5-fpm\n</code></pre>\n\n<p>然后在<code>/etc/php5/fpm</code>中进行配置，php-fpm.conf配置php-fpm的基本信息，这里可以更改<code>采用TCP或者UNIX SOCK</code>以及监视进程数的多少，<code>php.ini</code>是更改php配置，<code>pool.d</code>里面的东西是更改FPM的线程管理机制，一般用epoll，性能好。我自己采用的是UNIX SOCK监听：</p>\n\n<pre><code>##in php-fpm.ini\n[global]\n; Pid file\n; Note: the default prefix is /var\n; Default Value: none\n;pid = run/php-fpm.pid\npid = /var/run/php5-fpm.pid\n</code></pre>\n\n<p>启动并查看服务：</p>\n\n<pre><code>service php5-fpm restart\nroot@kb310-node10:/etc/php5/fpm# ps -e|grep php\n1738 ?        00:00:01 php5-fpm\n1739 ?        00:00:28 php5-fpm\n1740 ?        00:00:31 php5-fpm\n1741 ?        00:00:32 php5-fpm\n</code></pre>\n\n<p>相应nginx中就需要把<code>fastcgi_pass</code>参数更改为：</p>\n\n<pre><code>fastcgi_pass    unix:/var/run/php5-fpm.sock;\n</code></pre>\n\n<p>更多使用说明：</p>\n\n<pre><code>service php5-fpm {start|stop|quit|restart|reload|logrotate}\n--start 启动php的fastcgi进程\n--stop 强制终止php的fastcgi进程\n--quit 平滑终止php的fastcgi进程\n--restart 重启php的fastcgi进程\n--reload 重新平滑加载php的php.ini\n--logrotate 重新启用log文件\n</code></pre>\n\n<h2>Spawn-fcgi http://redmine.lighttpd.net/projects/spawn-fcgi</h2>\n\n<p>和PHP-FPM功能一样，要问他和php-fpm有什么区别，请看<a href=\"http://php-fpm.org/about/\">http://php-fpm.org/about/</a>，使用上：</p>\n\n<pre><code>spawn-fcgi -a 127.0.0.1 -p 9000 -C 10 -u www-data -f /usr/bin/php-cgi\n-f 指定调用FastCGI的进程的执行程序位置，根据系统上所装的PHP的情况具体设置\n-a 绑定到地址addr\n-p 绑定到端口port\n-s 绑定到unix socket的路径path\n-C 指定产生的FastCGI的进程数，默认为5(仅用于PHP)\n-P 指定产生的进程的PID文件路径\n-u和-g FastCGI使用什么身份(-u 用户 -g 用户组)运行，Ubuntu下可以使用www-data，其他的根据情况配置，如nobody、apache等\n</code></pre>\n\n<h2>参考文章：</h2>\n\n<p><a href=\"http://www.fastcgi.com/drupal/node/2\">FAST-CGI主页</a></p>\n\n<p><a href=\"http://www.mike.org.cn/articles/what-is-cgi-fastcgi-php-fpm-spawn-fcgi/\">http://www.mike.org.cn/articles/what-is-cgi-fastcgi-php-fpm-spawn-fcgi/</a></p>\n\n<p><a href=\"http://www.myhack58.com/Article/sort099/sort0102/2012/33364.htm\">http://www.myhack58.com/Article/sort099/sort0102/2012/33364.htm</a></p>\n\n<p><a href=\"http://wenku.baidu.com/view/1215375e3b3567ec102d8a67.html\">http://wenku.baidu.com/view/1215375e3b3567ec102d8a67.html</a></p>\n\n<p><a href=\"http://www.ayuelee.cn/fastcgi-spawn-fcgi-init-script.html\">http://www.ayuelee.cn/fastcgi-spawn-fcgi-init-script.html</a></p>\n\n<p><a href=\"http://hi.baidu.com/winsyk/item/7958e1313dbccdbd633aff8e\">http://hi.baidu.com/winsyk/item/7958e1313dbccdbd633aff8e</a></p>\n','CGI/FastCGI学习及实践-(1)-实践','','inherit','open','open','','81-revision-2','','','2013-03-02 20:38:34','2013-03-02 12:38:34','','81','http://blog.wachang.net/2013/03/81-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('84','1','2013-03-02 20:40:23','2013-03-02 12:40:23','<p>在上一节中，将到了Fastcgi中的一些概念，这一节就实例展示下。以php环境为例：</p>\n\n<p>从上节中，我们明白了，php-cgi就是一个php的解释器，当服务器接收到一个php文件的时候，就会连接Fastcgi管理程序，连接的方式可以通过TCP连接（fastcgi管理程序监听一个端口）或者unix sock（通过文件读写的方式交互）两种方式，这个管理程序会执行php-cgi这个php解释器，从而得到结果。而这个fastcgi管理程序，就有php-fpm以及spawn-fcgi两个。</p>\n\n<h2>Php-cgi</h2>\n\n<p>实际上，php-cgi也可以作为一个fast-cgi管理程序，有如下参数：</p>\n\n<pre><code> sudo -u www-data PHP_FCGI_CHILDREN=5 PHP_FCGI_MAX_REQUESTS=125 /usr/bin/php-cgi -q -b 127.0.0.1:9000 &amp;\n</code></pre>\n\n<p>以上就表示启动了5个php-cgi进程，监听地址127.0.0.1:9000，服务器需要把php请求发到这个地址上。此时可以查看进程：</p>\n\n<pre><code>root@kb310-node10:~# ps -e|grep php-cgi\n3527 ?        00:00:00 php-cgi\n3529 ?        00:00:00 php-cgi\n3530 ?        00:00:00 php-cgi\n3531 ?        00:00:00 php-cgi\n3532 ?        00:00:00 php-cgi\n3533 ?        00:00:00 php-cgi\n</code></pre>\n\n<p>而相应的nginx关于php的配置就为：\n    location ~ &#46;php\$ {\n                fastcgi_pass    127.0.0.1:9000;\n                fastcgi_index   index.php;\n                fastcgi_param   SCRIPT_FILENAME \$document_root\$fastcgi_script_name;\n                include         fastcgi_params;\n        }</p>\n\n<p>php-cgi的缺点：</p>\n\n<ul>\n<li>php-cgi变更php.ini配置后需重启php-cgi才能让新的php-ini生效，不可以平滑重启</li>\n<li>直接杀死php-cgi进程,php就不能运行了。(PHP-FPM和Spawn-FCGI就没有这个问题,守护进程会平滑从新生成新的子进程。）</li>\n</ul>\n\n<h2>Php-FPM http://php-fpm.org/</h2>\n\n<p>php-fpm作为一个fasc-cgi管理程序，在CPU和内存方面的控制都比较好,用他来管理php-cgi，有很高的稳定性，如下安装：</p>\n\n<pre><code>apt-get install php5-fpm\n</code></pre>\n\n<p>然后在<code>/etc/php5/fpm</code>中进行配置，php-fpm.conf配置php-fpm的基本信息，这里可以更改<code>采用TCP或者UNIX SOCK</code>以及监视进程数的多少，<code>php.ini</code>是更改php配置，<code>pool.d</code>里面的东西是更改FPM的线程管理机制，一般用epoll，性能好。我自己采用的是UNIX SOCK监听：</p>\n\n<pre><code>##in php-fpm.ini\n[global]\n; Pid file\n; Note: the default prefix is /var\n; Default Value: none\n;pid = run/php-fpm.pid\npid = /var/run/php5-fpm.pid\n</code></pre>\n\n<p>启动并查看服务：</p>\n\n<pre><code>service php5-fpm restart\nroot@kb310-node10:/etc/php5/fpm# ps -e|grep php\n1738 ?        00:00:01 php5-fpm\n1739 ?        00:00:28 php5-fpm\n1740 ?        00:00:31 php5-fpm\n1741 ?        00:00:32 php5-fpm\n</code></pre>\n\n<p>相应nginx中就需要把<code>fastcgi_pass</code>参数更改为：</p>\n\n<pre><code>fastcgi_pass    unix:/var/run/php5-fpm.sock;\n</code></pre>\n\n<p>更多使用说明：</p>\n\n<pre><code>service php5-fpm {start|stop|quit|restart|reload|logrotate}\n--start 启动php的fastcgi进程\n--stop 强制终止php的fastcgi进程\n--quit 平滑终止php的fastcgi进程\n--restart 重启php的fastcgi进程\n--reload 重新平滑加载php的php.ini\n--logrotate 重新启用log文件\n</code></pre>\n\n<h2>Spawn-fcgi http://redmine.lighttpd.net/projects/spawn-fcgi</h2>\n\n<p>和PHP-FPM功能一样，要问他和php-fpm有什么区别，请看<a href=\"http://php-fpm.org/about/\">http://php-fpm.org/about/</a>，使用上：</p>\n\n<pre><code>spawn-fcgi -a 127.0.0.1 -p 9000 -C 10 -u www-data -f /usr/bin/php-cgi\n-f 指定调用FastCGI的进程的执行程序位置，根据系统上所装的PHP的情况具体设置\n-a 绑定到地址addr\n-p 绑定到端口port\n-s 绑定到unix socket的路径path\n-C 指定产生的FastCGI的进程数，默认为5(仅用于PHP)\n-P 指定产生的进程的PID文件路径\n-u和-g FastCGI使用什么身份(-u 用户 -g 用户组)运行，Ubuntu下可以使用www-data，其他的根据情况配置，如nobody、apache等\n</code></pre>\n\n<h2>参考文章：</h2>\n\n<p><a href=\"http://www.fastcgi.com/drupal/node/2\">FAST-CGI主页</a></p>\n\n<p><a href=\"http://www.mike.org.cn/articles/what-is-cgi-fastcgi-php-fpm-spawn-fcgi/\">http://www.mike.org.cn/articles/what-is-cgi-fastcgi-php-fpm-spawn-fcgi/</a></p>\n\n<p><a href=\"http://www.myhack58.com/Article/sort099/sort0102/2012/33364.htm\">http://www.myhack58.com/Article/sort099/sort0102/2012/33364.htm</a></p>\n\n<p><a href=\"http://wenku.baidu.com/view/1215375e3b3567ec102d8a67.html\">http://wenku.baidu.com/view/1215375e3b3567ec102d8a67.html</a></p>\n\n<p><a href=\"http://www.ayuelee.cn/fastcgi-spawn-fcgi-init-script.html\">http://www.ayuelee.cn/fastcgi-spawn-fcgi-init-script.html</a></p>\n\n<p><a href=\"http://hi.baidu.com/winsyk/item/7958e1313dbccdbd633aff8e\">http://hi.baidu.com/winsyk/item/7958e1313dbccdbd633aff8e</a></p>\n','CGI/FastCGI学习及实践-(1)-实践','','inherit','open','open','','81-revision-3','','','2013-03-02 20:40:23','2013-03-02 12:40:23','','81','http://blog.wachang.net/2013/03/81-revision-3/','0','revision','','0');");
E_D("replace into `wp_posts` values('85','1','2013-03-02 20:41:34','2013-03-02 12:41:34','<p>在上一节中，将到了Fastcgi中的一些概念，这一节就实例展示下。以php环境为例：</p>\n\n<p>从上节中，我们明白了，php-cgi就是一个php的解释器，当服务器接收到一个php文件的时候，就会连接Fastcgi管理程序，连接的方式可以通过TCP连接（fastcgi管理程序监听一个端口）或者unix sock（通过文件读写的方式交互）两种方式，这个管理程序会执行php-cgi这个php解释器，从而得到结果。而这个fastcgi管理程序，就有php-fpm以及spawn-fcgi两个。</p>\n\n<h2>Php-cgi</h2>\n\n<p>实际上，php-cgi也可以作为一个fast-cgi管理程序，有如下参数：</p>\n\n<pre><code> sudo -u www-data PHP_FCGI_CHILDREN=5 PHP_FCGI_MAX_REQUESTS=125 /usr/bin/php-cgi -q -b 127.0.0.1:9000 &amp;\n</code></pre>\n\n<p>以上就表示启动了5个php-cgi进程，监听地址127.0.0.1:9000，服务器需要把php请求发到这个地址上。此时可以查看进程：</p>\n\n<pre><code>root@kb310-node10:~# ps -e|grep php-cgi\n3527 ?        00:00:00 php-cgi\n3529 ?        00:00:00 php-cgi\n3530 ?        00:00:00 php-cgi\n3531 ?        00:00:00 php-cgi\n3532 ?        00:00:00 php-cgi\n3533 ?        00:00:00 php-cgi\n</code></pre>\n\n<p>而相应的nginx关于php的配置就为：</p>\n\n<pre><code>location ~ .php\$ \n    { \n      fastcgi\\\\_pass 127.0.0.1:9000; \n      fastcgi\\\\_index index.php; \n      fastcgi\\\\_param SCRIPT\\\\_FILENAME \$document\\\\_root\$fastcgi\\\\_script\\\\_name; \n      include fastcgi\\\\_params; \n    }\n</code></pre>\n\n<p>php-cgi的缺点：</p>\n\n<ul>\n<li>php-cgi变更php.ini配置后需重启php-cgi才能让新的php-ini生效，不可以平滑重启</li>\n<li>直接杀死php-cgi进程,php就不能运行了。(PHP-FPM和Spawn-FCGI就没有这个问题,守护进程会平滑从新生成新的子进程。）</li>\n</ul>\n\n<h2>Php-FPM http://php-fpm.org/</h2>\n\n<p>php-fpm作为一个fasc-cgi管理程序，在CPU和内存方面的控制都比较好,用他来管理php-cgi，有很高的稳定性，如下安装：</p>\n\n<pre><code>apt-get install php5-fpm\n</code></pre>\n\n<p>然后在<code>/etc/php5/fpm</code>中进行配置，php-fpm.conf配置php-fpm的基本信息，这里可以更改<code>采用TCP或者UNIX SOCK</code>以及监视进程数的多少，<code>php.ini</code>是更改php配置，<code>pool.d</code>里面的东西是更改FPM的线程管理机制，一般用epoll，性能好。我自己采用的是UNIX SOCK监听：</p>\n\n<pre><code>##in php-fpm.ini\n[global]\n; Pid file\n; Note: the default prefix is /var\n; Default Value: none\n;pid = run/php-fpm.pid\npid = /var/run/php5-fpm.pid\n</code></pre>\n\n<p>启动并查看服务：</p>\n\n<pre><code>service php5-fpm restart\nroot@kb310-node10:/etc/php5/fpm# ps -e|grep php\n1738 ?        00:00:01 php5-fpm\n1739 ?        00:00:28 php5-fpm\n1740 ?        00:00:31 php5-fpm\n1741 ?        00:00:32 php5-fpm\n</code></pre>\n\n<p>相应nginx中就需要把<code>fastcgi_pass</code>参数更改为：</p>\n\n<pre><code>fastcgi_pass    unix:/var/run/php5-fpm.sock;\n</code></pre>\n\n<p>更多使用说明：</p>\n\n<pre><code>service php5-fpm {start|stop|quit|restart|reload|logrotate}\n--start 启动php的fastcgi进程\n--stop 强制终止php的fastcgi进程\n--quit 平滑终止php的fastcgi进程\n--restart 重启php的fastcgi进程\n--reload 重新平滑加载php的php.ini\n--logrotate 重新启用log文件\n</code></pre>\n\n<h2>Spawn-fcgi http://redmine.lighttpd.net/projects/spawn-fcgi</h2>\n\n<p>和PHP-FPM功能一样，要问他和php-fpm有什么区别，请看<a href=\"http://php-fpm.org/about/\">http://php-fpm.org/about/</a>，使用上：</p>\n\n<pre><code>spawn-fcgi -a 127.0.0.1 -p 9000 -C 10 -u www-data -f /usr/bin/php-cgi\n-f 指定调用FastCGI的进程的执行程序位置，根据系统上所装的PHP的情况具体设置\n-a 绑定到地址addr\n-p 绑定到端口port\n-s 绑定到unix socket的路径path\n-C 指定产生的FastCGI的进程数，默认为5(仅用于PHP)\n-P 指定产生的进程的PID文件路径\n-u和-g FastCGI使用什么身份(-u 用户 -g 用户组)运行，Ubuntu下可以使用www-data，其他的根据情况配置，如nobody、apache等\n</code></pre>\n\n<h2>参考文章：</h2>\n\n<p><a href=\"http://www.fastcgi.com/drupal/node/2\">FAST-CGI主页</a></p>\n\n<p><a href=\"http://www.mike.org.cn/articles/what-is-cgi-fastcgi-php-fpm-spawn-fcgi/\">http://www.mike.org.cn/articles/what-is-cgi-fastcgi-php-fpm-spawn-fcgi/</a></p>\n\n<p><a href=\"http://www.myhack58.com/Article/sort099/sort0102/2012/33364.htm\">http://www.myhack58.com/Article/sort099/sort0102/2012/33364.htm</a></p>\n\n<p><a href=\"http://wenku.baidu.com/view/1215375e3b3567ec102d8a67.html\">http://wenku.baidu.com/view/1215375e3b3567ec102d8a67.html</a></p>\n\n<p><a href=\"http://www.ayuelee.cn/fastcgi-spawn-fcgi-init-script.html\">http://www.ayuelee.cn/fastcgi-spawn-fcgi-init-script.html</a></p>\n\n<p><a href=\"http://hi.baidu.com/winsyk/item/7958e1313dbccdbd633aff8e\">http://hi.baidu.com/winsyk/item/7958e1313dbccdbd633aff8e</a></p>\n','CGI/FastCGI学习及实践-(1)-实践','','inherit','open','open','','81-revision-4','','','2013-03-02 20:41:34','2013-03-02 12:41:34','','81','http://blog.wachang.net/2013/03/81-revision-4/','0','revision','','0');");
E_D("replace into `wp_posts` values('86','1','2013-03-01 16:40:08','2013-03-01 08:40:08','<blockquote>\n  <p>本文主要罗列了CGI,FASTCGI,PHP-CGI,Spawn-FCGI,PHP-FPM的一些概念，后续做了一些相应的上机演示，主要是以php为例子说明，顺带提到了nginx中PHP环境的构建问题。</p>\n</blockquote>\n\n<h2>1 CGI</h2>\n\n<p>CGI全称是“公共网关接口”(Common Gateway Interface)，HTTP服务器与你的或其它机器上的程序进行“交谈”的一种工具，其程序须运行在网络服务器上。CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如php,perl,tcl等。<code>CGI是一种模型规范</code>，然后我们可以编写一个CGI程序来实现CGI模型中定义的功能。</p>\n\n<p>最常见的例子，服务器S上有一个Web服务W，这个服务W是用php写的，客户C请求服务W，S拿到请求以后就需要执行服务W中的代码，这个时候CGI程序就调用服务W的程序，得到结果后返回给服务器S，S再封装返回信息返回给客户C,或者说CGI直接把结果返回给客户C。</p>\n\n<p>所以CGI你可以认识是一个程序，得到一个请求以后就开启一个线程用来执行php/python/asp脚本用，得到结果后返回给服务器S的程序。</p>\n\n<p>传统CGI接口方式的主要缺点是性能很差，因为每次HTTP服务器遇到动态程序时都需要重新启动脚本解析器来执行解析，然后结果被返回给HTTP服务器。这在处理高并发访问时，几乎是不可用的。另外传统的CGI接口方式安全性也很差，现在已经很少被使用了。</p>\n\n<h2>2 FastCGI</h2>\n\n<p>FastCGI是从CGI发展改进而来的,FastCGI是一个可伸缩地、高速地在HTTP server和动态脚本语言间通信的接口。多数流行的HTTP server都支持FastCGI，包括Apache、Nginx和lighttpd等，同时，FastCGI也被许多脚本语言所支持。</p>\n\n<p>FastCGI接口方式采用C/S结构，可以将HTTP服务器和脚本解析服务器分开，同时在脚本解析服务器上启动一个或者多个脚本解析守护进程。当HTTP服务器每次遇到动态程序时，可以将其直接交付给FastCGI进程来执行，然后将得到的结果返回给浏览器。这种方式可以让HTTP服务器专一地处理静态请求或者将动态脚本服务器的结果返回给客户端，这在很大程度上提高了整个应用系统的性能。</p>\n\n<p>更具体来讲，之前的CGI是遇到动态语言就启动一下CGI进程，而FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次。所以说，<code>fasc-cgi也更像是一种模型规范</code>。</p>\n\n<h2>3 Cgi/Fast-cgi工作原理</h2>\n\n<p>我们以php文件举例，原理同样适合python,asp等。</p>\n\n<h3>3.1 CGI模式下php-cgi</h3>\n\n<p>当请求一个php页面，比如index.php以后，服务器得到请求，这是一个php脚本，服务器看不懂，于是他就启动一个程序php-cgi程序，这个程序就是一个php语言的解释器，类推就还有(python-cgi等等)，这个php-cgi就执行index.php中的代码，得到结构以后返回给客户或者先给服务器再由服务器传递给客户，然后这个php-cgi程序就退出。</p>\n\n<p>所以，php-cgi就是一个程序，用来解释php的。可以如下安装：</p>\n\n<pre><code>apt-get install php-cgi\n</code></pre>\n\n<h3>3.2 Fast-CGI模式</h3>\n\n<p>因为fast-cgi模式就是一个进程不退出，有请求到来时就产生或者调用一个新的进程处理，处理完了相应的处理程序就关闭，而fast-cgi程序又继续等待。<code>所以fast-cgi程序更像是一个管理器，用来管理cgi进程的。</code>结合3.1中所讲，更详细的解释是：</p>\n\n<ul>\n<li>fast-cgi管理进程初始化，启动多个cgi解释进程，比如php环境下就启动多个php-cgi进程。然后就等待服务器的连接。可以使用TCP或者socket方式连接（这是与服务器的连接）。</li>\n<li>当相应的请求到达web服务器的时候，服务器发送到fast-cgi管理程序，fast-cgi管理程序就激活一个cgi进程然后把相关的环境变量（CGI环境变量）和参数发送给这个cgi进程，php中就会发送到php-cgi。</li>\n<li>cgi进程一般都是一个动态语言解释器，所以他执行，php中php-cgi就执行代码，执行完成以后结果返回给fast-cgi，fast-cgi再递交给服务器或者直接给用户，而此时cgi进程就应该退出或者休眠了，在php中，php-cgi此时就关闭了。</li>\n</ul>\n\n<h2>4 总结</h2>\n\n<p>从上面可以总结如下：</p>\n\n<ul>\n<li>CGI就是一个解释动态语言的程序，解释php的一般是php-cgi</li>\n<li>fast-cgi就是一个管理CGI的程序，php中环境有php-fpm，spwan-fcgi等。</li>\n</ul>\n\n<p>但是，php-cgi虽然我们一般认为是一个cgi程序，其实他也是一个fast-cgi程序，通过一些配置也可以完成fast-cgi的功能。具体的实际，我们下一节中说明。</p>\n','CGI/FastCGI学习及实践-(1)-概念','','inherit','open','open','','76-revision-2','','','2013-03-01 16:40:08','2013-03-01 08:40:08','','76','http://blog.wachang.net/2013/03/76-revision-2/','0','revision','','0');");
E_D("replace into `wp_posts` values('87','1','2013-03-01 17:07:56','2013-03-01 09:07:56','<p>因为实验室环境需要提高上传文件大小限制，做个记录，如何在Nginx+PHP环境中配置文件上传相关的内容。</p>\n\n<h2>PHP配置:</h2>\n\n<pre><code>root@kb310-node10:/etc/php5# ls\ncgi  cli  conf.d  fpm\n</code></pre>\n\n<p>根据使用的具体方式，更改相应文件夹下<code>php.ini</code>文件中的选项：</p>\n\n<pre><code>1 max_execution_time\n</code></pre>\n\n<p>变量max&#95;execution&#95;time设置了在强制终止脚本前PHP等待脚本执行完毕的时间，此时间以秒计算。当脚本进入了一个无限循环状态 时此变量非常有用。然而，当存在一个需要很长时间完成的合法活动时（例如上传大型文件），这项功能也会导致操作失败。在这样的情况下必须考虑将此变量值增 加，以避免PHP在脚本正在执行某些重要过程的时候将脚本关闭。允许大文件上传就设置大一点。</p>\n\n<pre><code>2 file_uploads = on\n</code></pre>\n\n<p>是否允许文件上传。</p>\n\n<pre><code>3 upload_max_filesize =2M\n</code></pre>\n\n<p>允许上传文件大小</p>\n\n<pre><code>4 post_max_size\n</code></pre>\n\n<p>同表单提交相关的一个变量是post&#95;max&#95;size，它将控制在采用POST方法进行一次表单提交中PHP所能够接收的最大数据量。需要将默认的8 MB改得更大。相反，应当适当将其降到更为实际的数值。但如果希望使用PHP文件上传功能，则需要将此值改为比upload&#95;max&#95;filesize还要大。</p>\n\n<pre><code>5 max_input_time\n</code></pre>\n\n<p>此变量可以以秒为单位对通过POST、GET以及PUT方式接收数据时间进行限制。如果应用程序所运行环境处在低速链路上，则需要增加此值以适应接收数据所需的更多时间.</p>\n\n<pre><code>6 memory_limit =10M\n</code></pre>\n\n<p>为了避免正在运行的脚本大量使用系统可用内存，PHP允许定义内存使用限额。通过memory&#95;limit变量来指定单个脚本程序可以使用的最大内存容量，变量memory&#95;limit的值(不要超出服务器内寸最大值)</p>\n\n<h2>Nginx配置</h2>\n\n<p>貌似不需要进行设置。</p>\n\n<h2>参考资料：</h2>\n\n<p><a href=\"http://bbs.php100.com/read-htm-tid-297084.html\">http://bbs.php100.com/read-htm-tid-297084.html</a></p>\n','Nginx+PHP环境上传文件配置 ','','inherit','open','open','','78-revision-3','','','2013-03-01 17:07:56','2013-03-01 09:07:56','','78','http://blog.wachang.net/2013/03/78-revision-3/','0','revision','','0');");
E_D("replace into `wp_posts` values('88','1','2013-03-02 20:42:05','2013-03-02 12:42:05','<p>在上一节中，将到了Fastcgi中的一些概念，这一节就实例展示下。以php环境为例：</p>\n\n<p>从上节中，我们明白了，php-cgi就是一个php的解释器，当服务器接收到一个php文件的时候，就会连接Fastcgi管理程序，连接的方式可以通过TCP连接（fastcgi管理程序监听一个端口）或者unix sock（通过文件读写的方式交互）两种方式，这个管理程序会执行php-cgi这个php解释器，从而得到结果。而这个fastcgi管理程序，就有php-fpm以及spawn-fcgi两个。</p>\n\n<h2>Php-cgi</h2>\n\n<p>实际上，php-cgi也可以作为一个fast-cgi管理程序，有如下参数：</p>\n\n<pre><code> sudo -u www-data PHP_FCGI_CHILDREN=5 PHP_FCGI_MAX_REQUESTS=125 /usr/bin/php-cgi -q -b 127.0.0.1:9000 &amp;\n</code></pre>\n\n<p>以上就表示启动了5个php-cgi进程，监听地址127.0.0.1:9000，服务器需要把php请求发到这个地址上。此时可以查看进程：</p>\n\n<pre><code>root@kb310-node10:~# ps -e|grep php-cgi\n3527 ?        00:00:00 php-cgi\n3529 ?        00:00:00 php-cgi\n3530 ?        00:00:00 php-cgi\n3531 ?        00:00:00 php-cgi\n3532 ?        00:00:00 php-cgi\n3533 ?        00:00:00 php-cgi\n</code></pre>\n\n<p>而相应的nginx关于php的配置就为：</p>\n\n<pre><code>location ~ .php\$ \n    { \n      fastcgi_pass 127.0.0.1:9000; \n      fastcgi_index index.php; \n      fastcgi_param SCRIPT_FILENAME \$document_root\$fastcgi_script_name; \n      include fastcgi_params; \n    }\n</code></pre>\n\n<p>php-cgi的缺点：</p>\n\n<ul>\n<li>php-cgi变更php.ini配置后需重启php-cgi才能让新的php-ini生效，不可以平滑重启</li>\n<li>直接杀死php-cgi进程,php就不能运行了。(PHP-FPM和Spawn-FCGI就没有这个问题,守护进程会平滑从新生成新的子进程。）</li>\n</ul>\n\n<h2>Php-FPM http://php-fpm.org/</h2>\n\n<p>php-fpm作为一个fasc-cgi管理程序，在CPU和内存方面的控制都比较好,用他来管理php-cgi，有很高的稳定性，如下安装：</p>\n\n<pre><code>apt-get install php5-fpm\n</code></pre>\n\n<p>然后在<code>/etc/php5/fpm</code>中进行配置，php-fpm.conf配置php-fpm的基本信息，这里可以更改<code>采用TCP或者UNIX SOCK</code>以及监视进程数的多少，<code>php.ini</code>是更改php配置，<code>pool.d</code>里面的东西是更改FPM的线程管理机制，一般用epoll，性能好。我自己采用的是UNIX SOCK监听：</p>\n\n<pre><code>##in php-fpm.ini\n[global]\n; Pid file\n; Note: the default prefix is /var\n; Default Value: none\n;pid = run/php-fpm.pid\npid = /var/run/php5-fpm.pid\n</code></pre>\n\n<p>启动并查看服务：</p>\n\n<pre><code>service php5-fpm restart\nroot@kb310-node10:/etc/php5/fpm# ps -e|grep php\n1738 ?        00:00:01 php5-fpm\n1739 ?        00:00:28 php5-fpm\n1740 ?        00:00:31 php5-fpm\n1741 ?        00:00:32 php5-fpm\n</code></pre>\n\n<p>相应nginx中就需要把<code>fastcgi_pass</code>参数更改为：</p>\n\n<pre><code>fastcgi_pass    unix:/var/run/php5-fpm.sock;\n</code></pre>\n\n<p>更多使用说明：</p>\n\n<pre><code>service php5-fpm {start|stop|quit|restart|reload|logrotate}\n--start 启动php的fastcgi进程\n--stop 强制终止php的fastcgi进程\n--quit 平滑终止php的fastcgi进程\n--restart 重启php的fastcgi进程\n--reload 重新平滑加载php的php.ini\n--logrotate 重新启用log文件\n</code></pre>\n\n<h2>Spawn-fcgi http://redmine.lighttpd.net/projects/spawn-fcgi</h2>\n\n<p>和PHP-FPM功能一样，要问他和php-fpm有什么区别，请看<a href=\"http://php-fpm.org/about/\">http://php-fpm.org/about/</a>，使用上：</p>\n\n<pre><code>spawn-fcgi -a 127.0.0.1 -p 9000 -C 10 -u www-data -f /usr/bin/php-cgi\n-f 指定调用FastCGI的进程的执行程序位置，根据系统上所装的PHP的情况具体设置\n-a 绑定到地址addr\n-p 绑定到端口port\n-s 绑定到unix socket的路径path\n-C 指定产生的FastCGI的进程数，默认为5(仅用于PHP)\n-P 指定产生的进程的PID文件路径\n-u和-g FastCGI使用什么身份(-u 用户 -g 用户组)运行，Ubuntu下可以使用www-data，其他的根据情况配置，如nobody、apache等\n</code></pre>\n\n<h2>参考文章：</h2>\n\n<p><a href=\"http://www.fastcgi.com/drupal/node/2\">FAST-CGI主页</a></p>\n\n<p><a href=\"http://www.mike.org.cn/articles/what-is-cgi-fastcgi-php-fpm-spawn-fcgi/\">http://www.mike.org.cn/articles/what-is-cgi-fastcgi-php-fpm-spawn-fcgi/</a></p>\n\n<p><a href=\"http://www.myhack58.com/Article/sort099/sort0102/2012/33364.htm\">http://www.myhack58.com/Article/sort099/sort0102/2012/33364.htm</a></p>\n\n<p><a href=\"http://wenku.baidu.com/view/1215375e3b3567ec102d8a67.html\">http://wenku.baidu.com/view/1215375e3b3567ec102d8a67.html</a></p>\n\n<p><a href=\"http://www.ayuelee.cn/fastcgi-spawn-fcgi-init-script.html\">http://www.ayuelee.cn/fastcgi-spawn-fcgi-init-script.html</a></p>\n\n<p><a href=\"http://hi.baidu.com/winsyk/item/7958e1313dbccdbd633aff8e\">http://hi.baidu.com/winsyk/item/7958e1313dbccdbd633aff8e</a></p>\n','CGI/FastCGI学习及实践-(1)-实践','','inherit','open','open','','81-revision-5','','','2013-03-02 20:42:05','2013-03-02 12:42:05','','81','http://blog.wachang.net/2013/03/81-revision-5/','0','revision','','0');");
E_D("replace into `wp_posts` values('89','1','2013-03-02 20:43:08','2013-03-02 12:43:08','<blockquote>\n  <p>本文主要罗列了CGI,FASTCGI,PHP-CGI,Spawn-FCGI,PHP-FPM的一些概念，后续做了一些相应的上机演示，主要是以php为例子说明，顺带提到了nginx中PHP环境的构建问题。</p>\n</blockquote>\n\n<h2>1 CGI</h2>\n\n<p>CGI全称是“公共网关接口”(Common Gateway Interface)，HTTP服务器与你的或其它机器上的程序进行“交谈”的一种工具，其程序须运行在网络服务器上。CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如php,perl,tcl等。<code>CGI是一种模型规范</code>，然后我们可以编写一个CGI程序来实现CGI模型中定义的功能。</p>\n\n<p>最常见的例子，服务器S上有一个Web服务W，这个服务W是用php写的，客户C请求服务W，S拿到请求以后就需要执行服务W中的代码，这个时候CGI程序就调用服务W的程序，得到结果后返回给服务器S，S再封装返回信息返回给客户C,或者说CGI直接把结果返回给客户C。</p>\n\n<p>所以CGI你可以认识是一个程序，得到一个请求以后就开启一个线程用来执行php/python/asp脚本用，得到结果后返回给服务器S的程序。</p>\n\n<p>传统CGI接口方式的主要缺点是性能很差，因为每次HTTP服务器遇到动态程序时都需要重新启动脚本解析器来执行解析，然后结果被返回给HTTP服务器。这在处理高并发访问时，几乎是不可用的。另外传统的CGI接口方式安全性也很差，现在已经很少被使用了。</p>\n\n<h2>2 FastCGI</h2>\n\n<p>FastCGI是从CGI发展改进而来的,FastCGI是一个可伸缩地、高速地在HTTP server和动态脚本语言间通信的接口。多数流行的HTTP server都支持FastCGI，包括Apache、Nginx和lighttpd等，同时，FastCGI也被许多脚本语言所支持。</p>\n\n<p>FastCGI接口方式采用C/S结构，可以将HTTP服务器和脚本解析服务器分开，同时在脚本解析服务器上启动一个或者多个脚本解析守护进程。当HTTP服务器每次遇到动态程序时，可以将其直接交付给FastCGI进程来执行，然后将得到的结果返回给浏览器。这种方式可以让HTTP服务器专一地处理静态请求或者将动态脚本服务器的结果返回给客户端，这在很大程度上提高了整个应用系统的性能。</p>\n\n<p>更具体来讲，之前的CGI是遇到动态语言就启动一下CGI进程，而FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次。所以说，<code>fasc-cgi也更像是一种模型规范</code>。</p>\n\n<h2>3 Cgi/Fast-cgi工作原理</h2>\n\n<p>我们以php文件举例，原理同样适合python,asp等。</p>\n\n<h3>3.1 CGI模式下php-cgi</h3>\n\n<p>当请求一个php页面，比如index.php以后，服务器得到请求，这是一个php脚本，服务器看不懂，于是他就启动一个程序php-cgi程序，这个程序就是一个php语言的解释器，类推就还有(python-cgi等等)，这个php-cgi就执行index.php中的代码，得到结构以后返回给客户或者先给服务器再由服务器传递给客户，然后这个php-cgi程序就退出。</p>\n\n<p>所以，php-cgi就是一个程序，用来解释php的。可以如下安装：</p>\n\n<pre><code>apt-get install php-cgi\n</code></pre>\n\n<h3>3.2 Fast-CGI模式</h3>\n\n<p>因为fast-cgi模式就是一个进程不退出，有请求到来时就产生或者调用一个新的进程处理，处理完了相应的处理程序就关闭，而fast-cgi程序又继续等待。<code>所以fast-cgi程序更像是一个管理器，用来管理cgi进程的。</code>结合3.1中所讲，更详细的解释是：</p>\n\n<ul>\n<li>fast-cgi管理进程初始化，启动多个cgi解释进程，比如php环境下就启动多个php-cgi进程。然后就等待服务器的连接。可以使用TCP或者socket方式连接（这是与服务器的连接）。</li>\n<li>当相应的请求到达web服务器的时候，服务器发送到fast-cgi管理程序，fast-cgi管理程序就激活一个cgi进程然后把相关的环境变量（CGI环境变量）和参数发送给这个cgi进程，php中就会发送到php-cgi。</li>\n<li>cgi进程一般都是一个动态语言解释器，所以他执行，php中php-cgi就执行代码，执行完成以后结果返回给fast-cgi，fast-cgi再递交给服务器或者直接给用户，而此时cgi进程就应该退出或者休眠了，在php中，php-cgi此时就关闭了。</li>\n</ul>\n\n<h2>4 总结</h2>\n\n<p>从上面可以总结如下：</p>\n\n<ul>\n<li>CGI就是一个解释动态语言的程序，解释php的一般是php-cgi</li>\n<li>fast-cgi就是一个管理CGI的程序，php中环境有php-fpm，spwan-fcgi等。</li>\n</ul>\n\n<p>但是，php-cgi虽然我们一般认为是一个cgi程序，其实他也是一个fast-cgi程序，通过一些配置也可以完成fast-cgi的功能。具体的实际，我们下一节中说明。</p>\n','CGI/FastCGI学习及实践-(1)-概念','','inherit','open','open','','76-revision-3','','','2013-03-02 20:43:08','2013-03-02 12:43:08','','76','http://blog.wachang.net/2013/03/76-revision-3/','0','revision','','0');");
E_D("replace into `wp_posts` values('90','1','2013-03-04 18:34:07','2013-03-04 10:34:07','<p>原来这个不是OpenVPN官方自带的内容，还要自己折腾一下啊，找了些资料，这里提供两种方案，总结如下：</p>\n\n<h2>openvpn-auth-ldap</h2>\n\n<p><a href=\"https://code.google.com/p/openvpn-auth-ldap/\">OpenVPN-AUTH-LDAP</a>这是最常见的方案，不过现在一般Ubuntu现在都已经有编译好的包了，所以不用进行复杂的源码编译了。</p>\n\n<pre><code>apt-get install openvpn-auth-ldap\n</code></pre>\n\n<p>然后，先是配置LDAP认证相关内容：</p>\n\n<pre><code>mkdir /etc/openvpn/auth\ncp /usr/share/doc/openvpn-auth-ldap/examples/auth-ldap.conf /etc/openvpn/auth\n</code></pre>\n\n<p><!--more-->\n编辑文件<code>/etc/openvpn/auth/auth-ldap.conf</code>:</p>\n\n<pre><code>&lt;LDAP&gt;\n# LDAP server URL\nURL     ldap://X.X.X.X\n\n# Bind DN (If your LDAP server doesn''t support anonymous binds)\n# BindDN        uid=Manager,ou=People,dc=example,dc=com\n\n# Bind Password\n# Password  SecretPassword\n\n# Network timeout (in seconds)\nTimeout     15\n\n# Enable Start TLS\nTLSEnable   no ##这里要注意\n\n# Follow LDAP Referrals (anonymously)\nFollowReferrals yes\n\n# TLS CA Certificate File\nTLSCACertFile   /usr/local/etc/ssl/ca.pem\n\n# TLS CA Certificate Directory\nTLSCACertDir    /etc/ssl/certs\n\n# Client Certificate and key\n# If TLS client authentication is required\nTLSCertFile /usr/local/etc/ssl/client-cert.pem\nTLSKeyFile  /usr/local/etc/ssl/client-key.pem\n\n# Cipher Suite\n# The defaults are usually fine here\n# TLSCipherSuite    ALL:!ADH:@STRENGTH\n&lt;/LDAP&gt;\n\n&lt;Authorization&gt;\n# Base DN\nBaseDN      \"ou=People,dc=oinlab\"\n\n# User Search Filter\nSearchFilter    \"(uid=%u)\" ##这里要注意\n\n# Require Group Membership\nRequireGroup    false ##是否开启组验证\n\n# Add non-group members to a PF table (disabled)\n#PFTable    ips_vpn_users\n\n&lt;Group&gt;\n    BaseDN      \"ou=People,dc=oinlab\"\n    SearchFilter    \"(|(cn=developers)(cn=artists))\"\n    MemberAttribute uniqueMember\n    # Add group members to a PF table (disabled)\n    #PFTable    ips_vpn_eng\n&lt;/Group&gt;\n&lt;/Authorization&gt;\n</code></pre>\n\n<p>完了以后在配置OpenVPN中<code>server.conf</code>文件，加入如下：</p>\n\n<pre><code>plugin /usr/lib/openvpn/openvpn-auth-ldap.so /etc/openvpn/auth/auth-ldap.conf\nclient-cert-not-required ##有了LDAP就不需要证书认证了嘛\n</code></pre>\n\n<p>最后就是配置一下客户端了：</p>\n\n<p>客户端的配置简单，去掉<code>cert xxx.crt</code>以及<code>key xxx.key</code>部分，再加上<code>auth-user-pass</code>就OK。如下就是一个简单的例子：</p>\n\n<pre><code>client\ndev tun\nproto udp\nremote X.X.X.X 1194\nresolv-retry infinite\nnobind\nuser nobody\ngroup nobody\npersist-key\npersist-tun\nca ca.crt\n;cert wangchang.crt\n;key wangchang.key\ncomp-lzo\nverb 3\nauth-user-pass\n</code></pre>\n\n<p>参考资料(需要飞过Wall)：</p>\n\n<p><a href=\"http://cheaster.blogspot.com/2009/11/openvpn-auth-over-ldap.html\">http://cheaster.blogspot.com/2009/11/openvpn-auth-over-ldap.html</a></p>\n\n<p><a href=\"http://www.howtoforge.com/setting-up-an-openvpn-server-with-authentication-against-openldap-on-ubuntu-10.04-lts\">http://www.howtoforge.com/setting-up-an-openvpn-server-with-authentication-against-openldap-on-ubuntu-10.04-lts</a></p>\n\n<h2>脚本方式</h2>\n\n<p>有人就是把插件的功能用一个脚本来实现，相对来说，配置没那么复杂，我没测试过，应该可行。下附链接：</p>\n\n<p><a href=\"http://down.51cto.com/data/573688\">CSDN上的一个下载</a></p>\n\n<p><a href=\"http://redmine.debuntu.org/projects/openvpn-ldap-auth/wiki\">http://redmine.debuntu.org/projects/openvpn-ldap-auth/wiki</a></p>\n\n<p><a href=\"http://backreference.org/2012/09/14/openvpn-ldap-authentication/\">http://backreference.org/2012/09/14/openvpn-ldap-authentication/</a></p>\n','OpenVPN配置LDAP认证','','publish','open','open','','openvpn-configure-ldap','','','2013-03-08 16:43:36','2013-03-08 08:43:36','','0','http://blog.wachang.net/?p=90','0','post','','0');");

require("../../inc/footer.php");
?>